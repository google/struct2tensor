{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"","title":"Struct2Tensor","text":""},{"location":"#introduction","title":"Introduction","text":"<p>struct2tensor is a library for parsing structured data inside of tensorflow. In particular, it makes it easy to manipulate structured data, e.g., slicing, flattening, copying substructures, and so on, as part of a TensorFlow model graph. The notebook in 'examples/prensor_playground.ipynb' provides a few examples of struct2tensor in action and an introduction to the main concepts. You can run the notebook in your browser through Google's colab environment, or download the file to run it in your own Jupyter environment.</p> <p>There are two main use cases of this repo:</p> <ol> <li>To create a PIP package. The PIP package contains plug-ins (OpKernels) to an     existing tensorflow installation.</li> <li>To staticlly link with tensorflow-serving.</li> </ol> <p>As these processes are independent, one can follow either set of directions below.</p>"},{"location":"#use-a-pre-built-linux-pip-package","title":"Use a pre-built Linux PIP package.","text":"<p>From a virtual environment, run:</p> <pre><code>pip install struct2tensor\n</code></pre>"},{"location":"#nightly-packages","title":"Nightly Packages","text":"<p>Struct2Tensor also hosts nightly packages at https://pypi-nightly.tensorflow.org on Google Cloud. To install the latest nightly package, please use the following command:</p> <pre><code>pip install --extra-index-url https://pypi-nightly.tensorflow.org/simple struct2tensor\n</code></pre> <p>This will install the nightly packages for the major dependencies of struct2tensor such as TensorFlow Metadata (TFMD).</p>"},{"location":"#creating-a-pip-package","title":"Creating a PIP package.","text":"<p>The struct2tensor PIP package is useful for creating models. It works with tensorflow 2.x.</p> <p>In order to unify the process, we recommend compiling struct2tensor inside a docker container.</p>"},{"location":"#downloading-the-code","title":"Downloading the Code","text":"<p>Go to your home directory.</p> <p>Download the source code.</p> <pre><code>git clone https://github.com/google/struct2tensor.git\ncd ~/struct2tensor\n</code></pre>"},{"location":"#use-docker-compose","title":"Use docker-compose","text":"<p>Install docker-compose.</p> <p>Use it to build a pip wheel for Python 3.8 with tensorflow version 2:</p> <pre><code>docker-compose build --build-arg PYTHON_VERSION=3.8 manylinux2014\ndocker-compose run -e TF_VERSION=RELEASED_TF_2 manylinux2014\n</code></pre> <p>This will create a manylinux package in the ~/struct2tensor/dist directory.</p>"},{"location":"#creating-a-static-library","title":"Creating a static library","text":"<p>In order to construct a static library for tensorflow-serving, we run:</p> <pre><code>bazel build -c opt struct2tensor:struct2tensor_kernels_and_ops\n</code></pre> <p>This can also be linked into another library.</p>"},{"location":"#tensorflow-serving-docker-image","title":"TensorFlow Serving docker image","text":"<p>struct2tensor needs a couple of custom TensorFlow ops to function. If you train a model with struct2tensor and wants to serve it with TensorFlow Serving, the TensorFlow Serving binary needs to link with those custom ops. We have a pre-built docker image that contains such a binary. The <code>Dockerfile</code> is available at <code>tools/tf_serving_docker/Dockerfile</code>. The image is available at <code>gcr.io/tfx-oss-public/s2t_tf_serving</code>.</p> <p>Please see the <code>Dockerfile</code> for details. But in brief, the image exposes port 8500 as the gRPC endpoint and port 8501 as the REST endpoint. You can set two environment variables <code>MODEL_BASE_PATH</code> and <code>MODEL_NAME</code> to point it to your model (either mount it to the container, or put your model on GCS). It will look for a saved model at <code>${MODEL_BASE_PATH}/${MODEL_NAME}/${VERSION_NUMBER}</code>, where <code>VERSION_NUMBER</code> is an integer.</p>"},{"location":"#compatibility","title":"Compatibility","text":"struct2tensor tensorflow 0.48.0 2.17.0 0.47.0 2.16.2 0.46.0 2.15.0 0.45.0 2.13.0 0.44.0 2.12.0 0.43.0 2.11.0 0.42.0 2.10.0 0.41.0 2.9.0 0.40.0 2.9.0 0.39.0 2.8.0 0.38.0 2.8.0 0.37.0 2.7.0 0.36.0 2.7.0 0.35.0 2.6.0 0.34.0 2.6.0 0.33.0 2.5.0 0.32.0 2.5.0 0.31.0 2.5.0 0.30.0 2.4.0 0.29.0 2.4.0 0.28.0 2.4.0 0.27.0 2.4.0 0.26.0 2.3.0 0.25.0 2.3.0 0.24.0 2.3.0 0.23.0 2.3.0 0.22.0 2.2.0 0.21.1 2.1.0 0.21.0 2.1.0 0.0.1.dev* 1.15"},{"location":"api_docs/python/expression_impl/","title":"Module: expression_impl","text":"View source on GitHub      <p>The modules in this file should be accessed like the following:</p> <pre><code>import struct2tensor as s2t\nfrom struct2tensor import expression_impl\n\ns2t.expression_impl.apply_schema\n</code></pre>"},{"location":"api_docs/python/expression_impl/#modules","title":"Modules","text":"<p><code>apply_schema</code> module: Apply a schema to an expression.</p> <p><code>broadcast</code> module: Methods for broadcasting a path in a tree.</p> <p><code>depth_limit</code> module: Caps the depth of an expression.</p> <p><code>filter_expression</code> module: Create a new expression that is a filtered version of an original one.</p> <p><code>index</code> module: get_positional_index and get_index_from_end methods.</p> <p><code>map_prensor</code> module: Arbitrary operations from sparse and ragged tensors to a leaf field.</p> <p><code>map_prensor_to_prensor</code> module: Arbitrary operations from prensors to prensors in an expression.</p> <p><code>map_values</code> module: Maps the values of various leaves of the same child to a single result.</p> <p><code>parquet</code> module: Apache Parquet Dataset.</p> <p><code>placeholder</code> module: Placeholder expression.</p> <p><code>project</code> module: project selects a subtree of an expression.</p> <p><code>promote</code> module: Promote an expression to be a child of its grandparent.</p> <p><code>promote_and_broadcast</code> module: promote_and_broadcast a set of nodes.</p> <p><code>proto</code> module: Expressions to parse a proto.</p> <p><code>reroot</code> module: Reroot to a subtree, maintaining an input proto index.</p> <p><code>size</code> module: Functions for creating new size or has expression.</p> <p><code>slice_expression</code> module: Implementation of slice.</p>"},{"location":"api_docs/python/expression_impl/expression_impl/","title":"<code>expression_impl</code>","text":""},{"location":"api_docs/python/expression_impl/expression_impl/#struct2tensor.expression_impl","title":"struct2tensor.expression_impl","text":"<p>Import all modules in expression_impl.</p> <p>The modules in this file should be accessed like the following:</p> <pre><code>import struct2tensor as s2t\nfrom struct2tensor import expression_impl\n\ns2t.expression_impl.apply_schema\n</code></pre> MODULE DESCRIPTION <code>apply_schema</code> <p>Apply a schema to an expression.</p> <code>broadcast</code> <p>Methods for broadcasting a path in a tree.</p> <code>depth_limit</code> <p>Caps the depth of an expression.</p> <code>filter_expression</code> <p>Create a new expression that is a filtered version of an original one.</p> <code>index</code> <p>get_positional_index and get_index_from_end methods.</p> <code>map_prensor</code> <p>Arbitrary operations from sparse and ragged tensors to a leaf field.</p> <code>map_prensor_to_prensor</code> <p>Arbitrary operations from prensors to prensors in an expression.</p> <code>map_values</code> <p>Maps the values of various leaves of the same child to a single result.</p> <code>parquet</code> <p>Apache Parquet Dataset.</p> <code>parse_message_level_ex</code> <p>Parses regular fields, extensions, any casts, and map protos.</p> <code>placeholder</code> <p>Placeholder expression.</p> <code>project</code> <p>project selects a subtree of an expression.</p> <code>promote</code> <p>Promote an expression to be a child of its grandparent.</p> <code>promote_and_broadcast</code> <p>promote_and_broadcast a set of nodes.</p> <code>proto</code> <p>Expressions to parse a proto.</p> <code>reroot</code> <p>Reroot to a subtree, maintaining an input proto index.</p> <code>size</code> <p>Functions for creating new size or has expression.</p> <code>slice_expression</code> <p>Implementation of slice.</p>"},{"location":"api_docs/python/expression_impl/expression_impl/#struct2tensor.expression_impl-modules","title":"Modules","text":""},{"location":"api_docs/python/expression_impl/expression_impl/#struct2tensor.expression_impl.apply_schema","title":"apply_schema","text":"<p>Apply a schema to an expression.</p> <p>A tensorflow metadata schema (TODO(martinz): link) represents more detailed information about the data: specifically, it presents domain information (e.g., not just integers, but integers between 0 and 10), and more detailed structural information (e.g., this field occurs in at least 70% of its parents, and when it occurs, it shows up 5 to 7 times).</p> <p>Applying a schema attaches a tensorflow metadata schema to an expression: namely, it aligns the features in the schema with the expression's children by name (possibly recursively).</p> <p>After applying a schema to an expression, one can use promote, broadcast, et cetera, and the schema for new expressions will be inferred. If you write a custom expression, you can write code that determines the schema information of the result.</p> <p>To get the schema back, call get_schema().</p> <p>This does not filter out fields not in the schema.</p> <pre><code>my_expr = ...\nmy_schema = # ...schema here...\nmy_new_schema = my_expr.apply_schema(my_schema).get_schema()\n# my_new_schema has semantically identical information on the fields as my_schema.\n</code></pre> <p>TODO(martinz): Add utilities to:</p> <ol> <li>Get the (non-deprecated) paths from a schema.</li> <li>Check if any paths in the schema are not in the expression.</li> <li>Check if any paths in the expression are not in the schema.</li> <li>Project the expression to paths in the schema.</li> </ol> FUNCTION DESCRIPTION <code>apply_schema</code>"},{"location":"api_docs/python/expression_impl/expression_impl/#struct2tensor.expression_impl.apply_schema-functions","title":"Functions","text":""},{"location":"api_docs/python/expression_impl/expression_impl/#struct2tensor.expression_impl.apply_schema.apply_schema","title":"apply_schema","text":"<pre><code>apply_schema(\n    expr: Expression, schema: Schema\n) -&gt; Expression\n</code></pre> Source code in <code>struct2tensor/expression_impl/apply_schema.py</code> <pre><code>def apply_schema(expr: expression.Expression,\n                 schema: schema_pb2.Schema) -&gt; expression.Expression:\n  schema_copy = schema_pb2.Schema()\n  schema_copy.CopyFrom(schema)\n  for x in schema_copy.feature:\n    _normalize_feature(x, schema_copy)\n  return _SchemaExpression(expr, schema_copy.feature, None)\n</code></pre>"},{"location":"api_docs/python/expression_impl/expression_impl/#struct2tensor.expression_impl.apply_schema-modules","title":"Modules","text":""},{"location":"api_docs/python/expression_impl/expression_impl/#struct2tensor.expression_impl.broadcast","title":"broadcast","text":"<p>Methods for broadcasting a path in a tree.</p> <p>This provides methods for broadcasting a field anonymously (that is used in promote_and_broadcast), or with an explicitly given name.</p> <p>Suppose you have an expr representing:</p> <pre><code>+\n|\n+-session*   (stars indicate repeated)\n     |\n     +-event*\n     |\n     +-val*-int64\n</code></pre> <pre><code>session: {\n  event: {}\n  event: {}\n  val: 10\n  val: 11\n}\nsession: {\n  event: {}\n  event: {}\n  val: 20\n}\n</code></pre> <p>Then:</p> <pre><code>broadcast.broadcast(expr, path.Path([\"session\",\"val\"]), \"event\", \"nv\")\n</code></pre> <p>becomes:</p> <pre><code>+\n|\n+---session*   (stars indicate repeated)\n       |\n       +-event*\n       |   |\n       |   +---nv*-int64\n       |\n       +-val*-int64\n</code></pre> <pre><code>session: {\n  event: {\n    nv: 10\n    nv:11\n  }\n  event: {\n    nv: 10\n    nv:11\n  }\n  val: 10\n  val: 11\n}\nsession: {\n  event: {nv: 20}\n  event: {nv: 20}\n  val: 20\n}\n</code></pre> FUNCTION DESCRIPTION <code>broadcast</code> <code>broadcast_anonymous</code>"},{"location":"api_docs/python/expression_impl/expression_impl/#struct2tensor.expression_impl.broadcast-functions","title":"Functions","text":""},{"location":"api_docs/python/expression_impl/expression_impl/#struct2tensor.expression_impl.broadcast.broadcast","title":"broadcast","text":"<pre><code>broadcast(\n    root: Expression,\n    origin: Path,\n    sibling_name: Step,\n    new_field_name: Step,\n) -&gt; Expression\n</code></pre> Source code in <code>struct2tensor/expression_impl/broadcast.py</code> <pre><code>def broadcast(root: expression.Expression, origin: path.Path,\n              sibling_name: path.Step,\n              new_field_name: path.Step) -&gt; expression.Expression:\n  return _broadcast_impl(root, origin, sibling_name, new_field_name)[0]\n</code></pre>"},{"location":"api_docs/python/expression_impl/expression_impl/#struct2tensor.expression_impl.broadcast.broadcast_anonymous","title":"broadcast_anonymous","text":"<pre><code>broadcast_anonymous(\n    root: Expression, origin: Path, sibling: Step\n) -&gt; Tuple[Expression, Path]\n</code></pre> Source code in <code>struct2tensor/expression_impl/broadcast.py</code> <pre><code>def broadcast_anonymous(\n    root: expression.Expression, origin: path.Path,\n    sibling: path.Step) -&gt; Tuple[expression.Expression, path.Path]:\n  return _broadcast_impl(root, origin, sibling, path.get_anonymous_field())\n</code></pre>"},{"location":"api_docs/python/expression_impl/expression_impl/#struct2tensor.expression_impl.broadcast-modules","title":"Modules","text":""},{"location":"api_docs/python/expression_impl/expression_impl/#struct2tensor.expression_impl.depth_limit","title":"depth_limit","text":"<p>Caps the depth of an expression.</p> <p>Suppose you have an expression expr modeled as:</p> <pre><code>  *\n   \\\n    A\n   / \\\n  D   B\n       \\\n        C\n</code></pre> <p>if expr_2 = depth_limit.limit_depth(expr, 2) You get:</p> <pre><code>  *\n   \\\n    A\n   / \\\n  D   B\n</code></pre> FUNCTION DESCRIPTION <code>limit_depth</code> <p>Limit the depth to nodes k steps from expr.</p>"},{"location":"api_docs/python/expression_impl/expression_impl/#struct2tensor.expression_impl.depth_limit-functions","title":"Functions","text":""},{"location":"api_docs/python/expression_impl/expression_impl/#struct2tensor.expression_impl.depth_limit.limit_depth","title":"limit_depth","text":"<pre><code>limit_depth(\n    expr: Expression, depth_limit: int\n) -&gt; Expression\n</code></pre> <p>Limit the depth to nodes k steps from expr.</p> Source code in <code>struct2tensor/expression_impl/depth_limit.py</code> <pre><code>def limit_depth(expr: expression.Expression,\n                depth_limit: int) -&gt; expression.Expression:\n  \"\"\"Limit the depth to nodes k steps from expr.\"\"\"\n  return _DepthLimitExpression(expr, depth_limit)\n</code></pre>"},{"location":"api_docs/python/expression_impl/expression_impl/#struct2tensor.expression_impl.depth_limit-modules","title":"Modules","text":""},{"location":"api_docs/python/expression_impl/expression_impl/#struct2tensor.expression_impl.filter_expression","title":"filter_expression","text":"<p>Create a new expression that is a filtered version of an original one.</p> <p>There are two public methods in this module: filter_by_sibling and filter_by_child. As with most other operations, these create a new tree which has all the original paths of the original tree, but with a new subtree.</p> <p>filter_by_sibling allows you to filter an expression by a boolean sibling field.</p> <p>Beginning with the struct:</p> <pre><code>root =\n         -----*----------------------------------------------------\n        /                       \\                                  \\\n     root0                    root1-----------------------      root2 (empty)\n      /   \\                   /    \\               \\      \\\n      |  keep_my_sib0:False  |  keep_my_sib1:True   | keep_my_sib2:False\n    doc0-----               doc1---------------    doc2--------\n     |       \\                \\           \\    \\               \\\n    bar:\"a\"  keep_me:False    bar:\"b\" bar:\"c\" keep_me:True      bar:\"d\"\n\n# Note, keep_my_sib and doc must have the same shape (e.g., each root\nhas the same number of keep_my_sib children as doc children).\nroot_2 = filter_expression.filter_by_sibling(\n    root, path.create_path(\"doc\"), \"keep_my_sib\", \"new_doc\")\n\nEnd with the struct (suppressing original doc):\n         -----*----------------------------------------------------\n        /                       \\                                  \\\n    root0                    root1------------------        root2 (empty)\n        \\                   /    \\                  \\\n        keep_my_sib0:False  |  keep_my_sib1:True   keep_my_sib2:False\n                           new_doc0-----------\n                             \\           \\    \\\n                             bar:\"b\" bar:\"c\" keep_me:True\n</code></pre> <p>filter_by_sibling allows you to filter an expression by a optional boolean child field.</p> <p>The following call will have the same effect as above:</p> <pre><code>root_2 = filter_expression.filter_by_child(\n    root, path.create_path(\"doc\"), \"keep_me\", \"new_doc\")\n</code></pre> FUNCTION DESCRIPTION <code>filter_by_child</code> <p>Filter an expression by an optional boolean child field.</p> <code>filter_by_sibling</code> <p>Filter an expression by its sibling.</p>"},{"location":"api_docs/python/expression_impl/expression_impl/#struct2tensor.expression_impl.filter_expression-functions","title":"Functions","text":""},{"location":"api_docs/python/expression_impl/expression_impl/#struct2tensor.expression_impl.filter_expression.filter_by_child","title":"filter_by_child","text":"<pre><code>filter_by_child(\n    expr: Expression,\n    p: Path,\n    child_field_name: Step,\n    new_field_name: Step,\n) -&gt; Expression\n</code></pre> <p>Filter an expression by an optional boolean child field.</p> <p>If the child field is present and True, then keep that parent. Otherwise, drop the parent.</p> PARAMETER DESCRIPTION <code>expr</code> <p>the original expression</p> <p> TYPE: <code>Expression</code> </p> <code>p</code> <p>the path to filter.</p> <p> TYPE: <code>Path</code> </p> <code>child_field_name</code> <p>the boolean child field to use to filter.</p> <p> TYPE: <code>Step</code> </p> <code>new_field_name</code> <p>the new, filtered version of path.</p> <p> TYPE: <code>Step</code> </p> RETURNS DESCRIPTION <code>Expression</code> <p>The new root expression.</p> Source code in <code>struct2tensor/expression_impl/filter_expression.py</code> <pre><code>def filter_by_child(expr: expression.Expression, p: path.Path,\n                    child_field_name: path.Step,\n                    new_field_name: path.Step) -&gt; expression.Expression:\n  \"\"\"Filter an expression by an optional boolean child field.\n\n  If the child field is present and True, then keep that parent.\n  Otherwise, drop the parent.\n\n  Args:\n    expr: the original expression\n    p: the path to filter.\n    child_field_name: the boolean child field to use to filter.\n    new_field_name: the new, filtered version of path.\n\n  Returns:\n    The new root expression.\n  \"\"\"\n  origin = expr.get_descendant_or_error(p)\n  child = origin.get_child_or_error(child_field_name)\n  new_expr = _FilterByChildExpression(origin, child)\n  new_path = p.get_parent().get_child(new_field_name)\n\n  return expression_add.add_paths(expr, {new_path: new_expr})\n</code></pre>"},{"location":"api_docs/python/expression_impl/expression_impl/#struct2tensor.expression_impl.filter_expression.filter_by_sibling","title":"filter_by_sibling","text":"<pre><code>filter_by_sibling(\n    expr: Expression,\n    p: Path,\n    sibling_field_name: Step,\n    new_field_name: Step,\n) -&gt; Expression\n</code></pre> <p>Filter an expression by its sibling.</p> <p>This is similar to boolean_mask. The shape of the path being filtered and the sibling must be identical (e.g., each parent object must have an equal number of source and sibling children).</p> PARAMETER DESCRIPTION <code>expr</code> <p>the root expression.</p> <p> TYPE: <code>Expression</code> </p> <code>p</code> <p>a path to the source to be filtered.</p> <p> TYPE: <code>Path</code> </p> <code>sibling_field_name</code> <p>the sibling to use as a mask.</p> <p> TYPE: <code>Step</code> </p> <code>new_field_name</code> <p>a new sibling to create.</p> <p> TYPE: <code>Step</code> </p> RETURNS DESCRIPTION <code>Expression</code> <p>a new root.</p> Source code in <code>struct2tensor/expression_impl/filter_expression.py</code> <pre><code>def filter_by_sibling(expr: expression.Expression, p: path.Path,\n                      sibling_field_name: path.Step,\n                      new_field_name: path.Step) -&gt; expression.Expression:\n  \"\"\"Filter an expression by its sibling.\n\n\n  This is similar to boolean_mask. The shape of the path being filtered and\n  the sibling must be identical (e.g., each parent object must have an\n  equal number of source and sibling children).\n\n  Args:\n    expr: the root expression.\n    p: a path to the source to be filtered.\n    sibling_field_name: the sibling to use as a mask.\n    new_field_name: a new sibling to create.\n\n  Returns:\n    a new root.\n  \"\"\"\n  origin = expr.get_descendant_or_error(p)\n  parent_path = p.get_parent()\n  sibling = expr.get_descendant_or_error(\n      parent_path.get_child(sibling_field_name))\n  new_expr = _FilterBySiblingExpression(origin, sibling)\n  new_path = parent_path.get_child(new_field_name)\n  return expression_add.add_paths(expr, {new_path: new_expr})\n</code></pre>"},{"location":"api_docs/python/expression_impl/expression_impl/#struct2tensor.expression_impl.filter_expression-modules","title":"Modules","text":""},{"location":"api_docs/python/expression_impl/expression_impl/#struct2tensor.expression_impl.index","title":"index","text":"<p>get_positional_index and get_index_from_end methods.</p> <p>The parent_index identifies the index of the parent of each element. These methods take the parent_index to determine the relationship with respect to other elements.</p> <p>Given:</p> <pre><code>session: {\n  event: {\n    val: 111\n  }\n  event: {\n    val: 121\n    val: 122\n  }\n}\n\nsession: {\n  event: {\n    val: 10\n    val: 7\n  }\n  event: {\n    val: 1\n  }\n}\n</code></pre> <pre><code>get_positional_index(expr, path.Path([\"event\",\"val\"]), \"val_index\")\n</code></pre> <p>yields:</p> <pre><code>session: {\n  event: {\n    val: 111\n    val_index: 0\n  }\n  event: {\n    val: 121\n    val: 122\n    val_index: 0\n    val_index: 1\n  }\n}\n\nsession: {\n  event: {\n    val: 10\n    val: 7\n    val_index: 0\n    val_index: 1\n  }\n  event: {\n    val: 1\n    val_index: 0\n  }\n}\n</code></pre> <p></p><pre><code>get_index_from_end(expr, path.Path([\"event\",\"val\"]), \"neg_val_index\")\n</code></pre> yields: <pre><code>session: {\n  event: {\n    val: 111\n    neg_val_index: -1\n  }\n  event: {\n    val: 121\n    val: 122\n    neg_val_index: -2\n    neg_val_index: -1\n  }\n}\n\nsession: {\n  event: {\n    val: 10\n    val: 7\n    neg_val_index: 2\n    neg_val_index: -1\n  }\n  event: {\n    val: 1\n    neg_val_index: -1\n  }\n}\n</code></pre> <p>These methods are useful when you want to depend upon the index of a field. For example, if you want to filter examples based upon their index, or cogroup two fields by index, then first creating the index is useful.</p> <p>Note that while the parent indices of these fields seem like overhead, they are just references to the parent indices of other fields, and are therefore take little memory or CPU.</p> FUNCTION DESCRIPTION <code>get_index_from_end</code> <p>Gets the number of steps from the end of the array.</p> <code>get_positional_index</code> <p>Gets the positional index.</p>"},{"location":"api_docs/python/expression_impl/expression_impl/#struct2tensor.expression_impl.index-functions","title":"Functions","text":""},{"location":"api_docs/python/expression_impl/expression_impl/#struct2tensor.expression_impl.index.get_index_from_end","title":"get_index_from_end","text":"<pre><code>get_index_from_end(\n    t: Expression, source_path: Path, new_field_name: Step\n) -&gt; Tuple[Expression, Path]\n</code></pre> <p>Gets the number of steps from the end of the array.</p> <p>Given an array [\"a\", \"b\", \"c\"], with indices [0, 1, 2], the result of this is [-3,-2,-1].</p> PARAMETER DESCRIPTION <code>t</code> <p>original expression</p> <p> TYPE: <code>Expression</code> </p> <code>source_path</code> <p>path in expression to get index of.</p> <p> TYPE: <code>Path</code> </p> <code>new_field_name</code> <p>the name of the new field.</p> <p> TYPE: <code>Step</code> </p> RETURNS DESCRIPTION <code>Tuple[Expression, Path]</code> <p>The new expression and the new path as a pair.</p> Source code in <code>struct2tensor/expression_impl/index.py</code> <pre><code>def get_index_from_end(t: expression.Expression, source_path: path.Path,\n                       new_field_name: path.Step\n                      ) -&gt; Tuple[expression.Expression, path.Path]:\n  \"\"\"Gets the number of steps from the end of the array.\n\n  Given an array [\"a\", \"b\", \"c\"], with indices [0, 1, 2], the result of this\n  is [-3,-2,-1].\n\n  Args:\n    t: original expression\n    source_path: path in expression to get index of.\n    new_field_name: the name of the new field.\n\n  Returns:\n    The new expression and the new path as a pair.\n  \"\"\"\n  new_path = source_path.get_parent().get_child(new_field_name)\n  work_expr, positional_index_path = get_positional_index(\n      t, source_path, path.get_anonymous_field())\n  work_expr, size_path = size.size_anonymous(work_expr, source_path)\n  work_expr = expression_add.add_paths(\n      work_expr, {\n          new_path:\n              _PositionalIndexFromEndExpression(\n                  work_expr.get_descendant_or_error(positional_index_path),\n                  work_expr.get_descendant_or_error(size_path))\n      })\n  # Removing the intermediate anonymous nodes.\n  result = expression_add.add_to(t, {new_path: work_expr})\n  return result, new_path\n</code></pre>"},{"location":"api_docs/python/expression_impl/expression_impl/#struct2tensor.expression_impl.index.get_positional_index","title":"get_positional_index","text":"<pre><code>get_positional_index(\n    expr: Expression,\n    source_path: Path,\n    new_field_name: Step,\n) -&gt; Tuple[Expression, Path]\n</code></pre> <p>Gets the positional index.</p> <p>Given a field with parent_index [0,1,1,2,3,4,4], this returns: parent_index [0,1,1,2,3,4,4] and value [0,0,1,0,0,0,1]</p> PARAMETER DESCRIPTION <code>expr</code> <p>original expression</p> <p> TYPE: <code>Expression</code> </p> <code>source_path</code> <p>path in expression to get index of.</p> <p> TYPE: <code>Path</code> </p> <code>new_field_name</code> <p>the name of the new field.</p> <p> TYPE: <code>Step</code> </p> RETURNS DESCRIPTION <code>Tuple[Expression, Path]</code> <p>The new expression and the new path as a pair.</p> Source code in <code>struct2tensor/expression_impl/index.py</code> <pre><code>def get_positional_index(expr: expression.Expression, source_path: path.Path,\n                         new_field_name: path.Step\n                        ) -&gt; Tuple[expression.Expression, path.Path]:\n  \"\"\"Gets the positional index.\n\n  Given a field with parent_index [0,1,1,2,3,4,4], this returns:\n  parent_index [0,1,1,2,3,4,4] and value [0,0,1,0,0,0,1]\n\n  Args:\n    expr: original expression\n    source_path: path in expression to get index of.\n    new_field_name: the name of the new field.\n\n  Returns:\n    The new expression and the new path as a pair.\n  \"\"\"\n  new_path = source_path.get_parent().get_child(new_field_name)\n  return expression_add.add_paths(\n      expr, {\n          new_path:\n              _PositionalIndexExpression(\n                  expr.get_descendant_or_error(source_path))\n      }), new_path\n</code></pre>"},{"location":"api_docs/python/expression_impl/expression_impl/#struct2tensor.expression_impl.index-modules","title":"Modules","text":""},{"location":"api_docs/python/expression_impl/expression_impl/#struct2tensor.expression_impl.map_prensor","title":"map_prensor","text":"<p>Arbitrary operations from sparse and ragged tensors to a leaf field.</p> <p>There are two public methods of note right now: map_sparse_tensor and map_ragged_tensor.</p> <p>Assume expr is:</p> <pre><code>session: {\n  event: {\n    val_a: 10\n    val_b: 1\n  }\n  event: {\n    val_a: 20\n    val_b: 2\n  }\n  event: {\n  }\n  event: {\n    val_a: 40\n  }\n  event: {\n    val_b: 5\n  }\n}\n</code></pre> <p>Either of the following alternatives will add val_a and val_b to create val_sum.</p> <p>map_sparse_tensor converts val_a and val_b to sparse tensors, and then add them to produce val_sum.</p> <pre><code>new_root = map_prensor.map_sparse_tensor(\n    expr,\n    path.Path([\"event\"]),\n    [path.Path([\"val_a\"]), path.Path([\"val_b\"])],\n    lambda x,y: x + y,\n    False,\n    tf.int32,\n    \"val_sum\")\n</code></pre> <p>map_ragged_tensor converts val_a and val_b to ragged tensors, and then add them to produce val_sum.</p> <pre><code>new_root = map_prensor.map_ragged_tensor(\n    expr,\n    path.Path([\"event\"]),\n    [path.Path([\"val_a\"]), path.Path([\"val_b\"])],\n    lambda x,y: x + y,\n    False,\n    tf.int32,\n    \"val_sum\")\n</code></pre> <p>The result of either is:</p> <pre><code>session: {\n  event: {\n    val_a: 10\n    val_b: 1\n    val_sum: 11\n  }\n  event: {\n    val_a: 20\n    val_b: 2\n    val_sum: 22\n  }\n  event: {\n  }\n  event: {\n    val_a: 40\n    val_sum: 40\n  }\n  event: {\n    val_b: 5\n    val_sum: 5\n  }\n}\n</code></pre> FUNCTION DESCRIPTION <code>map_ragged_tensor</code> <p>Map a ragged tensor.</p> <code>map_sparse_tensor</code> <p>Maps a sparse tensor.</p>"},{"location":"api_docs/python/expression_impl/expression_impl/#struct2tensor.expression_impl.map_prensor-functions","title":"Functions","text":""},{"location":"api_docs/python/expression_impl/expression_impl/#struct2tensor.expression_impl.map_prensor.map_ragged_tensor","title":"map_ragged_tensor","text":"<pre><code>map_ragged_tensor(\n    root: Expression,\n    root_path: Path,\n    paths: Sequence[Path],\n    operation: Callable[..., RaggedTensor],\n    is_repeated: bool,\n    dtype: DType,\n    new_field_name: Step,\n) -&gt; Expression\n</code></pre> <p>Map a ragged tensor.</p> PARAMETER DESCRIPTION <code>root</code> <p>the root of the expression.</p> <p> TYPE: <code>Expression</code> </p> <code>root_path</code> <p>the path relative to which the ragged tensors are calculated.</p> <p> TYPE: <code>Path</code> </p> <code>paths</code> <p>the input paths relative to the root_path</p> <p> TYPE: <code>Sequence[Path]</code> </p> <code>operation</code> <p>a method that takes the list of ragged tensors as input and returns a ragged tensor.</p> <p> TYPE: <code>Callable[..., RaggedTensor]</code> </p> <code>is_repeated</code> <p>true if the result of operation is repeated.</p> <p> TYPE: <code>bool</code> </p> <code>dtype</code> <p>dtype of the result of the operation.</p> <p> TYPE: <code>DType</code> </p> <code>new_field_name</code> <p>root_path.get_child(new_field_name) is the path of the result.</p> <p> TYPE: <code>Step</code> </p> RETURNS DESCRIPTION <code>Expression</code> <p>A new root expression containing the old root expression plus the new path, root_path.get_child(new_field_name), with the result of the operation.</p> Source code in <code>struct2tensor/expression_impl/map_prensor.py</code> <pre><code>def map_ragged_tensor(root: expression.Expression, root_path: path.Path,\n                      paths: Sequence[path.Path],\n                      operation: Callable[..., tf.RaggedTensor],\n                      is_repeated: bool, dtype: tf.DType,\n                      new_field_name: path.Step) -&gt; expression.Expression:\n  \"\"\"Map a ragged tensor.\n\n  Args:\n    root: the root of the expression.\n    root_path: the path relative to which the ragged tensors are calculated.\n    paths: the input paths relative to the root_path\n    operation: a method that takes the list of ragged tensors as input and\n      returns a ragged tensor.\n    is_repeated: true if the result of operation is repeated.\n    dtype: dtype of the result of the operation.\n    new_field_name: root_path.get_child(new_field_name) is the path of the\n      result.\n\n  Returns:\n    A new root expression containing the old root expression plus the new path,\n      root_path.get_child(new_field_name), with the result of the operation.\n  \"\"\"\n  return _map_ragged_tensor_impl(root, root_path, paths, operation, is_repeated,\n                                 dtype, new_field_name)[0]\n</code></pre>"},{"location":"api_docs/python/expression_impl/expression_impl/#struct2tensor.expression_impl.map_prensor.map_sparse_tensor","title":"map_sparse_tensor","text":"<pre><code>map_sparse_tensor(\n    root: Expression,\n    root_path: Path,\n    paths: Sequence[Path],\n    operation: Callable[..., SparseTensor],\n    is_repeated: bool,\n    dtype: DType,\n    new_field_name: Step,\n) -&gt; Expression\n</code></pre> <p>Maps a sparse tensor.</p> PARAMETER DESCRIPTION <code>root</code> <p>the root of the expression.</p> <p> TYPE: <code>Expression</code> </p> <code>root_path</code> <p>the path relative to which the sparse tensors are calculated.</p> <p> TYPE: <code>Path</code> </p> <code>paths</code> <p>the input paths relative to the root_path</p> <p> TYPE: <code>Sequence[Path]</code> </p> <code>operation</code> <p>a method that takes the list of sparse tensors as input and returns a sparse tensor.</p> <p> TYPE: <code>Callable[..., SparseTensor]</code> </p> <code>is_repeated</code> <p>true if the result of operation is repeated.</p> <p> TYPE: <code>bool</code> </p> <code>dtype</code> <p>dtype of the result of the operation.</p> <p> TYPE: <code>DType</code> </p> <code>new_field_name</code> <p>root_path.get_child(new_field_name) is the path of the result.</p> <p> TYPE: <code>Step</code> </p> RETURNS DESCRIPTION <code>Expression</code> <p>A new root expression containing the old root expression plus the new path, root_path.get_child(new_field_name), with the result of the operation.</p> Source code in <code>struct2tensor/expression_impl/map_prensor.py</code> <pre><code>def map_sparse_tensor(root: expression.Expression, root_path: path.Path,\n                      paths: Sequence[path.Path],\n                      operation: Callable[..., tf.SparseTensor],\n                      is_repeated: bool, dtype: tf.DType,\n                      new_field_name: path.Step) -&gt; expression.Expression:\n  \"\"\"Maps a sparse tensor.\n\n  Args:\n    root: the root of the expression.\n    root_path: the path relative to which the sparse tensors are calculated.\n    paths: the input paths relative to the root_path\n    operation: a method that takes the list of sparse tensors as input and\n      returns a sparse tensor.\n    is_repeated: true if the result of operation is repeated.\n    dtype: dtype of the result of the operation.\n    new_field_name: root_path.get_child(new_field_name) is the path of the\n      result.\n\n  Returns:\n    A new root expression containing the old root expression plus the new path,\n      root_path.get_child(new_field_name), with the result of the operation.\n  \"\"\"\n\n  return _map_sparse_tensor_impl(root, root_path, paths, operation, is_repeated,\n                                 dtype, new_field_name)[0]\n</code></pre>"},{"location":"api_docs/python/expression_impl/expression_impl/#struct2tensor.expression_impl.map_prensor-modules","title":"Modules","text":""},{"location":"api_docs/python/expression_impl/expression_impl/#struct2tensor.expression_impl.map_prensor_to_prensor","title":"map_prensor_to_prensor","text":"<p>Arbitrary operations from prensors to prensors in an expression.</p> <p>This is useful if a single op generates an entire structure. In general, it is better to use the existing expressions framework or design a custom expression than use this op. So long as any of the output is required, all of the input is required.</p> <p>For example, suppose you have an op my_op, that takes a prensor of the form:</p> <pre><code>  event\n   / \\\n foo   bar\n</code></pre> <p>and produces a prensor of the form my_result_schema:</p> <pre><code>   event\n    / \\\n foo2 bar2\n</code></pre> <pre><code>my_result_schema = create_schema(\n    is_repeated=True,\n    children={\"foo2\":{is_repeated:True, dtype:tf.int64},\n              \"bar2\":{is_repeated:False, dtype:tf.int64}})\n</code></pre> <p>If you give it an expression original with the schema:</p> <pre><code> session\n    |\n  event\n  /  \\\nfoo   bar\n</code></pre> <pre><code>result = map_prensor_to_prensor(\n  original,\n  path.Path([\"session\",\"event\"]),\n  my_op,\n  my_result_schema)\n</code></pre> <p>Result will have the schema:</p> <pre><code> session\n    |\n  event--------\n  /  \\    \\    \\\nfoo   bar foo2 bar2\n</code></pre> CLASS DESCRIPTION <code>Schema</code> <p>A finite schema for a prensor.</p> FUNCTION DESCRIPTION <code>create_schema</code> <p>Create a schema recursively.</p> <code>map_prensor_to_prensor</code> <p>Maps an expression to a prensor, and merges that prensor.</p>"},{"location":"api_docs/python/expression_impl/expression_impl/#struct2tensor.expression_impl.map_prensor_to_prensor-classes","title":"Classes","text":""},{"location":"api_docs/python/expression_impl/expression_impl/#struct2tensor.expression_impl.map_prensor_to_prensor.Schema","title":"Schema","text":"<pre><code>Schema(\n    is_repeated: bool = True,\n    dtype: Optional[DType] = None,\n    schema_feature: Optional[Feature] = None,\n    children: Optional[Dict[Step, Schema]] = None,\n)\n</code></pre> <p>               Bases: <code>object</code></p> <p>A finite schema for a prensor.</p> <p>Effectively, this stores everything for the prensor but the tensors themselves.</p> <p>Notice that this is slightly different than schema_pb2.Schema, although similar in nature. At present, there is no clear way to extract is_repeated and dtype from schema_pb2.Schema.</p> <p>See create_schema below for constructing a schema.</p> <p>Note that for LeafNodeTensor, dtype is not None. Also, for ChildNodeTensor and RootNodeTensor, dtype is None. However, a ChildNodeTensor or RootNodeTensor could be childless.</p> <p>Create a new Schema object.</p> PARAMETER DESCRIPTION <code>is_repeated</code> <p>is the root repeated?</p> <p> TYPE: <code>bool</code> DEFAULT: <code>True</code> </p> <code>dtype</code> <p>tf.dtype of the root if the root is a leaf, otherwise None.</p> <p> TYPE: <code>Optional[DType]</code> DEFAULT: <code>None</code> </p> <code>schema_feature</code> <p>schema_pb2.Feature of the root (no struct_domain necessary)</p> <p> TYPE: <code>Optional[Feature]</code> DEFAULT: <code>None</code> </p> <code>children</code> <p>child schemas.</p> <p> TYPE: <code>Optional[Dict[Step, Schema]]</code> DEFAULT: <code>None</code> </p> METHOD DESCRIPTION <code>get_child</code> <code>known_field_names</code> ATTRIBUTE DESCRIPTION <code>is_repeated</code> <p> TYPE: <code>bool</code> </p> <code>schema_feature</code> <p> TYPE: <code>Optional[Feature]</code> </p> <code>type</code> <p> TYPE: <code>Optional[DType]</code> </p> Source code in <code>struct2tensor/expression_impl/map_prensor_to_prensor.py</code> <pre><code>def __init__(self,\n             is_repeated: bool = True,\n             dtype: Optional[tf.DType] = None,\n             schema_feature: Optional[schema_pb2.Feature] = None,\n             children: Optional[Dict[path.Step, \"Schema\"]] = None):\n  \"\"\"Create a new Schema object.\n\n  Args:\n    is_repeated: is the root repeated?\n    dtype: tf.dtype of the root if the root is a leaf, otherwise None.\n    schema_feature: schema_pb2.Feature of the root (no struct_domain\n      necessary)\n    children: child schemas.\n  \"\"\"\n  self._is_repeated = is_repeated\n  self._type = dtype\n  self._schema_feature = schema_feature\n  self._children = children if children is not None else {}\n  # Cannot have a type and children.\n  assert (self._type is None or not self._children)\n</code></pre> Attributes\u00b6 <code></code> is_repeated <code>property</code> \u00b6 <pre><code>is_repeated: bool\n</code></pre> <code></code> schema_feature <code>property</code> \u00b6 <pre><code>schema_feature: Optional[Feature]\n</code></pre> <code></code> type <code>property</code> \u00b6 <pre><code>type: Optional[DType]\n</code></pre> Functions\u00b6 <code></code> get_child \u00b6 <pre><code>get_child(key: Step)\n</code></pre> Source code in <code>struct2tensor/expression_impl/map_prensor_to_prensor.py</code> <pre><code>def get_child(self, key: path.Step):\n  return self._children[key]\n</code></pre> <code></code> known_field_names \u00b6 <pre><code>known_field_names() -&gt; FrozenSet[Step]\n</code></pre> Source code in <code>struct2tensor/expression_impl/map_prensor_to_prensor.py</code> <pre><code>def known_field_names(self) -&gt; FrozenSet[path.Step]:\n  return frozenset(self._children.keys())\n</code></pre>"},{"location":"api_docs/python/expression_impl/expression_impl/#struct2tensor.expression_impl.map_prensor_to_prensor-functions","title":"Functions","text":""},{"location":"api_docs/python/expression_impl/expression_impl/#struct2tensor.expression_impl.map_prensor_to_prensor.create_schema","title":"create_schema","text":"<pre><code>create_schema(\n    is_repeated: bool = True,\n    dtype: Optional[DType] = None,\n    schema_feature: Optional[Feature] = None,\n    children: Optional[Dict[Step, Any]] = None,\n) -&gt; Schema\n</code></pre> <p>Create a schema recursively.</p> <p>Example</p> <pre><code>my_result_schema = create_schema(\n  is_repeated=True,\n  children={\"foo2\":{is_repeated=True, dtype=tf.int64},\n            \"bar2\":{is_repeated=False, dtype=tf.int64}})\n</code></pre> PARAMETER DESCRIPTION <code>is_repeated</code> <p>whether the root is repeated.</p> <p> TYPE: <code>bool</code> DEFAULT: <code>True</code> </p> <code>dtype</code> <p>the dtype of a leaf (None for non-leaves).</p> <p> TYPE: <code>Optional[DType]</code> DEFAULT: <code>None</code> </p> <code>schema_feature</code> <p>the schema_pb2.Feature describing this expression. name and struct_domain need not be specified.</p> <p> TYPE: <code>Optional[Feature]</code> DEFAULT: <code>None</code> </p> <code>children</code> <p>the child schemas. Note that the value type of children is either a Schema or a dictionary of arguments to create_schema.</p> <p> TYPE: <code>Optional[Dict[Step, Any]]</code> DEFAULT: <code>None</code> </p> RETURNS DESCRIPTION <code>Schema</code> <p>a new Schema represented by the inputs.</p> Source code in <code>struct2tensor/expression_impl/map_prensor_to_prensor.py</code> <pre><code>def create_schema(is_repeated: bool = True,\n                  dtype: Optional[tf.DType] = None,\n                  schema_feature: Optional[schema_pb2.Feature] = None,\n                  children: Optional[Dict[path.Step, Any]] = None) -&gt; Schema:\n  \"\"\"Create a schema recursively.\n\n  !!! Example\n      ```python\n      my_result_schema = create_schema(\n        is_repeated=True,\n        children={\"foo2\":{is_repeated=True, dtype=tf.int64},\n                  \"bar2\":{is_repeated=False, dtype=tf.int64}})\n      ```\n\n  Args:\n    is_repeated: whether the root is repeated.\n    dtype: the dtype of a leaf (None for non-leaves).\n    schema_feature: the schema_pb2.Feature describing this expression. name and\n      struct_domain need not be specified.\n    children: the child schemas. Note that the value type of children is either\n      a Schema or a dictionary of arguments to create_schema.\n\n  Returns:\n    a new Schema represented by the inputs.\n  \"\"\"\n  children_dict = children or {}\n  child_schemas = {\n      k: _create_schema_helper(v) for k, v in children_dict.items()\n  }\n  return Schema(\n      is_repeated=is_repeated,\n      dtype=dtype,\n      schema_feature=schema_feature,\n      children=child_schemas)\n</code></pre>"},{"location":"api_docs/python/expression_impl/expression_impl/#struct2tensor.expression_impl.map_prensor_to_prensor.map_prensor_to_prensor","title":"map_prensor_to_prensor","text":"<pre><code>map_prensor_to_prensor(\n    root_expr: Expression,\n    source: Path,\n    paths_needed: Sequence[Path],\n    prensor_op: Callable[[Prensor], Prensor],\n    output_schema: Schema,\n) -&gt; Expression\n</code></pre> <p>Maps an expression to a prensor, and merges that prensor.</p> <p>For example, suppose you have an op my_op, that takes a prensor of the form:</p> <pre><code>  event\n  /  \\\nfoo  bar\n</code></pre> <p>and produces a prensor of the form my_result_schema:</p> <pre><code>  event\n  /  \\\nfoo2 bar2\n</code></pre> <p>If you give it an expression original with the schema:</p> <p></p><pre><code> session\n    |\n  event\n  /  \\\nfoo   bar\n</code></pre> <pre><code>result = map_prensor_to_prensor(\n  original,\n  path.Path([\"session\",\"event\"]),\n  my_op,\n  my_output_schema)\n</code></pre> <p>Result will have the schema:</p> <pre><code> session\n    |\n  event--------\n  /  \\    \\    \\\nfoo   bar foo2 bar2\n</code></pre> PARAMETER DESCRIPTION <code>root_expr</code> <p>the root expression</p> <p> TYPE: <code>Expression</code> </p> <code>source</code> <p>the path where the prensor op is applied.</p> <p> TYPE: <code>Path</code> </p> <code>paths_needed</code> <p>the paths needed for the op.</p> <p> TYPE: <code>Sequence[Path]</code> </p> <code>prensor_op</code> <p>the prensor op</p> <p> TYPE: <code>Callable[[Prensor], Prensor]</code> </p> <code>output_schema</code> <p>the output schema of the op.</p> <p> TYPE: <code>Schema</code> </p> RETURNS DESCRIPTION <code>Expression</code> <p>A new expression where the prensor is merged.</p> Source code in <code>struct2tensor/expression_impl/map_prensor_to_prensor.py</code> <pre><code>def map_prensor_to_prensor(\n    root_expr: expression.Expression, source: path.Path,\n    paths_needed: Sequence[path.Path],\n    prensor_op: Callable[[prensor.Prensor], prensor.Prensor],\n    output_schema: Schema) -&gt; expression.Expression:\n  r\"\"\"Maps an expression to a prensor, and merges that prensor.\n\n  For example, suppose you have an op my_op, that takes a prensor of the form:\n\n  ```\n    event\n    /  \\\n  foo  bar\n  ```\n\n  and produces a prensor of the form my_result_schema:\n\n  ```\n    event\n    /  \\\n  foo2 bar2\n  ```\n\n  If you give it an expression original with the schema:\n\n  ```\n   session\n      |\n    event\n    /  \\\n  foo   bar\n  ```\n  ```python\n  result = map_prensor_to_prensor(\n    original,\n    path.Path([\"session\",\"event\"]),\n    my_op,\n    my_output_schema)\n  ```\n\n  Result will have the schema:\n\n  ```\n   session\n      |\n    event--------\n    /  \\    \\    \\\n  foo   bar foo2 bar2\n  ```\n\n  Args:\n    root_expr: the root expression\n    source: the path where the prensor op is applied.\n    paths_needed: the paths needed for the op.\n    prensor_op: the prensor op\n    output_schema: the output schema of the op.\n\n  Returns:\n    A new expression where the prensor is merged.\n  \"\"\"\n  original_child = root_expr.get_descendant_or_error(source).project(\n      paths_needed)\n  prensor_child = _PrensorOpExpression(original_child, prensor_op,\n                                       output_schema)\n  paths_map = {\n      source.get_child(k): prensor_child.get_child_or_error(k)\n      for k in prensor_child.known_field_names()\n  }\n  result = expression_add.add_paths(root_expr, paths_map)\n  return result\n</code></pre>"},{"location":"api_docs/python/expression_impl/expression_impl/#struct2tensor.expression_impl.map_prensor_to_prensor-modules","title":"Modules","text":""},{"location":"api_docs/python/expression_impl/expression_impl/#struct2tensor.expression_impl.map_values","title":"map_values","text":"<p>Maps the values of various leaves of the same child to a single result.</p> <p>All inputs must have the same shape (parent_index must be equal).</p> <p>The output is given the same shape (output of function must be of equal length).</p> <p>Note that the operations are on 1-D tensors (as opposed to scalars).</p> FUNCTION DESCRIPTION <code>map_many_values</code> <p>Map multiple sibling fields into a new sibling.</p> <code>map_values</code> <p>Map field into a new sibling.</p> <code>map_values_anonymous</code> <p>Map field into a new sibling.</p>"},{"location":"api_docs/python/expression_impl/expression_impl/#struct2tensor.expression_impl.map_values-functions","title":"Functions","text":""},{"location":"api_docs/python/expression_impl/expression_impl/#struct2tensor.expression_impl.map_values.map_many_values","title":"map_many_values","text":"<pre><code>map_many_values(\n    root: Expression,\n    parent_path: Path,\n    source_fields: Sequence[Step],\n    operation: Callable[..., Tensor],\n    dtype: DType,\n    new_field_name: Step,\n) -&gt; Tuple[Expression, Path]\n</code></pre> <p>Map multiple sibling fields into a new sibling.</p> <p>All source fields must have the same shape, and the shape of the output must be the same as well.</p> PARAMETER DESCRIPTION <code>root</code> <p>original root.</p> <p> TYPE: <code>Expression</code> </p> <code>parent_path</code> <p>parent path of all sources and the new field.</p> <p> TYPE: <code>Path</code> </p> <code>source_fields</code> <p>source fields of the operation. Must have the same shape.</p> <p> TYPE: <code>Sequence[Step]</code> </p> <code>operation</code> <p>operation from source_fields to new field.</p> <p> TYPE: <code>Callable[..., Tensor]</code> </p> <code>dtype</code> <p>type of new field.</p> <p> TYPE: <code>DType</code> </p> <code>new_field_name</code> <p>name of the new field.</p> <p> TYPE: <code>Step</code> </p> RETURNS DESCRIPTION <code>Tuple[Expression, Path]</code> <p>The new expression and the new path as a pair.</p> Source code in <code>struct2tensor/expression_impl/map_values.py</code> <pre><code>def map_many_values(\n    root: expression.Expression, parent_path: path.Path,\n    source_fields: Sequence[path.Step], operation: Callable[..., tf.Tensor],\n    dtype: tf.DType,\n    new_field_name: path.Step) -&gt; Tuple[expression.Expression, path.Path]:\n  \"\"\"Map multiple sibling fields into a new sibling.\n\n  All source fields must have the same shape, and the shape of the output\n  must be the same as well.\n\n  Args:\n    root: original root.\n    parent_path: parent path of all sources and the new field.\n    source_fields: source fields of the operation. Must have the same shape.\n    operation: operation from source_fields to new field.\n    dtype: type of new field.\n    new_field_name: name of the new field.\n\n  Returns:\n    The new expression and the new path as a pair.\n  \"\"\"\n  new_path = parent_path.get_child(new_field_name)\n  return expression_add.add_paths(\n      root, {\n          new_path:\n              _MapValuesExpression([\n                  root.get_descendant_or_error(parent_path.get_child(f))\n                  for f in source_fields\n              ], operation, dtype)\n      }), new_path\n</code></pre>"},{"location":"api_docs/python/expression_impl/expression_impl/#struct2tensor.expression_impl.map_values.map_values","title":"map_values","text":"<pre><code>map_values(\n    root: Expression,\n    source_path: Path,\n    operation: Callable[[Tensor], Tensor],\n    dtype: DType,\n    new_field_name: Step,\n) -&gt; Expression\n</code></pre> <p>Map field into a new sibling.</p> <p>The shape of the output must be the same as the input.</p> PARAMETER DESCRIPTION <code>root</code> <p>original root.</p> <p> TYPE: <code>Expression</code> </p> <code>source_path</code> <p>source of the operation.</p> <p> TYPE: <code>Path</code> </p> <code>operation</code> <p>operation from source_fields to new field.</p> <p> TYPE: <code>Callable[[Tensor], Tensor]</code> </p> <code>dtype</code> <p>type of new field.</p> <p> TYPE: <code>DType</code> </p> <code>new_field_name</code> <p>name of the new field.</p> <p> TYPE: <code>Step</code> </p> RETURNS DESCRIPTION <code>Expression</code> <p>The new expression.</p> Source code in <code>struct2tensor/expression_impl/map_values.py</code> <pre><code>def map_values(root: expression.Expression, source_path: path.Path,\n               operation: Callable[[tf.Tensor], tf.Tensor], dtype: tf.DType,\n               new_field_name: path.Step) -&gt; expression.Expression:\n  \"\"\"Map field into a new sibling.\n\n  The shape of the output must be the same as the input.\n\n  Args:\n    root: original root.\n    source_path: source of the operation.\n    operation: operation from source_fields to new field.\n    dtype: type of new field.\n    new_field_name: name of the new field.\n\n  Returns:\n    The new expression.\n  \"\"\"\n  if not source_path:\n    raise ValueError('Cannot map the root.')\n  return map_many_values(root, source_path.get_parent(),\n                         [source_path.field_list[-1]], operation, dtype,\n                         new_field_name)[0]\n</code></pre>"},{"location":"api_docs/python/expression_impl/expression_impl/#struct2tensor.expression_impl.map_values.map_values_anonymous","title":"map_values_anonymous","text":"<pre><code>map_values_anonymous(\n    root: Expression,\n    source_path: Path,\n    operation: Callable[[Tensor], Tensor],\n    dtype: DType,\n) -&gt; Tuple[Expression, Path]\n</code></pre> <p>Map field into a new sibling.</p> <p>The shape of the output must be the same as the input.</p> PARAMETER DESCRIPTION <code>root</code> <p>original root.</p> <p> TYPE: <code>Expression</code> </p> <code>source_path</code> <p>source of the operation.</p> <p> TYPE: <code>Path</code> </p> <code>operation</code> <p>operation from source_fields to new field.</p> <p> TYPE: <code>Callable[[Tensor], Tensor]</code> </p> <code>dtype</code> <p>type of new field.</p> <p> TYPE: <code>DType</code> </p> RETURNS DESCRIPTION <code>Tuple[Expression, Path]</code> <p>The new expression and the new path as a pair.</p> Source code in <code>struct2tensor/expression_impl/map_values.py</code> <pre><code>def map_values_anonymous(\n    root: expression.Expression, source_path: path.Path,\n    operation: Callable[[tf.Tensor], tf.Tensor],\n    dtype: tf.DType) -&gt; Tuple[expression.Expression, path.Path]:\n  \"\"\"Map field into a new sibling.\n\n  The shape of the output must be the same as the input.\n\n  Args:\n    root: original root.\n    source_path: source of the operation.\n    operation: operation from source_fields to new field.\n    dtype: type of new field.\n\n  Returns:\n    The new expression and the new path as a pair.\n  \"\"\"\n  if not source_path:\n    raise ValueError('Cannot map the root.')\n  return map_many_values(root, source_path.get_parent(),\n                         [source_path.field_list[-1]], operation, dtype,\n                         path.get_anonymous_field())\n</code></pre>"},{"location":"api_docs/python/expression_impl/expression_impl/#struct2tensor.expression_impl.map_values-modules","title":"Modules","text":""},{"location":"api_docs/python/expression_impl/expression_impl/#struct2tensor.expression_impl.parquet","title":"parquet","text":"<p>Apache Parquet Dataset.</p> <p>Example Usage</p> <pre><code>exp = create_expression_from_parquet_file(filenames)\ndocid_project_exp = project.project(exp, [path.Path([\"DocId\"])])\npqds = parquet_dataset.calculate_parquet_values([docid_project_exp], exp,\n                                                filenames, batch_size)\n\nfor prensors in pqds:\n  doc_id_prensor = prensors[0]\n</code></pre> CLASS DESCRIPTION <code>ParquetDataset</code> <p>A dataset which reads columns from a parquet file and returns a prensor.</p> FUNCTION DESCRIPTION <code>calculate_parquet_values</code> <p>Calculates expressions and returns a parquet dataset.</p> <code>create_expression_from_parquet_file</code> <p>Creates a placeholder expression from a parquet file.</p>"},{"location":"api_docs/python/expression_impl/expression_impl/#struct2tensor.expression_impl.parquet-classes","title":"Classes","text":""},{"location":"api_docs/python/expression_impl/expression_impl/#struct2tensor.expression_impl.parquet.ParquetDataset","title":"ParquetDataset","text":"<pre><code>ParquetDataset(\n    filenames: List[str],\n    value_paths: List[str],\n    batch_size: int,\n)\n</code></pre> <p>               Bases: <code>_RawParquetDataset</code></p> <p>A dataset which reads columns from a parquet file and returns a prensor.</p> <p>The prensor will have a PrensorTypeSpec, which is created based on value_paths.</p> <p>Note</p> <p>In tensorflow v1 this dataset will not return a prensor. The output will be the same format as _RawParquetDataset's output (a vector of tensors). The following is a workaround in v1:</p> <pre><code>pq_ds = ParquetDataset(...)\ntype_spec = pq_ds.element_spec\ntensors = pq_ds.make_one_shot_iterator().get_next()\nprensor = type_spec.from_components(tensors)\nsession.run(prensor)\n</code></pre> <p>Creates a ParquetDataset.</p> PARAMETER DESCRIPTION <code>filenames</code> <p>A list containing the name(s) of the file(s) to be read.</p> <p> TYPE: <code>List[str]</code> </p> <code>value_paths</code> <p>A list of strings of the dotstring path(s) of each leaf path(s).</p> <p> TYPE: <code>List[str]</code> </p> <code>batch_size</code> <p>An int that determines how many messages are parsed into one prensor tree in an iteration. If there are fewer than batch_size remaining messages, then all remaining messages will be returned.</p> <p> TYPE: <code>int</code> </p> RAISES DESCRIPTION <code>ValueError</code> <p>if the column does not exist in the parquet schema.</p> ATTRIBUTE DESCRIPTION <code>element_spec</code> <p> </p> <code>element_structure</code> <p> </p> <code>output_classes</code> <p> </p> <code>output_shapes</code> <p> </p> <code>output_types</code> <p> </p> Source code in <code>struct2tensor/expression_impl/parquet.py</code> <pre><code>def __init__(self, filenames: List[str], value_paths: List[str],\n             batch_size: int):\n  \"\"\"Creates a ParquetDataset.\n\n  Args:\n    filenames: A list containing the name(s) of the file(s) to be read.\n    value_paths: A list of strings of the dotstring path(s) of each leaf\n      path(s).\n    batch_size: An int that determines how many messages are parsed into one\n      prensor tree in an iteration. If there are fewer than batch_size\n      remaining messages, then all remaining messages will be returned.\n\n  Raises:\n    ValueError: if the column does not exist in the parquet schema.\n  \"\"\"\n  self._filenames = filenames\n  self._value_paths = value_paths\n  self._batch_size = batch_size\n\n  for filename in filenames:\n    self._validate_file(filename, value_paths)\n\n  self._value_dtypes = self._get_column_dtypes(filenames[0], value_paths)\n\n  self._parent_index_paths = []\n  self._path_index = []\n\n  self.element_structure = self._create_prensor_spec()\n  self._create_parent_index_paths_and_index_from_type_spec(\n      self.element_structure, 0, 0)\n\n  super(ParquetDataset,\n        self).__init__(filenames, self._value_paths, self._value_dtypes,\n                       self._parent_index_paths, self._path_index, batch_size)\n</code></pre> Attributes\u00b6 <code></code> element_spec <code>property</code> \u00b6 <pre><code>element_spec\n</code></pre> <code></code> element_structure <code>instance-attribute</code> \u00b6 <pre><code>element_structure = _create_prensor_spec()\n</code></pre> <code></code> output_classes <code>property</code> \u00b6 <pre><code>output_classes\n</code></pre> <code></code> output_shapes <code>property</code> \u00b6 <pre><code>output_shapes\n</code></pre> <code></code> output_types <code>property</code> \u00b6 <pre><code>output_types\n</code></pre> Functions\u00b6"},{"location":"api_docs/python/expression_impl/expression_impl/#struct2tensor.expression_impl.parquet-functions","title":"Functions","text":""},{"location":"api_docs/python/expression_impl/expression_impl/#struct2tensor.expression_impl.parquet.calculate_parquet_values","title":"calculate_parquet_values","text":"<pre><code>calculate_parquet_values(\n    expressions: List[Expression],\n    root_exp: _PlaceholderRootExpression,\n    filenames: List[str],\n    batch_size: int,\n    options: Optional[Options] = None,\n)\n</code></pre> <p>Calculates expressions and returns a parquet dataset.</p> PARAMETER DESCRIPTION <code>expressions</code> <p>A list of expressions to calculate.</p> <p> TYPE: <code>List[Expression]</code> </p> <code>root_exp</code> <p>The root placeholder expression to use as the feed dict.</p> <p> TYPE: <code>_PlaceholderRootExpression</code> </p> <code>filenames</code> <p>A list of parquet files.</p> <p> TYPE: <code>List[str]</code> </p> <code>batch_size</code> <p>The number of messages to batch.</p> <p> TYPE: <code>int</code> </p> <code>options</code> <p>calculate options.</p> <p> TYPE: <code>Optional[Options]</code> DEFAULT: <code>None</code> </p> RETURNS DESCRIPTION <p>A parquet dataset.</p> Source code in <code>struct2tensor/expression_impl/parquet.py</code> <pre><code>def calculate_parquet_values(\n    expressions: List[expression.Expression],\n    root_exp: placeholder._PlaceholderRootExpression,  # pylint: disable=protected-access\n    filenames: List[str],\n    batch_size: int,\n    options: Optional[calculate_options.Options] = None):\n  \"\"\"Calculates expressions and returns a parquet dataset.\n\n  Args:\n    expressions: A list of expressions to calculate.\n    root_exp: The root placeholder expression to use as the feed dict.\n    filenames: A list of parquet files.\n    batch_size: The number of messages to batch.\n    options: calculate options.\n\n  Returns:\n    A parquet dataset.\n  \"\"\"\n  pqds = _ParquetDatasetWithExpression(expressions, root_exp, filenames,\n                                       batch_size, options)\n  return pqds.map(pqds._calculate_prensor)  # pylint: disable=protected-access\n</code></pre>"},{"location":"api_docs/python/expression_impl/expression_impl/#struct2tensor.expression_impl.parquet.create_expression_from_parquet_file","title":"create_expression_from_parquet_file","text":"<pre><code>create_expression_from_parquet_file(\n    filenames: List[str],\n) -&gt; _PlaceholderRootExpression\n</code></pre> <p>Creates a placeholder expression from a parquet file.</p> PARAMETER DESCRIPTION <code>filenames</code> <p>A list of parquet files.</p> <p> TYPE: <code>List[str]</code> </p> RETURNS DESCRIPTION <code>_PlaceholderRootExpression</code> <p>A PlaceholderRootExpression that should be used as the root of an expression graph.</p> Source code in <code>struct2tensor/expression_impl/parquet.py</code> <pre><code>def create_expression_from_parquet_file(\n    filenames: List[str]) -&gt; placeholder._PlaceholderRootExpression:  # pylint: disable=protected-access\n  \"\"\"Creates a placeholder expression from a parquet file.\n\n  Args:\n    filenames: A list of parquet files.\n\n  Returns:\n    A PlaceholderRootExpression that should be used as the root of an expression\n      graph.\n  \"\"\"\n\n  metadata = pq.ParquetFile(filenames[0]).metadata\n  parquet_schema = metadata.schema\n  arrow_schema = parquet_schema.to_arrow_schema()\n\n  root_schema = mpp.create_schema(\n      is_repeated=True,\n      children=_create_children_from_arrow_fields(\n          [arrow_schema.field_by_name(name) for name in arrow_schema.names]))\n\n  # pylint: disable=protected-access\n  return placeholder._PlaceholderRootExpression(root_schema)\n</code></pre>"},{"location":"api_docs/python/expression_impl/expression_impl/#struct2tensor.expression_impl.parquet-modules","title":"Modules","text":""},{"location":"api_docs/python/expression_impl/expression_impl/#struct2tensor.expression_impl.parse_message_level_ex","title":"parse_message_level_ex","text":"<p>Parses regular fields, extensions, any casts, and map protos.</p> <p>This is intended for use within proto.py, not independently.</p> <p>parse_message_level(...) in struct2tensor_ops provides a direct interface to parsing a protocol buffer message. In particular, extensions and regular fields can be directly extracted from the protobuf. However, prensors provide other syntactic sugar to parse protobufs, and parse_message_level_ex(...) handles these in addition to regular fields and extensions.</p> <p>Specifically, consider google.protobuf.Any and proto maps:</p> <pre><code>package foo.bar;\n\nmessage MyMessage {\n  Any my_any = 1;\n  map&lt;string, Baz&gt; my_map = 2;\n}\nmessage Baz {\n  int32 my_int = 1;\n  ...\n}\n</code></pre> <p>Then for MyMessage, the path my_any.(foo.bar.Baz).my_int is an optional path. Also, my_map[x].my_int is an optional path.</p> <pre><code>  MyMessage--------------\n     \\  my_any?          \\ my_map[x]\n      *                   *\n       \\  (foo.bar.Baz)?   \\  my_int?\n        *                   *\n         \\  my_int?\n          *\n</code></pre> <p>Thus, we can run:</p> <pre><code>my_message_serialized_tensor = ...\n\nmy_message_parsed = parse_message_level_ex(\n    my_message_serialized_tensor,\n    MyMessage.DESCRIPTOR,\n    {\"my_any\", \"my_map[x]\"})\n\nmy_any_serialized = my_message_parsed[\"my_any\"].value\n\nmy_any_parsed = parse_message_level_ex(\n    my_any_serialized,\n    Any.DESCRIPTOR,\n    {\"(foo.bar.Baz)\"})\n</code></pre> <p>At this point, my_message_parsed[\"my_map[x]\"].value AND my_any_parsed[\"(foo.bar.Baz)\"].value are serialized Baz tensors.</p> FUNCTION DESCRIPTION <code>get_full_name_from_any_step</code> <p>Gets the full name of a protobuf from a google.protobuf.Any step.</p> <code>is_any_descriptor</code> <p>Returns true if it is an Any descriptor.</p> <code>parse_message_level_ex</code> <p>Parses regular fields, extensions, any casts, and map protos.</p> ATTRIBUTE DESCRIPTION <code>ProtoFieldName</code> <p> </p> <code>ProtoFullName</code> <p> </p> <code>StrStep</code> <p> </p>"},{"location":"api_docs/python/expression_impl/expression_impl/#struct2tensor.expression_impl.parse_message_level_ex-attributes","title":"Attributes","text":""},{"location":"api_docs/python/expression_impl/expression_impl/#struct2tensor.expression_impl.parse_message_level_ex.ProtoFieldName","title":"ProtoFieldName  <code>module-attribute</code>","text":"<pre><code>ProtoFieldName = str\n</code></pre>"},{"location":"api_docs/python/expression_impl/expression_impl/#struct2tensor.expression_impl.parse_message_level_ex.ProtoFullName","title":"ProtoFullName  <code>module-attribute</code>","text":"<pre><code>ProtoFullName = str\n</code></pre>"},{"location":"api_docs/python/expression_impl/expression_impl/#struct2tensor.expression_impl.parse_message_level_ex.StrStep","title":"StrStep  <code>module-attribute</code>","text":"<pre><code>StrStep = str\n</code></pre>"},{"location":"api_docs/python/expression_impl/expression_impl/#struct2tensor.expression_impl.parse_message_level_ex-functions","title":"Functions","text":""},{"location":"api_docs/python/expression_impl/expression_impl/#struct2tensor.expression_impl.parse_message_level_ex.get_full_name_from_any_step","title":"get_full_name_from_any_step","text":"<pre><code>get_full_name_from_any_step(\n    step: ProtoFieldName,\n) -&gt; Optional[ProtoFieldName]\n</code></pre> <p>Gets the full name of a protobuf from a google.protobuf.Any step.</p> <p>An any step is of the form (foo.com/bar.Baz). In this case the result would be bar.Baz.</p> PARAMETER DESCRIPTION <code>step</code> <p>the string of a step in a path.</p> <p> TYPE: <code>ProtoFieldName</code> </p> RETURNS DESCRIPTION <code>Optional[ProtoFieldName]</code> <p>the full name of a protobuf if the step is an any step, or None otherwise.</p> Source code in <code>struct2tensor/expression_impl/parse_message_level_ex.py</code> <pre><code>def get_full_name_from_any_step(\n    step: ProtoFieldName) -&gt; Optional[ProtoFieldName]:\n  \"\"\"Gets the full name of a protobuf from a google.protobuf.Any step.\n\n  An any step is of the form (foo.com/bar.Baz). In this case the result would\n  be bar.Baz.\n\n  Args:\n    step: the string of a step in a path.\n\n  Returns:\n    the full name of a protobuf if the step is an any step, or None otherwise.\n  \"\"\"\n  if not step:\n    return None\n  if step[0] != \"(\":\n    return None\n  if step[-1] != \")\":\n    return None\n  step_without_parens = step[1:-1]\n  return step_without_parens.split(\"/\")[-1]\n</code></pre>"},{"location":"api_docs/python/expression_impl/expression_impl/#struct2tensor.expression_impl.parse_message_level_ex.is_any_descriptor","title":"is_any_descriptor","text":"<pre><code>is_any_descriptor(desc: Descriptor) -&gt; bool\n</code></pre> <p>Returns true if it is an Any descriptor.</p> Source code in <code>struct2tensor/expression_impl/parse_message_level_ex.py</code> <pre><code>def is_any_descriptor(desc: descriptor.Descriptor) -&gt; bool:\n  \"\"\"Returns true if it is an Any descriptor.\"\"\"\n  return desc.full_name == \"google.protobuf.Any\"\n</code></pre>"},{"location":"api_docs/python/expression_impl/expression_impl/#struct2tensor.expression_impl.parse_message_level_ex.parse_message_level_ex","title":"parse_message_level_ex","text":"<pre><code>parse_message_level_ex(\n    tensor_of_protos: Tensor,\n    desc: Descriptor,\n    field_names: Set[ProtoFieldName],\n    message_format: str = \"binary\",\n    backing_str_tensor: Optional[Tensor] = None,\n    honor_proto3_optional_semantics: bool = False,\n) -&gt; Mapping[StrStep, _ParsedField]\n</code></pre> <p>Parses regular fields, extensions, any casts, and map protos.</p> Source code in <code>struct2tensor/expression_impl/parse_message_level_ex.py</code> <pre><code>def parse_message_level_ex(\n    tensor_of_protos: tf.Tensor,\n    desc: descriptor.Descriptor,\n    field_names: Set[ProtoFieldName],\n    message_format: str = \"binary\",\n    backing_str_tensor: Optional[tf.Tensor] = None,\n    honor_proto3_optional_semantics: bool = False\n) -&gt; Mapping[StrStep, struct2tensor_ops._ParsedField]:\n  \"\"\"Parses regular fields, extensions, any casts, and map protos.\"\"\"\n  raw_field_names = _get_field_names_to_parse(desc, field_names)\n  regular_fields = list(\n      struct2tensor_ops.parse_message_level(\n          tensor_of_protos,\n          desc,\n          raw_field_names,\n          message_format=message_format,\n          backing_str_tensor=backing_str_tensor,\n          honor_proto3_optional_semantics=honor_proto3_optional_semantics))\n  regular_field_map = {x.field_name: x for x in regular_fields}\n\n  any_fields = _get_any_parsed_fields(desc, regular_field_map, field_names)\n  map_fields = _get_map_parsed_fields(desc, regular_field_map, field_names,\n                                      backing_str_tensor)\n  result = regular_field_map\n  result.update(any_fields)\n  result.update(map_fields)\n  return result\n</code></pre>"},{"location":"api_docs/python/expression_impl/expression_impl/#struct2tensor.expression_impl.parse_message_level_ex-modules","title":"Modules","text":""},{"location":"api_docs/python/expression_impl/expression_impl/#struct2tensor.expression_impl.placeholder","title":"placeholder","text":"<p>Placeholder expression.</p> <p>A placeholder expression represents prensor nodes, however a prensor is not needed until calculate is called. This allows the user to apply expression queries to a placeholder expression before having an actual prensor object. When calculate is called on a placeholder expression (or a descendant of a placeholder expression), the feed_dict will need to be passed in. Then calculate will bind the prensor with the appropriate placeholder expression.</p> <p>Sample usage:</p> <pre><code>placeholder_exp = placeholder.create_expression_from_schema(schema)\nnew_exp = expression_queries(placeholder_exp, ..)\nresult = calculate.calculate_values([new_exp],\n                                    feed_dict={placeholder_exp: pren})\n# placeholder_exp requires a feed_dict to be passed in when calculating\n</code></pre> FUNCTION DESCRIPTION <code>create_expression_from_schema</code> <p>Creates a placeholder expression from a parquet schema.</p> <code>get_placeholder_paths_from_graph</code> <p>Gets all placeholder paths from an expression graph.</p>"},{"location":"api_docs/python/expression_impl/expression_impl/#struct2tensor.expression_impl.placeholder-functions","title":"Functions","text":""},{"location":"api_docs/python/expression_impl/expression_impl/#struct2tensor.expression_impl.placeholder.create_expression_from_schema","title":"create_expression_from_schema","text":"<pre><code>create_expression_from_schema(\n    schema: Schema,\n) -&gt; _PlaceholderRootExpression\n</code></pre> <p>Creates a placeholder expression from a parquet schema.</p> PARAMETER DESCRIPTION <code>schema</code> <p>The schema that describes the prensor tree that this placeholder represents.</p> <p> TYPE: <code>Schema</code> </p> RETURNS DESCRIPTION <code>_PlaceholderRootExpression</code> <p>A PlaceholderRootExpression that should be used as the root of an expression graph.</p> Source code in <code>struct2tensor/expression_impl/placeholder.py</code> <pre><code>def create_expression_from_schema(\n    schema: mpp.Schema) -&gt; \"_PlaceholderRootExpression\":\n  \"\"\"Creates a placeholder expression from a parquet schema.\n\n  Args:\n    schema: The schema that describes the prensor tree that this placeholder\n      represents.\n\n  Returns:\n    A PlaceholderRootExpression that should be used as the root of an expression\n      graph.\n  \"\"\"\n\n  return _PlaceholderRootExpression(schema)\n</code></pre>"},{"location":"api_docs/python/expression_impl/expression_impl/#struct2tensor.expression_impl.placeholder.get_placeholder_paths_from_graph","title":"get_placeholder_paths_from_graph","text":"<pre><code>get_placeholder_paths_from_graph(\n    graph: ExpressionGraph,\n) -&gt; List[Path]\n</code></pre> <p>Gets all placeholder paths from an expression graph.</p> <p>This finds all leaf placeholder expressions in an expression graph, and gets the path of these expressions.</p> PARAMETER DESCRIPTION <code>graph</code> <p>expression graph</p> <p> TYPE: <code>ExpressionGraph</code> </p> RETURNS DESCRIPTION <code>List[Path]</code> <p>a list of paths of placeholder expressions</p> Source code in <code>struct2tensor/expression_impl/placeholder.py</code> <pre><code>def get_placeholder_paths_from_graph(\n    graph: calculate.ExpressionGraph) -&gt; List[path.Path]:\n  \"\"\"Gets all placeholder paths from an expression graph.\n\n  This finds all leaf placeholder expressions in an expression graph, and gets\n  the path of these expressions.\n\n  Args:\n    graph: expression graph\n\n  Returns:\n    a list of paths of placeholder expressions\n  \"\"\"\n  expressions = [\n      x for x in graph.get_expressions_needed()\n      if (_is_placeholder_expression(x) and x.is_leaf)\n  ]\n  expressions = typing.cast(List[_PlaceholderExpression], expressions)\n  return [e.get_path() for e in expressions]\n</code></pre>"},{"location":"api_docs/python/expression_impl/expression_impl/#struct2tensor.expression_impl.placeholder-modules","title":"Modules","text":""},{"location":"api_docs/python/expression_impl/expression_impl/#struct2tensor.expression_impl.project","title":"project","text":"<p>project selects a subtree of an expression.</p> <p>project is often used right before calculating the value.</p> <p>Example</p> <pre><code>expr = ...\nnew_expr = project.project(expr, [path.Path([\"foo\",\"bar\"]),\n                                  path.Path([\"x\", \"y\"])])\n[prensor_result] = calculate.calculate_prensors([new_expr])\n</code></pre> <p>prensor_result now has two paths, \"foo.bar\" and \"x.y\".</p> FUNCTION DESCRIPTION <code>project</code> <p>select a subtree.</p>"},{"location":"api_docs/python/expression_impl/expression_impl/#struct2tensor.expression_impl.project-functions","title":"Functions","text":""},{"location":"api_docs/python/expression_impl/expression_impl/#struct2tensor.expression_impl.project.project","title":"project","text":"<pre><code>project(\n    expr: Expression, paths: Sequence[Path]\n) -&gt; Expression\n</code></pre> <p>select a subtree.</p> <p>Paths not selected are removed. Paths that are selected are \"known\", such that if calculate_prensors is called, they will be in the result.</p> PARAMETER DESCRIPTION <code>expr</code> <p>the original expression.</p> <p> TYPE: <code>Expression</code> </p> <code>paths</code> <p>the paths to include.</p> <p> TYPE: <code>Sequence[Path]</code> </p> RETURNS DESCRIPTION <code>Expression</code> <p>A projected expression.</p> Source code in <code>struct2tensor/expression_impl/project.py</code> <pre><code>def project(expr: expression.Expression,\n            paths: Sequence[path.Path]) -&gt; expression.Expression:\n  \"\"\"select a subtree.\n\n  Paths not selected are removed.\n  Paths that are selected are \"known\", such that if calculate_prensors is\n  called, they will be in the result.\n\n  Args:\n    expr: the original expression.\n    paths: the paths to include.\n\n  Returns:\n    A projected expression.\n  \"\"\"\n  missing_paths = [p for p in paths if expr.get_descendant(p) is None]\n  if missing_paths:\n    raise ValueError(\"{} Path(s) missing in project: {}\".format(\n        len(missing_paths), \", \".join([str(x) for x in missing_paths])))\n  return _ProjectExpression(expr, paths)\n</code></pre>"},{"location":"api_docs/python/expression_impl/expression_impl/#struct2tensor.expression_impl.project-modules","title":"Modules","text":""},{"location":"api_docs/python/expression_impl/expression_impl/#struct2tensor.expression_impl.promote","title":"promote","text":"<p>Promote an expression to be a child of its grandparent.</p> <p>Promote is part of the standard flattening of data, promote_and_broadcast, which takes structured data and flattens it. By directly accessing promote, one can perform simpler operations.</p> <p>For example, suppose an expr represents:</p> <pre><code>+\n|\n+-session*   (stars indicate repeated)\n     |\n     +-event*\n         |\n         +-val*-int64\n</code></pre> <pre><code>session: {\n  event: {\n    val: 111\n  }\n  event: {\n    val: 121\n    val: 122\n  }\n}\n\nsession: {\n  event: {\n    val: 10\n    val: 7\n  }\n  event: {\n    val: 1\n  }\n}\n</code></pre> <pre><code>promote.promote(expr, path.Path([\"session\", \"event\", \"val\"]), nval)\n</code></pre> <p>produces:</p> <pre><code>+\n|\n+-session*   (stars indicate repeated)\n     |\n     +-event*\n     |    |\n     |    +-val*-int64\n     |\n     +-nval*-int64\n</code></pre> <pre><code>session: {\n  event: {\n    val: 111\n  }\n  event: {\n    val: 121\n    val: 122\n  }\n  nval: 111\n  nval: 121\n  nval: 122\n}\n\nsession: {\n  event: {\n    val: 10\n    val: 7\n  }\n  event: {\n    val: 1\n  }\n  nval: 10\n  nval: 7\n  nval: 1\n}\n</code></pre> CLASS DESCRIPTION <code>PromoteChildExpression</code> <p>The root of the promoted sub tree.</p> <code>PromoteExpression</code> <p>A promoted leaf.</p> FUNCTION DESCRIPTION <code>promote</code> <p>Promote a path to be a child of its grandparent, and give it a name.</p> <code>promote_anonymous</code> <p>Promote a path to be a new anonymous child of its grandparent.</p>"},{"location":"api_docs/python/expression_impl/expression_impl/#struct2tensor.expression_impl.promote-classes","title":"Classes","text":""},{"location":"api_docs/python/expression_impl/expression_impl/#struct2tensor.expression_impl.promote.PromoteChildExpression","title":"PromoteChildExpression","text":"<pre><code>PromoteChildExpression(\n    origin: Expression, origin_parent: Expression\n)\n</code></pre> <p>               Bases: <code>Expression</code></p> <p>The root of the promoted sub tree.</p> <p>Initialize an expression.</p> PARAMETER DESCRIPTION <code>is_repeated</code> <p>if the expression is repeated.</p> <p> TYPE: <code>bool</code> </p> <code>my_type</code> <p>the DType of a field, or None for an internal node.</p> <p> TYPE: <code>Optional[DType]</code> </p> <code>schema_feature</code> <p>the local schema (StructDomain information should not be present).</p> <p> TYPE: <code>Optional[Feature]</code> DEFAULT: <code>None</code> </p> <code>validate_step_format</code> <p>If True, validates that steps do not have any characters that could be ambiguously understood as structure delimiters (e.g. \".\"). If False, such characters are allowed and the client is responsible to ensure to not rely on any auto-coercion of strings to paths.</p> <p> TYPE: <code>bool</code> DEFAULT: <code>True</code> </p> METHOD DESCRIPTION <code>apply</code> <code>apply_schema</code> <code>broadcast</code> <p>Broadcasts the existing field at source_path to the sibling_field.</p> <code>calculate</code> <p>Calculates the node tensor of the expression.</p> <code>calculation_equal</code> <p>self.calculate is equal to another expression.calculate.</p> <code>calculation_is_identity</code> <p>True iff the self.calculate is the identity.</p> <code>cogroup_by_index</code> <p>Creates a cogroup of left_name and right_name at new_field_name.</p> <code>create_has_field</code> <p>Creates a field that is the presence of the source path.</p> <code>create_proto_index</code> <p>Creates a proto index field as a direct child of the current root.</p> <code>create_size_field</code> <p>Creates a field that is the size of the source path.</p> <code>get_child</code> <p>Gets a named child.</p> <code>get_child_or_error</code> <p>Gets a named child.</p> <code>get_descendant</code> <p>Finds the descendant at the path.</p> <code>get_descendant_or_error</code> <p>Finds the descendant at the path.</p> <code>get_known_children</code> <code>get_known_descendants</code> <p>Gets a mapping from known paths to subexpressions.</p> <code>get_paths_with_schema</code> <p>Extract only paths that contain schema information.</p> <code>get_schema</code> <p>Returns a schema for the entire tree.</p> <code>get_source_expressions</code> <p>Gets the sources of this expression.</p> <code>known_field_names</code> <p>Returns known field names of the expression.</p> <code>map_field_values</code> <p>Map a primitive field to create a new primitive field.</p> <code>map_ragged_tensors</code> <p>Maps a set of primitive fields of a message to a new field.</p> <code>map_sparse_tensors</code> <p>Maps a set of primitive fields of a message to a new field.</p> <code>project</code> <p>Constrains the paths to those listed.</p> <code>promote</code> <p>Promotes source_path to be a field new_field_name in its grandparent.</p> <code>promote_and_broadcast</code> <code>reroot</code> <p>Returns a new list of protocol buffers available at new_root.</p> <code>schema_string</code> <p>Returns a schema for the expression.</p> <code>slice</code> <p>Creates a slice copy of source_path at new_field_path.</p> <code>truncate</code> <p>Creates a truncated copy of source_path at new_field_path.</p> ATTRIBUTE DESCRIPTION <code>is_leaf</code> <p>True iff the node tensor is a LeafNodeTensor.</p> <p> TYPE: <code>bool</code> </p> <code>is_repeated</code> <p>True iff the same parent value can have multiple children values.</p> <p> TYPE: <code>bool</code> </p> <code>schema_feature</code> <p>Return the schema of the field.</p> <p> TYPE: <code>Optional[Feature]</code> </p> <code>type</code> <p>dtype of the expression, or None if not a leaf expression.</p> <p> TYPE: <code>Optional[DType]</code> </p> <code>validate_step_format</code> <p> TYPE: <code>bool</code> </p> Source code in <code>struct2tensor/expression_impl/promote.py</code> <pre><code>def __init__(self, origin: expression.Expression,\n             origin_parent: expression.Expression):\n\n  super().__init__(\n      origin.is_repeated or origin_parent.is_repeated,\n      origin.type,\n      schema_feature=_get_promote_schema_feature(\n          origin.schema_feature, origin_parent.schema_feature\n      ),\n      validate_step_format=origin.validate_step_format,\n  )\n  self._origin = origin\n  self._origin_parent = origin_parent\n  if self._origin_parent.type is not None:\n    raise ValueError(\"origin_parent cannot be a field\")\n</code></pre> Attributes\u00b6 <code></code> is_leaf <code>property</code> \u00b6 <pre><code>is_leaf: bool\n</code></pre> <p>True iff the node tensor is a LeafNodeTensor.</p> <code></code> is_repeated <code>property</code> \u00b6 <pre><code>is_repeated: bool\n</code></pre> <p>True iff the same parent value can have multiple children values.</p> <code></code> schema_feature <code>property</code> \u00b6 <pre><code>schema_feature: Optional[Feature]\n</code></pre> <p>Return the schema of the field.</p> <code></code> type <code>property</code> \u00b6 <pre><code>type: Optional[DType]\n</code></pre> <p>dtype of the expression, or None if not a leaf expression.</p> <code></code> validate_step_format <code>property</code> \u00b6 <pre><code>validate_step_format: bool\n</code></pre> Functions\u00b6 <code></code> apply \u00b6 <pre><code>apply(\n    transform: Callable[[Expression], Expression],\n) -&gt; Expression\n</code></pre> Source code in <code>struct2tensor/expression.py</code> <pre><code>def apply(self,\n          transform: Callable[[\"Expression\"], \"Expression\"]) -&gt; \"Expression\":\n  return transform(self)\n</code></pre> <code></code> apply_schema \u00b6 <pre><code>apply_schema(schema: Schema) -&gt; Expression\n</code></pre> Source code in <code>struct2tensor/expression.py</code> <pre><code>def apply_schema(self, schema: schema_pb2.Schema) -&gt; \"Expression\":\n  return apply_schema.apply_schema(self, schema)\n</code></pre> <code></code> broadcast \u00b6 <pre><code>broadcast(\n    source_path: CoercableToPath,\n    sibling_field: Step,\n    new_field_name: Step,\n) -&gt; Expression\n</code></pre> <p>Broadcasts the existing field at source_path to the sibling_field.</p> Source code in <code>struct2tensor/expression.py</code> <pre><code>def broadcast(self, source_path: CoercableToPath, sibling_field: path.Step,\n              new_field_name: path.Step) -&gt; \"Expression\":\n  \"\"\"Broadcasts the existing field at source_path to the sibling_field.\"\"\"\n  return broadcast.broadcast(self, path.create_path(source_path),\n                             sibling_field, new_field_name)\n</code></pre> <code></code> calculate \u00b6 <pre><code>calculate(\n    sources: Sequence[NodeTensor],\n    destinations: Sequence[Expression],\n    options: Options,\n    side_info: Optional[Prensor] = None,\n) -&gt; NodeTensor\n</code></pre> <p>Calculates the node tensor of the expression.</p> <p>The node tensor must be a function of the properties of the expression and the node tensors of the expressions from get_source_expressions().</p> <p>If is_leaf, then calculate must return a LeafNodeTensor. Otherwise, it must return a ChildNodeTensor or RootNodeTensor.</p> <p>If calculate_is_identity is true, then this must return source_tensors[0].</p> <p>Sometimes, for operations such as parsing the proto, calculate will return additional information. For example, calculate() for the root of the proto expression also parses out the tensors required to calculate the tensors of the children. This is why destinations are required.</p> <p>For a reference use, see calculate_value_slowly(...) below.</p> PARAMETER DESCRIPTION <code>source_tensors</code> <p>The node tensors of the expressions in get_source_expressions().</p> <p> TYPE: <code>Sequence[NodeTensor]</code> </p> <code>destinations</code> <p>The expressions that will use the output of this method.</p> <p> TYPE: <code>Sequence[Expression]</code> </p> <code>options</code> <p>Options for the calculation.</p> <p> TYPE: <code>Options</code> </p> <code>side_info</code> <p>An optional prensor that is used to bind to a placeholder expression.</p> <p> TYPE: <code>Optional[Prensor]</code> DEFAULT: <code>None</code> </p> RETURNS DESCRIPTION <code>NodeTensor</code> <p>A NodeTensor representing the output of this expression.</p> Source code in <code>struct2tensor/expression_impl/promote.py</code> <pre><code>def calculate(\n    self,\n    sources: Sequence[prensor.NodeTensor],\n    destinations: Sequence[expression.Expression],\n    options: calculate_options.Options,\n    side_info: Optional[prensor.Prensor] = None) -&gt; prensor.NodeTensor:\n  [origin_value, origin_parent_value] = sources\n  if not isinstance(origin_value, prensor.ChildNodeTensor):\n    raise ValueError(\"origin_value must be a child\")\n  if not isinstance(origin_parent_value, prensor.ChildNodeTensor):\n    raise ValueError(\"origin_parent_value must be a child node\")\n  new_parent_index = tf.gather(origin_parent_value.parent_index,\n                               origin_value.parent_index)\n  return prensor.ChildNodeTensor(new_parent_index, self.is_repeated)\n</code></pre> <code></code> calculation_equal \u00b6 <pre><code>calculation_equal(expr: Expression) -&gt; bool\n</code></pre> <p>self.calculate is equal to another expression.calculate.</p> <p>Given the same source node tensors, self.calculate(...) and expression.calculate(...) will have the same result.</p> <p>Note that this does not check that the source expressions of the two expressions are the same. Therefore, two operations can have the same calculation, but not the same output, because their sources are different. For example, if a.calculation_is_identity() is True and b.calculation_is_identity() is True, then a.calculation_equal(b) is True. However, unless a and b have the same source, the expressions themselves are not equal.</p> PARAMETER DESCRIPTION <code>expression</code> <p>The expression to compare to.</p> <p> TYPE: <code>Expression</code> </p> Source code in <code>struct2tensor/expression_impl/promote.py</code> <pre><code>def calculation_equal(self, expr: expression.Expression) -&gt; bool:\n  return isinstance(expr, PromoteChildExpression)\n</code></pre> <code></code> calculation_is_identity \u00b6 <pre><code>calculation_is_identity() -&gt; bool\n</code></pre> <p>True iff the self.calculate is the identity.</p> <p>There is exactly one source, and the output of self.calculate(...) is the node tensor of this source.</p> Source code in <code>struct2tensor/expression_impl/promote.py</code> <pre><code>def calculation_is_identity(self) -&gt; bool:\n  return False\n</code></pre> <code></code> cogroup_by_index \u00b6 <pre><code>cogroup_by_index(\n    source_path: CoercableToPath,\n    left_name: Step,\n    right_name: Step,\n    new_field_name: Step,\n) -&gt; Expression\n</code></pre> <p>Creates a cogroup of left_name and right_name at new_field_name.</p> Source code in <code>struct2tensor/expression.py</code> <pre><code>def cogroup_by_index(self, source_path: CoercableToPath, left_name: path.Step,\n                     right_name: path.Step,\n                     new_field_name: path.Step) -&gt; \"Expression\":\n  \"\"\"Creates a cogroup of left_name and right_name at new_field_name.\"\"\"\n  raise NotImplementedError(\"cogroup_by_index is not implemented\")\n</code></pre> <code></code> create_has_field \u00b6 <pre><code>create_has_field(\n    source_path: CoercableToPath, new_field_name: Step\n) -&gt; Expression\n</code></pre> <p>Creates a field that is the presence of the source path.</p> Source code in <code>struct2tensor/expression.py</code> <pre><code>def create_has_field(self, source_path: CoercableToPath,\n                     new_field_name: path.Step) -&gt; \"Expression\":\n  \"\"\"Creates a field that is the presence of the source path.\"\"\"\n  return size.has(self, path.create_path(source_path), new_field_name)\n</code></pre> <code></code> create_proto_index \u00b6 <pre><code>create_proto_index(field_name: Step) -&gt; Expression\n</code></pre> <p>Creates a proto index field as a direct child of the current root.</p> <p>The proto index maps each root element to the original batch index. For example: [0, 2] means the first element came from the first proto in the original input tensor and the second element came from the third proto. The created field is always \"dense\" -- it has the same valency as the current root.</p> PARAMETER DESCRIPTION <code>field_name</code> <p>the name of the field to be created.</p> <p> TYPE: <code>Step</code> </p> RETURNS DESCRIPTION <code>Expression</code> <p>An Expression object representing the result of the operation.</p> Source code in <code>struct2tensor/expression.py</code> <pre><code>def create_proto_index(self, field_name: path.Step) -&gt; \"Expression\":\n  \"\"\"Creates a proto index field as a direct child of the current root.\n\n  The proto index maps each root element to the original batch index.\n  For example: [0, 2] means the first element came from the first proto\n  in the original input tensor and the second element came from the third\n  proto. The created field is always \"dense\" -- it has the same valency as\n  the current root.\n\n  Args:\n    field_name: the name of the field to be created.\n\n  Returns:\n    An Expression object representing the result of the operation.\n  \"\"\"\n\n  return reroot.create_proto_index_field(self, field_name)\n</code></pre> <code></code> create_size_field \u00b6 <pre><code>create_size_field(\n    source_path: CoercableToPath, new_field_name: Step\n) -&gt; Expression\n</code></pre> <p>Creates a field that is the size of the source path.</p> Source code in <code>struct2tensor/expression.py</code> <pre><code>def create_size_field(self, source_path: CoercableToPath,\n                      new_field_name: path.Step) -&gt; \"Expression\":\n  \"\"\"Creates a field that is the size of the source path.\"\"\"\n  return size.size(self, path.create_path(source_path), new_field_name)\n</code></pre> <code></code> get_child \u00b6 <pre><code>get_child(field_name: Step) -&gt; Optional[Expression]\n</code></pre> <p>Gets a named child.</p> Source code in <code>struct2tensor/expression.py</code> <pre><code>def get_child(self, field_name: path.Step) -&gt; Optional[\"Expression\"]:\n  \"\"\"Gets a named child.\"\"\"\n  if field_name in self._child_cache:\n    return self._child_cache[field_name]\n  result = self._get_child_impl(field_name)\n  self._child_cache[field_name] = result\n  return result\n</code></pre> <code></code> get_child_or_error \u00b6 <pre><code>get_child_or_error(field_name: Step) -&gt; Expression\n</code></pre> <p>Gets a named child.</p> Source code in <code>struct2tensor/expression.py</code> <pre><code>def get_child_or_error(self, field_name: path.Step) -&gt; \"Expression\":\n  \"\"\"Gets a named child.\"\"\"\n  result = self.get_child(field_name)\n  if result is None:\n    raise KeyError(\"No such field: {}\".format(field_name))\n  return result\n</code></pre> <code></code> get_descendant \u00b6 <pre><code>get_descendant(p: Path) -&gt; Optional[Expression]\n</code></pre> <p>Finds the descendant at the path.</p> Source code in <code>struct2tensor/expression.py</code> <pre><code>def get_descendant(self, p: path.Path) -&gt; Optional[\"Expression\"]:\n  \"\"\"Finds the descendant at the path.\"\"\"\n  result = self\n  for field_name in p.field_list:\n    result = result.get_child(field_name)\n    if result is None:\n      return None\n  return result\n</code></pre> <code></code> get_descendant_or_error \u00b6 <pre><code>get_descendant_or_error(p: Path) -&gt; Expression\n</code></pre> <p>Finds the descendant at the path.</p> Source code in <code>struct2tensor/expression.py</code> <pre><code>def get_descendant_or_error(self, p: path.Path) -&gt; \"Expression\":\n  \"\"\"Finds the descendant at the path.\"\"\"\n  result = self.get_descendant(p)\n  if result is None:\n    raise ValueError(\"Missing path: {} in {}\".format(\n        str(p), self.schema_string(limit=20)))\n  return result\n</code></pre> <code></code> get_known_children \u00b6 <pre><code>get_known_children() -&gt; Mapping[Step, Expression]\n</code></pre> Source code in <code>struct2tensor/expression.py</code> <pre><code>def get_known_children(self) -&gt; Mapping[path.Step, \"Expression\"]:\n  known_field_names = self.known_field_names()\n  result = {}\n  for name in known_field_names:\n    result[name] = self.get_child_or_error(name)\n  return result\n</code></pre> <code></code> get_known_descendants \u00b6 <pre><code>get_known_descendants() -&gt; Mapping[Path, Expression]\n</code></pre> <p>Gets a mapping from known paths to subexpressions.</p> <p>The difference between this and get_descendants in Prensor is that all paths in a Prensor are realized, thus all known. But an Expression's descendants might not all be known at the point this method is called, because an expression may have an infinite number of children.</p> RETURNS DESCRIPTION <code>Mapping[Path, Expression]</code> <p>A mapping from paths (relative to the root of the subexpression) to expressions.</p> Source code in <code>struct2tensor/expression.py</code> <pre><code>def get_known_descendants(self) -&gt; Mapping[path.Path, \"Expression\"]:\n  # Rename get_known_descendants\n  \"\"\"Gets a mapping from known paths to subexpressions.\n\n  The difference between this and get_descendants in Prensor is that\n  all paths in a Prensor are realized, thus all known. But an Expression's\n  descendants might not all be known at the point this method is called,\n  because an expression may have an infinite number of children.\n\n  Returns:\n    A mapping from paths (relative to the root of the subexpression) to\n      expressions.\n  \"\"\"\n  known_subexpressions = {\n      k: v.get_known_descendants()\n      for k, v in self.get_known_children().items()\n  }\n  result = {}\n  for field_name, subexpression in known_subexpressions.items():\n    subexpression_path = path.Path(\n        [field_name], validate_step_format=self.validate_step_format\n    )\n    for p, expr in subexpression.items():\n      result[subexpression_path.concat(p)] = expr\n  result[path.Path([], validate_step_format=self.validate_step_format)] = self\n  return result\n</code></pre> <code></code> get_paths_with_schema \u00b6 <pre><code>get_paths_with_schema() -&gt; List[Path]\n</code></pre> <p>Extract only paths that contain schema information.</p> Source code in <code>struct2tensor/expression.py</code> <pre><code>def get_paths_with_schema(self) -&gt; List[path.Path]:\n  \"\"\"Extract only paths that contain schema information.\"\"\"\n  result = []\n  for name, child in self.get_known_children().items():\n    if child.schema_feature is None:\n      continue\n    result.extend(\n        [\n            path.Path(\n                [name], validate_step_format=self.validate_step_format\n            ).concat(x)\n            for x in child.get_paths_with_schema()\n        ]\n    )\n  # Note: We always take the root path and so will return an empty schema\n  # if there is no schema information on any nodes, including the root.\n  if not result:\n    result.append(\n        path.Path([], validate_step_format=self.validate_step_format)\n    )\n  return result\n</code></pre> <code></code> get_schema \u00b6 <pre><code>get_schema(create_schema_features=True) -&gt; Schema\n</code></pre> <p>Returns a schema for the entire tree.</p> PARAMETER DESCRIPTION <code>create_schema_features</code> <p>If True, schema features are added for all children and a schema entry is created if not available on the child. If False, features are left off of the returned schema if there is no schema_feature on the child.</p> <p> DEFAULT: <code>True</code> </p> Source code in <code>struct2tensor/expression.py</code> <pre><code>def get_schema(self, create_schema_features=True) -&gt; schema_pb2.Schema:\n  \"\"\"Returns a schema for the entire tree.\n\n  Args:\n    create_schema_features: If True, schema features are added for all\n      children and a schema entry is created if not available on the child. If\n      False, features are left off of the returned schema if there is no\n      schema_feature on the child.\n  \"\"\"\n  if not create_schema_features:\n    return self.project(self.get_paths_with_schema()).get_schema()\n  result = schema_pb2.Schema()\n  self._populate_schema_feature_children(result.feature)\n  return result\n</code></pre> <code></code> get_source_expressions \u00b6 <pre><code>get_source_expressions() -&gt; Sequence[Expression]\n</code></pre> <p>Gets the sources of this expression.</p> <p>The node tensors of the source expressions must be sufficient to calculate the node tensor of this expression (see calculate and calculate_value_slowly).</p> RETURNS DESCRIPTION <code>Sequence[Expression]</code> <p>The sources of this expression.</p> Source code in <code>struct2tensor/expression_impl/promote.py</code> <pre><code>def get_source_expressions(self) -&gt; Sequence[expression.Expression]:\n  return [self._origin, self._origin_parent]\n</code></pre> <code></code> known_field_names \u00b6 <pre><code>known_field_names() -&gt; FrozenSet[Step]\n</code></pre> <p>Returns known field names of the expression.</p> <p>TODO(martinz): implement set_field and project. Known field names of a parsed proto correspond to the fields declared in the message. Examples of \"unknown\" fields are extensions and explicit casts in an any field. The only way to know if an unknown field \"(foo.bar)\" is present in an expression expr is to call (expr[\"(foo.bar)\"] is not None).</p> <p>Notice that simply accessing a field does not make it \"known\". However, setting a field (or setting a descendant of a field) will make it known.</p> <p>project(...) returns an expression where the known field names are the only field names. In general, if you want to depend upon known_field_names (e.g., if you want to compile a expression), then the best approach is to project() the expression first.</p> RETURNS DESCRIPTION <code>FrozenSet[Step]</code> <p>An immutable set of field names.</p> Source code in <code>struct2tensor/expression_impl/promote.py</code> <pre><code>def known_field_names(self) -&gt; FrozenSet[path.Step]:\n  return self._origin.known_field_names()\n</code></pre> <code></code> map_field_values \u00b6 <pre><code>map_field_values(\n    source_path: CoercableToPath,\n    operator: Callable[[Tensor], Tensor],\n    dtype: DType,\n    new_field_name: Step,\n) -&gt; Expression\n</code></pre> <p>Map a primitive field to create a new primitive field.</p> <p>Note</p> <p>The dtype argument is added since the v1 API.</p> PARAMETER DESCRIPTION <code>source_path</code> <p>the origin path.</p> <p> TYPE: <code>CoercableToPath</code> </p> <code>operator</code> <p>an element-wise operator that takes a 1-dimensional vector.</p> <p> TYPE: <code>Callable[[Tensor], Tensor]</code> </p> <code>dtype</code> <p>the type of the output.</p> <p> TYPE: <code>DType</code> </p> <code>new_field_name</code> <p>the name of a new sibling of source_path.</p> <p> TYPE: <code>Step</code> </p> RETURNS DESCRIPTION <code>Expression</code> <p>the resulting root expression.</p> Source code in <code>struct2tensor/expression.py</code> <pre><code>def map_field_values(self, source_path: CoercableToPath,\n                     operator: Callable[[tf.Tensor], tf.Tensor],\n                     dtype: tf.DType,\n                     new_field_name: path.Step) -&gt; \"Expression\":\n  \"\"\"Map a primitive field to create a new primitive field.\n\n  !!! Note\n      The dtype argument is added since the v1 API.\n\n  Args:\n    source_path: the origin path.\n    operator: an element-wise operator that takes a 1-dimensional vector.\n    dtype: the type of the output.\n    new_field_name: the name of a new sibling of source_path.\n\n  Returns:\n    the resulting root expression.\n  \"\"\"\n  return map_values.map_values(self, path.create_path(source_path), operator,\n                               dtype, new_field_name)\n</code></pre> <code></code> map_ragged_tensors \u00b6 <pre><code>map_ragged_tensors(\n    parent_path: CoercableToPath,\n    source_fields: Sequence[Step],\n    operator: Callable[..., SparseTensor],\n    is_repeated: bool,\n    dtype: DType,\n    new_field_name: Step,\n) -&gt; Expression\n</code></pre> <p>Maps a set of primitive fields of a message to a new field.</p> <p>Unlike map_field_values, this operation allows you to some degree reshape the field. For instance, you can take two optional fields and create a repeated field, or perform a reduce_sum on the last dimension of a repeated field and create an optional field. The key constraint is that the operator must return a sparse tensor of the correct dimension: i.e., a 2D sparse tensor if is_repeated is true, or a 1D sparse tensor if is_repeated is false. Moreover, the first dimension of the sparse tensor must be equal to the first dimension of the input tensor.</p> PARAMETER DESCRIPTION <code>parent_path</code> <p>the parent of the input and output fields.</p> <p> TYPE: <code>CoercableToPath</code> </p> <code>source_fields</code> <p>the nonempty list of names of the source fields.</p> <p> TYPE: <code>Sequence[Step]</code> </p> <code>operator</code> <p>an operator that takes len(source_fields) sparse tensors and returns a sparse tensor of the appropriate shape.</p> <p> TYPE: <code>Callable[..., SparseTensor]</code> </p> <code>is_repeated</code> <p>whether the output is repeated.</p> <p> TYPE: <code>bool</code> </p> <code>dtype</code> <p>the dtype of the result.</p> <p> TYPE: <code>DType</code> </p> <code>new_field_name</code> <p>the name of the resulting field.</p> <p> TYPE: <code>Step</code> </p> RETURNS DESCRIPTION <code>Expression</code> <p>A new query.</p> Source code in <code>struct2tensor/expression.py</code> <pre><code>def map_ragged_tensors(self, parent_path: CoercableToPath,\n                       source_fields: Sequence[path.Step],\n                       operator: Callable[..., tf.SparseTensor],\n                       is_repeated: bool, dtype: tf.DType,\n                       new_field_name: path.Step) -&gt; \"Expression\":\n  \"\"\"Maps a set of primitive fields of a message to a new field.\n\n  Unlike map_field_values, this operation allows you to some degree reshape\n  the field. For instance, you can take two optional fields and create a\n  repeated field, or perform a reduce_sum on the last dimension of a repeated\n  field and create an optional field. The key constraint is that the operator\n  must return a sparse tensor of the correct dimension: i.e., a\n  2D sparse tensor if is_repeated is true, or a 1D sparse tensor if\n  is_repeated is false. Moreover, the first dimension of the sparse tensor\n  must be equal to the first dimension of the input tensor.\n\n  Args:\n    parent_path: the parent of the input and output fields.\n    source_fields: the nonempty list of names of the source fields.\n    operator: an operator that takes len(source_fields) sparse tensors and\n      returns a sparse tensor of the appropriate shape.\n    is_repeated: whether the output is repeated.\n    dtype: the dtype of the result.\n    new_field_name: the name of the resulting field.\n\n  Returns:\n    A new query.\n  \"\"\"\n  return map_prensor.map_ragged_tensor(\n      self,\n      path.create_path(parent_path),\n      [\n          path.Path([f], validate_step_format=self.validate_step_format)\n          for f in source_fields\n      ],\n      operator,\n      is_repeated,\n      dtype,\n      new_field_name,\n  )\n</code></pre> <code></code> map_sparse_tensors \u00b6 <pre><code>map_sparse_tensors(\n    parent_path: CoercableToPath,\n    source_fields: Sequence[Step],\n    operator: Callable[..., SparseTensor],\n    is_repeated: bool,\n    dtype: DType,\n    new_field_name: Step,\n) -&gt; Expression\n</code></pre> <p>Maps a set of primitive fields of a message to a new field.</p> <p>Unlike map_field_values, this operation allows you to some degree reshape the field. For instance, you can take two optional fields and create a repeated field, or perform a reduce_sum on the last dimension of a repeated field and create an optional field. The key constraint is that the operator must return a sparse tensor of the correct dimension: i.e., a 2D sparse tensor if is_repeated is true, or a 1D sparse tensor if is_repeated is false. Moreover, the first dimension of the sparse tensor must be equal to the first dimension of the input tensor.</p> PARAMETER DESCRIPTION <code>parent_path</code> <p>the parent of the input and output fields.</p> <p> TYPE: <code>CoercableToPath</code> </p> <code>source_fields</code> <p>the nonempty list of names of the source fields.</p> <p> TYPE: <code>Sequence[Step]</code> </p> <code>operator</code> <p>an operator that takes len(source_fields) sparse tensors and returns a sparse tensor of the appropriate shape.</p> <p> TYPE: <code>Callable[..., SparseTensor]</code> </p> <code>is_repeated</code> <p>whether the output is repeated.</p> <p> TYPE: <code>bool</code> </p> <code>dtype</code> <p>the dtype of the result.</p> <p> TYPE: <code>DType</code> </p> <code>new_field_name</code> <p>the name of the resulting field.</p> <p> TYPE: <code>Step</code> </p> RETURNS DESCRIPTION <code>Expression</code> <p>A new query.</p> Source code in <code>struct2tensor/expression.py</code> <pre><code>def map_sparse_tensors(self, parent_path: CoercableToPath,\n                       source_fields: Sequence[path.Step],\n                       operator: Callable[..., tf.SparseTensor],\n                       is_repeated: bool, dtype: tf.DType,\n                       new_field_name: path.Step) -&gt; \"Expression\":\n  \"\"\"Maps a set of primitive fields of a message to a new field.\n\n  Unlike map_field_values, this operation allows you to some degree reshape\n  the field. For instance, you can take two optional fields and create a\n  repeated field, or perform a reduce_sum on the last dimension of a repeated\n  field and create an optional field. The key constraint is that the operator\n  must return a sparse tensor of the correct dimension: i.e., a\n  2D sparse tensor if is_repeated is true, or a 1D sparse tensor if\n  is_repeated is false. Moreover, the first dimension of the sparse tensor\n  must be equal to the first dimension of the input tensor.\n\n  Args:\n    parent_path: the parent of the input and output fields.\n    source_fields: the nonempty list of names of the source fields.\n    operator: an operator that takes len(source_fields) sparse tensors and\n      returns a sparse tensor of the appropriate shape.\n    is_repeated: whether the output is repeated.\n    dtype: the dtype of the result.\n    new_field_name: the name of the resulting field.\n\n  Returns:\n    A new query.\n  \"\"\"\n  return map_prensor.map_sparse_tensor(\n      self,\n      path.create_path(parent_path),\n      [\n          path.Path([f], validate_step_format=self.validate_step_format)\n          for f in source_fields\n      ],\n      operator,\n      is_repeated,\n      dtype,\n      new_field_name,\n  )\n</code></pre> <code></code> project \u00b6 <pre><code>project(path_list: Sequence[CoercableToPath]) -&gt; Expression\n</code></pre> <p>Constrains the paths to those listed.</p> Source code in <code>struct2tensor/expression.py</code> <pre><code>def project(self, path_list: Sequence[CoercableToPath]) -&gt; \"Expression\":\n  \"\"\"Constrains the paths to those listed.\"\"\"\n  return project.project(self, [path.create_path(x) for x in path_list])\n</code></pre> <code></code> promote \u00b6 <pre><code>promote(source_path: CoercableToPath, new_field_name: Step)\n</code></pre> <p>Promotes source_path to be a field new_field_name in its grandparent.</p> Source code in <code>struct2tensor/expression.py</code> <pre><code>def promote(self, source_path: CoercableToPath, new_field_name: path.Step):\n  \"\"\"Promotes source_path to be a field new_field_name in its grandparent.\"\"\"\n  return promote.promote(self, path.create_path(source_path), new_field_name)\n</code></pre> <code></code> promote_and_broadcast \u00b6 <pre><code>promote_and_broadcast(\n    path_dictionary: Mapping[Step, CoercableToPath],\n    dest_path_parent: CoercableToPath,\n) -&gt; Expression\n</code></pre> Source code in <code>struct2tensor/expression.py</code> <pre><code>def promote_and_broadcast(\n    self, path_dictionary: Mapping[path.Step, CoercableToPath],\n    dest_path_parent: CoercableToPath) -&gt; \"Expression\":\n  return promote_and_broadcast.promote_and_broadcast(\n      self, {k: path.create_path(v) for k, v in path_dictionary.items()},\n      path.create_path(dest_path_parent))\n</code></pre> <code></code> reroot \u00b6 <pre><code>reroot(new_root: CoercableToPath) -&gt; Expression\n</code></pre> <p>Returns a new list of protocol buffers available at new_root.</p> Source code in <code>struct2tensor/expression.py</code> <pre><code>def reroot(self, new_root: CoercableToPath) -&gt; \"Expression\":\n  \"\"\"Returns a new list of protocol buffers available at new_root.\"\"\"\n  return reroot.reroot(self, path.create_path(new_root))\n</code></pre> <code></code> schema_string \u00b6 <pre><code>schema_string(limit: Optional[int] = None) -&gt; str\n</code></pre> <p>Returns a schema for the expression.</p> <p>For examle, </p><pre><code>repeated root:\n  optional int32 foo\n  optional bar:\n    optional string baz\n  optional int64 bak\n</code></pre> <p>Note that unknown fields and subexpressions are not displayed.</p> PARAMETER DESCRIPTION <code>limit</code> <p>if present, limit the recursion.</p> <p> TYPE: <code>Optional[int]</code> DEFAULT: <code>None</code> </p> RETURNS DESCRIPTION <code>str</code> <p>A string, describing (a part of) the schema.</p> Source code in <code>struct2tensor/expression.py</code> <pre><code>def schema_string(self, limit: Optional[int] = None) -&gt; str:\n  \"\"\"Returns a schema for the expression.\n\n  For examle,\n  ```\n  repeated root:\n    optional int32 foo\n    optional bar:\n      optional string baz\n    optional int64 bak\n  ```\n\n  Note that unknown fields and subexpressions are not displayed.\n\n  Args:\n    limit: if present, limit the recursion.\n\n  Returns:\n    A string, describing (a part of) the schema.\n  \"\"\"\n  return \"\\n\".join(self._schema_string_helper(\"root\", limit))\n</code></pre> <code></code> slice \u00b6 <pre><code>slice(\n    source_path: CoercableToPath,\n    new_field_name: Step,\n    begin: Optional[IndexValue] = None,\n    end: Optional[IndexValue] = None,\n) -&gt; Expression\n</code></pre> <p>Creates a slice copy of source_path at new_field_path.</p> <p>Note that if begin or end is negative, it is considered relative to the size of the array. e.g., slice(...,begin=-1) will get the last element of every array.</p> PARAMETER DESCRIPTION <code>source_path</code> <p>the source of the slice.</p> <p> TYPE: <code>CoercableToPath</code> </p> <code>new_field_name</code> <p>the new field that is generated.</p> <p> TYPE: <code>Step</code> </p> <code>begin</code> <p>the beginning of the slice (inclusive).</p> <p> TYPE: <code>Optional[IndexValue]</code> DEFAULT: <code>None</code> </p> <code>end</code> <p>the end of the slice (exclusive).</p> <p> TYPE: <code>Optional[IndexValue]</code> DEFAULT: <code>None</code> </p> RETURNS DESCRIPTION <code>Expression</code> <p>An Expression object representing the result of the operation.</p> Source code in <code>struct2tensor/expression.py</code> <pre><code>def slice(self,\n          source_path: CoercableToPath,\n          new_field_name: path.Step,\n          begin: Optional[IndexValue] = None,\n          end: Optional[IndexValue] = None) -&gt; \"Expression\":\n  \"\"\"Creates a slice copy of source_path at new_field_path.\n\n  Note that if begin or end is negative, it is considered relative to\n  the size of the array. e.g., slice(...,begin=-1) will get the last\n  element of every array.\n\n  Args:\n    source_path: the source of the slice.\n    new_field_name: the new field that is generated.\n    begin: the beginning of the slice (inclusive).\n    end: the end of the slice (exclusive).\n\n  Returns:\n    An Expression object representing the result of the operation.\n  \"\"\"\n  return slice_expression.slice_expression(self,\n                                           path.create_path(source_path),\n                                           new_field_name, begin, end)\n</code></pre> <code></code> truncate \u00b6 <pre><code>truncate(\n    source_path: CoercableToPath,\n    limit: Union[int, Tensor],\n    new_field_name: Step,\n) -&gt; Expression\n</code></pre> <p>Creates a truncated copy of source_path at new_field_path.</p> Source code in <code>struct2tensor/expression.py</code> <pre><code>def truncate(self, source_path: CoercableToPath, limit: Union[int, tf.Tensor],\n             new_field_name: path.Step) -&gt; \"Expression\":\n  \"\"\"Creates a truncated copy of source_path at new_field_path.\"\"\"\n  return self.slice(source_path, new_field_name, end=limit)\n</code></pre>"},{"location":"api_docs/python/expression_impl/expression_impl/#struct2tensor.expression_impl.promote.PromoteExpression","title":"PromoteExpression","text":"<pre><code>PromoteExpression(\n    origin: Expression, origin_parent: Expression\n)\n</code></pre> <p>               Bases: <code>Leaf</code></p> <p>A promoted leaf.</p> <p>Initialize a Leaf.</p> <p>Note that a leaf must have a specified type.</p> PARAMETER DESCRIPTION <code>is_repeated</code> <p>if the expression is repeated.</p> <p> TYPE: <code>bool</code> </p> <code>my_type</code> <p>the DType of the field.</p> <p> TYPE: <code>DType</code> </p> <code>schema_feature</code> <p>schema information about the field.</p> <p> TYPE: <code>Optional[Feature]</code> DEFAULT: <code>None</code> </p> METHOD DESCRIPTION <code>apply</code> <code>apply_schema</code> <code>broadcast</code> <p>Broadcasts the existing field at source_path to the sibling_field.</p> <code>calculate</code> <p>Calculates the node tensor of the expression.</p> <code>calculation_equal</code> <p>self.calculate is equal to another expression.calculate.</p> <code>calculation_is_identity</code> <p>True iff the self.calculate is the identity.</p> <code>cogroup_by_index</code> <p>Creates a cogroup of left_name and right_name at new_field_name.</p> <code>create_has_field</code> <p>Creates a field that is the presence of the source path.</p> <code>create_proto_index</code> <p>Creates a proto index field as a direct child of the current root.</p> <code>create_size_field</code> <p>Creates a field that is the size of the source path.</p> <code>get_child</code> <p>Gets a named child.</p> <code>get_child_or_error</code> <p>Gets a named child.</p> <code>get_descendant</code> <p>Finds the descendant at the path.</p> <code>get_descendant_or_error</code> <p>Finds the descendant at the path.</p> <code>get_known_children</code> <code>get_known_descendants</code> <p>Gets a mapping from known paths to subexpressions.</p> <code>get_paths_with_schema</code> <p>Extract only paths that contain schema information.</p> <code>get_schema</code> <p>Returns a schema for the entire tree.</p> <code>get_source_expressions</code> <p>Gets the sources of this expression.</p> <code>known_field_names</code> <p>Returns known field names of the expression.</p> <code>map_field_values</code> <p>Map a primitive field to create a new primitive field.</p> <code>map_ragged_tensors</code> <p>Maps a set of primitive fields of a message to a new field.</p> <code>map_sparse_tensors</code> <p>Maps a set of primitive fields of a message to a new field.</p> <code>project</code> <p>Constrains the paths to those listed.</p> <code>promote</code> <p>Promotes source_path to be a field new_field_name in its grandparent.</p> <code>promote_and_broadcast</code> <code>reroot</code> <p>Returns a new list of protocol buffers available at new_root.</p> <code>schema_string</code> <p>Returns a schema for the expression.</p> <code>slice</code> <p>Creates a slice copy of source_path at new_field_path.</p> <code>truncate</code> <p>Creates a truncated copy of source_path at new_field_path.</p> ATTRIBUTE DESCRIPTION <code>is_leaf</code> <p>True iff the node tensor is a LeafNodeTensor.</p> <p> TYPE: <code>bool</code> </p> <code>is_repeated</code> <p>True iff the same parent value can have multiple children values.</p> <p> TYPE: <code>bool</code> </p> <code>schema_feature</code> <p>Return the schema of the field.</p> <p> TYPE: <code>Optional[Feature]</code> </p> <code>type</code> <p>dtype of the expression, or None if not a leaf expression.</p> <p> TYPE: <code>Optional[DType]</code> </p> <code>validate_step_format</code> <p> TYPE: <code>bool</code> </p> Source code in <code>struct2tensor/expression_impl/promote.py</code> <pre><code>def __init__(self, origin: expression.Expression,\n             origin_parent: expression.Expression):\n\n  super().__init__(\n      origin.is_repeated or origin_parent.is_repeated,\n      origin.type,\n      schema_feature=_get_promote_schema_feature(\n          origin.schema_feature, origin_parent.schema_feature))\n  self._origin = origin\n  self._origin_parent = origin_parent\n  if self.type is None:\n    raise ValueError(\"Can only promote a field\")\n  if self._origin_parent.type is not None:\n    raise ValueError(\"origin_parent cannot be a field\")\n</code></pre> Attributes\u00b6 <code></code> is_leaf <code>property</code> \u00b6 <pre><code>is_leaf: bool\n</code></pre> <p>True iff the node tensor is a LeafNodeTensor.</p> <code></code> is_repeated <code>property</code> \u00b6 <pre><code>is_repeated: bool\n</code></pre> <p>True iff the same parent value can have multiple children values.</p> <code></code> schema_feature <code>property</code> \u00b6 <pre><code>schema_feature: Optional[Feature]\n</code></pre> <p>Return the schema of the field.</p> <code></code> type <code>property</code> \u00b6 <pre><code>type: Optional[DType]\n</code></pre> <p>dtype of the expression, or None if not a leaf expression.</p> <code></code> validate_step_format <code>property</code> \u00b6 <pre><code>validate_step_format: bool\n</code></pre> Functions\u00b6 <code></code> apply \u00b6 <pre><code>apply(\n    transform: Callable[[Expression], Expression],\n) -&gt; Expression\n</code></pre> Source code in <code>struct2tensor/expression.py</code> <pre><code>def apply(self,\n          transform: Callable[[\"Expression\"], \"Expression\"]) -&gt; \"Expression\":\n  return transform(self)\n</code></pre> <code></code> apply_schema \u00b6 <pre><code>apply_schema(schema: Schema) -&gt; Expression\n</code></pre> Source code in <code>struct2tensor/expression.py</code> <pre><code>def apply_schema(self, schema: schema_pb2.Schema) -&gt; \"Expression\":\n  return apply_schema.apply_schema(self, schema)\n</code></pre> <code></code> broadcast \u00b6 <pre><code>broadcast(\n    source_path: CoercableToPath,\n    sibling_field: Step,\n    new_field_name: Step,\n) -&gt; Expression\n</code></pre> <p>Broadcasts the existing field at source_path to the sibling_field.</p> Source code in <code>struct2tensor/expression.py</code> <pre><code>def broadcast(self, source_path: CoercableToPath, sibling_field: path.Step,\n              new_field_name: path.Step) -&gt; \"Expression\":\n  \"\"\"Broadcasts the existing field at source_path to the sibling_field.\"\"\"\n  return broadcast.broadcast(self, path.create_path(source_path),\n                             sibling_field, new_field_name)\n</code></pre> <code></code> calculate \u00b6 <pre><code>calculate(\n    sources: Sequence[NodeTensor],\n    destinations: Sequence[Expression],\n    options: Options,\n    side_info: Optional[Prensor] = None,\n) -&gt; NodeTensor\n</code></pre> <p>Calculates the node tensor of the expression.</p> <p>The node tensor must be a function of the properties of the expression and the node tensors of the expressions from get_source_expressions().</p> <p>If is_leaf, then calculate must return a LeafNodeTensor. Otherwise, it must return a ChildNodeTensor or RootNodeTensor.</p> <p>If calculate_is_identity is true, then this must return source_tensors[0].</p> <p>Sometimes, for operations such as parsing the proto, calculate will return additional information. For example, calculate() for the root of the proto expression also parses out the tensors required to calculate the tensors of the children. This is why destinations are required.</p> <p>For a reference use, see calculate_value_slowly(...) below.</p> PARAMETER DESCRIPTION <code>source_tensors</code> <p>The node tensors of the expressions in get_source_expressions().</p> <p> TYPE: <code>Sequence[NodeTensor]</code> </p> <code>destinations</code> <p>The expressions that will use the output of this method.</p> <p> TYPE: <code>Sequence[Expression]</code> </p> <code>options</code> <p>Options for the calculation.</p> <p> TYPE: <code>Options</code> </p> <code>side_info</code> <p>An optional prensor that is used to bind to a placeholder expression.</p> <p> TYPE: <code>Optional[Prensor]</code> DEFAULT: <code>None</code> </p> RETURNS DESCRIPTION <code>NodeTensor</code> <p>A NodeTensor representing the output of this expression.</p> Source code in <code>struct2tensor/expression_impl/promote.py</code> <pre><code>def calculate(\n    self,\n    sources: Sequence[prensor.NodeTensor],\n    destinations: Sequence[expression.Expression],\n    options: calculate_options.Options,\n    side_info: Optional[prensor.Prensor] = None) -&gt; prensor.NodeTensor:\n  [origin_value, origin_parent_value] = sources\n  if not isinstance(origin_value, prensor.LeafNodeTensor):\n    raise ValueError(\"origin_value must be a leaf\")\n  if not isinstance(origin_parent_value, prensor.ChildNodeTensor):\n    raise ValueError(\"origin_parent_value must be a child node\")\n  new_parent_index = tf.gather(origin_parent_value.parent_index,\n                               origin_value.parent_index)\n  return prensor.LeafNodeTensor(new_parent_index, origin_value.values,\n                                self.is_repeated)\n</code></pre> <code></code> calculation_equal \u00b6 <pre><code>calculation_equal(expr: Expression) -&gt; bool\n</code></pre> <p>self.calculate is equal to another expression.calculate.</p> <p>Given the same source node tensors, self.calculate(...) and expression.calculate(...) will have the same result.</p> <p>Note that this does not check that the source expressions of the two expressions are the same. Therefore, two operations can have the same calculation, but not the same output, because their sources are different. For example, if a.calculation_is_identity() is True and b.calculation_is_identity() is True, then a.calculation_equal(b) is True. However, unless a and b have the same source, the expressions themselves are not equal.</p> PARAMETER DESCRIPTION <code>expression</code> <p>The expression to compare to.</p> <p> TYPE: <code>Expression</code> </p> Source code in <code>struct2tensor/expression_impl/promote.py</code> <pre><code>def calculation_equal(self, expr: expression.Expression) -&gt; bool:\n  return isinstance(expr, PromoteExpression)\n</code></pre> <code></code> calculation_is_identity \u00b6 <pre><code>calculation_is_identity() -&gt; bool\n</code></pre> <p>True iff the self.calculate is the identity.</p> <p>There is exactly one source, and the output of self.calculate(...) is the node tensor of this source.</p> Source code in <code>struct2tensor/expression_impl/promote.py</code> <pre><code>def calculation_is_identity(self) -&gt; bool:\n  return False\n</code></pre> <code></code> cogroup_by_index \u00b6 <pre><code>cogroup_by_index(\n    source_path: CoercableToPath,\n    left_name: Step,\n    right_name: Step,\n    new_field_name: Step,\n) -&gt; Expression\n</code></pre> <p>Creates a cogroup of left_name and right_name at new_field_name.</p> Source code in <code>struct2tensor/expression.py</code> <pre><code>def cogroup_by_index(self, source_path: CoercableToPath, left_name: path.Step,\n                     right_name: path.Step,\n                     new_field_name: path.Step) -&gt; \"Expression\":\n  \"\"\"Creates a cogroup of left_name and right_name at new_field_name.\"\"\"\n  raise NotImplementedError(\"cogroup_by_index is not implemented\")\n</code></pre> <code></code> create_has_field \u00b6 <pre><code>create_has_field(\n    source_path: CoercableToPath, new_field_name: Step\n) -&gt; Expression\n</code></pre> <p>Creates a field that is the presence of the source path.</p> Source code in <code>struct2tensor/expression.py</code> <pre><code>def create_has_field(self, source_path: CoercableToPath,\n                     new_field_name: path.Step) -&gt; \"Expression\":\n  \"\"\"Creates a field that is the presence of the source path.\"\"\"\n  return size.has(self, path.create_path(source_path), new_field_name)\n</code></pre> <code></code> create_proto_index \u00b6 <pre><code>create_proto_index(field_name: Step) -&gt; Expression\n</code></pre> <p>Creates a proto index field as a direct child of the current root.</p> <p>The proto index maps each root element to the original batch index. For example: [0, 2] means the first element came from the first proto in the original input tensor and the second element came from the third proto. The created field is always \"dense\" -- it has the same valency as the current root.</p> PARAMETER DESCRIPTION <code>field_name</code> <p>the name of the field to be created.</p> <p> TYPE: <code>Step</code> </p> RETURNS DESCRIPTION <code>Expression</code> <p>An Expression object representing the result of the operation.</p> Source code in <code>struct2tensor/expression.py</code> <pre><code>def create_proto_index(self, field_name: path.Step) -&gt; \"Expression\":\n  \"\"\"Creates a proto index field as a direct child of the current root.\n\n  The proto index maps each root element to the original batch index.\n  For example: [0, 2] means the first element came from the first proto\n  in the original input tensor and the second element came from the third\n  proto. The created field is always \"dense\" -- it has the same valency as\n  the current root.\n\n  Args:\n    field_name: the name of the field to be created.\n\n  Returns:\n    An Expression object representing the result of the operation.\n  \"\"\"\n\n  return reroot.create_proto_index_field(self, field_name)\n</code></pre> <code></code> create_size_field \u00b6 <pre><code>create_size_field(\n    source_path: CoercableToPath, new_field_name: Step\n) -&gt; Expression\n</code></pre> <p>Creates a field that is the size of the source path.</p> Source code in <code>struct2tensor/expression.py</code> <pre><code>def create_size_field(self, source_path: CoercableToPath,\n                      new_field_name: path.Step) -&gt; \"Expression\":\n  \"\"\"Creates a field that is the size of the source path.\"\"\"\n  return size.size(self, path.create_path(source_path), new_field_name)\n</code></pre> <code></code> get_child \u00b6 <pre><code>get_child(field_name: Step) -&gt; Optional[Expression]\n</code></pre> <p>Gets a named child.</p> Source code in <code>struct2tensor/expression.py</code> <pre><code>def get_child(self, field_name: path.Step) -&gt; Optional[\"Expression\"]:\n  \"\"\"Gets a named child.\"\"\"\n  if field_name in self._child_cache:\n    return self._child_cache[field_name]\n  result = self._get_child_impl(field_name)\n  self._child_cache[field_name] = result\n  return result\n</code></pre> <code></code> get_child_or_error \u00b6 <pre><code>get_child_or_error(field_name: Step) -&gt; Expression\n</code></pre> <p>Gets a named child.</p> Source code in <code>struct2tensor/expression.py</code> <pre><code>def get_child_or_error(self, field_name: path.Step) -&gt; \"Expression\":\n  \"\"\"Gets a named child.\"\"\"\n  result = self.get_child(field_name)\n  if result is None:\n    raise KeyError(\"No such field: {}\".format(field_name))\n  return result\n</code></pre> <code></code> get_descendant \u00b6 <pre><code>get_descendant(p: Path) -&gt; Optional[Expression]\n</code></pre> <p>Finds the descendant at the path.</p> Source code in <code>struct2tensor/expression.py</code> <pre><code>def get_descendant(self, p: path.Path) -&gt; Optional[\"Expression\"]:\n  \"\"\"Finds the descendant at the path.\"\"\"\n  result = self\n  for field_name in p.field_list:\n    result = result.get_child(field_name)\n    if result is None:\n      return None\n  return result\n</code></pre> <code></code> get_descendant_or_error \u00b6 <pre><code>get_descendant_or_error(p: Path) -&gt; Expression\n</code></pre> <p>Finds the descendant at the path.</p> Source code in <code>struct2tensor/expression.py</code> <pre><code>def get_descendant_or_error(self, p: path.Path) -&gt; \"Expression\":\n  \"\"\"Finds the descendant at the path.\"\"\"\n  result = self.get_descendant(p)\n  if result is None:\n    raise ValueError(\"Missing path: {} in {}\".format(\n        str(p), self.schema_string(limit=20)))\n  return result\n</code></pre> <code></code> get_known_children \u00b6 <pre><code>get_known_children() -&gt; Mapping[Step, Expression]\n</code></pre> Source code in <code>struct2tensor/expression.py</code> <pre><code>def get_known_children(self) -&gt; Mapping[path.Step, \"Expression\"]:\n  known_field_names = self.known_field_names()\n  result = {}\n  for name in known_field_names:\n    result[name] = self.get_child_or_error(name)\n  return result\n</code></pre> <code></code> get_known_descendants \u00b6 <pre><code>get_known_descendants() -&gt; Mapping[Path, Expression]\n</code></pre> <p>Gets a mapping from known paths to subexpressions.</p> <p>The difference between this and get_descendants in Prensor is that all paths in a Prensor are realized, thus all known. But an Expression's descendants might not all be known at the point this method is called, because an expression may have an infinite number of children.</p> RETURNS DESCRIPTION <code>Mapping[Path, Expression]</code> <p>A mapping from paths (relative to the root of the subexpression) to expressions.</p> Source code in <code>struct2tensor/expression.py</code> <pre><code>def get_known_descendants(self) -&gt; Mapping[path.Path, \"Expression\"]:\n  # Rename get_known_descendants\n  \"\"\"Gets a mapping from known paths to subexpressions.\n\n  The difference between this and get_descendants in Prensor is that\n  all paths in a Prensor are realized, thus all known. But an Expression's\n  descendants might not all be known at the point this method is called,\n  because an expression may have an infinite number of children.\n\n  Returns:\n    A mapping from paths (relative to the root of the subexpression) to\n      expressions.\n  \"\"\"\n  known_subexpressions = {\n      k: v.get_known_descendants()\n      for k, v in self.get_known_children().items()\n  }\n  result = {}\n  for field_name, subexpression in known_subexpressions.items():\n    subexpression_path = path.Path(\n        [field_name], validate_step_format=self.validate_step_format\n    )\n    for p, expr in subexpression.items():\n      result[subexpression_path.concat(p)] = expr\n  result[path.Path([], validate_step_format=self.validate_step_format)] = self\n  return result\n</code></pre> <code></code> get_paths_with_schema \u00b6 <pre><code>get_paths_with_schema() -&gt; List[Path]\n</code></pre> <p>Extract only paths that contain schema information.</p> Source code in <code>struct2tensor/expression.py</code> <pre><code>def get_paths_with_schema(self) -&gt; List[path.Path]:\n  \"\"\"Extract only paths that contain schema information.\"\"\"\n  result = []\n  for name, child in self.get_known_children().items():\n    if child.schema_feature is None:\n      continue\n    result.extend(\n        [\n            path.Path(\n                [name], validate_step_format=self.validate_step_format\n            ).concat(x)\n            for x in child.get_paths_with_schema()\n        ]\n    )\n  # Note: We always take the root path and so will return an empty schema\n  # if there is no schema information on any nodes, including the root.\n  if not result:\n    result.append(\n        path.Path([], validate_step_format=self.validate_step_format)\n    )\n  return result\n</code></pre> <code></code> get_schema \u00b6 <pre><code>get_schema(create_schema_features=True) -&gt; Schema\n</code></pre> <p>Returns a schema for the entire tree.</p> PARAMETER DESCRIPTION <code>create_schema_features</code> <p>If True, schema features are added for all children and a schema entry is created if not available on the child. If False, features are left off of the returned schema if there is no schema_feature on the child.</p> <p> DEFAULT: <code>True</code> </p> Source code in <code>struct2tensor/expression.py</code> <pre><code>def get_schema(self, create_schema_features=True) -&gt; schema_pb2.Schema:\n  \"\"\"Returns a schema for the entire tree.\n\n  Args:\n    create_schema_features: If True, schema features are added for all\n      children and a schema entry is created if not available on the child. If\n      False, features are left off of the returned schema if there is no\n      schema_feature on the child.\n  \"\"\"\n  if not create_schema_features:\n    return self.project(self.get_paths_with_schema()).get_schema()\n  result = schema_pb2.Schema()\n  self._populate_schema_feature_children(result.feature)\n  return result\n</code></pre> <code></code> get_source_expressions \u00b6 <pre><code>get_source_expressions() -&gt; Sequence[Expression]\n</code></pre> <p>Gets the sources of this expression.</p> <p>The node tensors of the source expressions must be sufficient to calculate the node tensor of this expression (see calculate and calculate_value_slowly).</p> RETURNS DESCRIPTION <code>Sequence[Expression]</code> <p>The sources of this expression.</p> Source code in <code>struct2tensor/expression_impl/promote.py</code> <pre><code>def get_source_expressions(self) -&gt; Sequence[expression.Expression]:\n  return [self._origin, self._origin_parent]\n</code></pre> <code></code> known_field_names \u00b6 <pre><code>known_field_names() -&gt; FrozenSet[Step]\n</code></pre> <p>Returns known field names of the expression.</p> <p>TODO(martinz): implement set_field and project. Known field names of a parsed proto correspond to the fields declared in the message. Examples of \"unknown\" fields are extensions and explicit casts in an any field. The only way to know if an unknown field \"(foo.bar)\" is present in an expression expr is to call (expr[\"(foo.bar)\"] is not None).</p> <p>Notice that simply accessing a field does not make it \"known\". However, setting a field (or setting a descendant of a field) will make it known.</p> <p>project(...) returns an expression where the known field names are the only field names. In general, if you want to depend upon known_field_names (e.g., if you want to compile a expression), then the best approach is to project() the expression first.</p> RETURNS DESCRIPTION <code>FrozenSet[Step]</code> <p>An immutable set of field names.</p> Source code in <code>struct2tensor/expression.py</code> <pre><code>def known_field_names(self) -&gt; FrozenSet[path.Step]:\n  return frozenset()\n</code></pre> <code></code> map_field_values \u00b6 <pre><code>map_field_values(\n    source_path: CoercableToPath,\n    operator: Callable[[Tensor], Tensor],\n    dtype: DType,\n    new_field_name: Step,\n) -&gt; Expression\n</code></pre> <p>Map a primitive field to create a new primitive field.</p> <p>Note</p> <p>The dtype argument is added since the v1 API.</p> PARAMETER DESCRIPTION <code>source_path</code> <p>the origin path.</p> <p> TYPE: <code>CoercableToPath</code> </p> <code>operator</code> <p>an element-wise operator that takes a 1-dimensional vector.</p> <p> TYPE: <code>Callable[[Tensor], Tensor]</code> </p> <code>dtype</code> <p>the type of the output.</p> <p> TYPE: <code>DType</code> </p> <code>new_field_name</code> <p>the name of a new sibling of source_path.</p> <p> TYPE: <code>Step</code> </p> RETURNS DESCRIPTION <code>Expression</code> <p>the resulting root expression.</p> Source code in <code>struct2tensor/expression.py</code> <pre><code>def map_field_values(self, source_path: CoercableToPath,\n                     operator: Callable[[tf.Tensor], tf.Tensor],\n                     dtype: tf.DType,\n                     new_field_name: path.Step) -&gt; \"Expression\":\n  \"\"\"Map a primitive field to create a new primitive field.\n\n  !!! Note\n      The dtype argument is added since the v1 API.\n\n  Args:\n    source_path: the origin path.\n    operator: an element-wise operator that takes a 1-dimensional vector.\n    dtype: the type of the output.\n    new_field_name: the name of a new sibling of source_path.\n\n  Returns:\n    the resulting root expression.\n  \"\"\"\n  return map_values.map_values(self, path.create_path(source_path), operator,\n                               dtype, new_field_name)\n</code></pre> <code></code> map_ragged_tensors \u00b6 <pre><code>map_ragged_tensors(\n    parent_path: CoercableToPath,\n    source_fields: Sequence[Step],\n    operator: Callable[..., SparseTensor],\n    is_repeated: bool,\n    dtype: DType,\n    new_field_name: Step,\n) -&gt; Expression\n</code></pre> <p>Maps a set of primitive fields of a message to a new field.</p> <p>Unlike map_field_values, this operation allows you to some degree reshape the field. For instance, you can take two optional fields and create a repeated field, or perform a reduce_sum on the last dimension of a repeated field and create an optional field. The key constraint is that the operator must return a sparse tensor of the correct dimension: i.e., a 2D sparse tensor if is_repeated is true, or a 1D sparse tensor if is_repeated is false. Moreover, the first dimension of the sparse tensor must be equal to the first dimension of the input tensor.</p> PARAMETER DESCRIPTION <code>parent_path</code> <p>the parent of the input and output fields.</p> <p> TYPE: <code>CoercableToPath</code> </p> <code>source_fields</code> <p>the nonempty list of names of the source fields.</p> <p> TYPE: <code>Sequence[Step]</code> </p> <code>operator</code> <p>an operator that takes len(source_fields) sparse tensors and returns a sparse tensor of the appropriate shape.</p> <p> TYPE: <code>Callable[..., SparseTensor]</code> </p> <code>is_repeated</code> <p>whether the output is repeated.</p> <p> TYPE: <code>bool</code> </p> <code>dtype</code> <p>the dtype of the result.</p> <p> TYPE: <code>DType</code> </p> <code>new_field_name</code> <p>the name of the resulting field.</p> <p> TYPE: <code>Step</code> </p> RETURNS DESCRIPTION <code>Expression</code> <p>A new query.</p> Source code in <code>struct2tensor/expression.py</code> <pre><code>def map_ragged_tensors(self, parent_path: CoercableToPath,\n                       source_fields: Sequence[path.Step],\n                       operator: Callable[..., tf.SparseTensor],\n                       is_repeated: bool, dtype: tf.DType,\n                       new_field_name: path.Step) -&gt; \"Expression\":\n  \"\"\"Maps a set of primitive fields of a message to a new field.\n\n  Unlike map_field_values, this operation allows you to some degree reshape\n  the field. For instance, you can take two optional fields and create a\n  repeated field, or perform a reduce_sum on the last dimension of a repeated\n  field and create an optional field. The key constraint is that the operator\n  must return a sparse tensor of the correct dimension: i.e., a\n  2D sparse tensor if is_repeated is true, or a 1D sparse tensor if\n  is_repeated is false. Moreover, the first dimension of the sparse tensor\n  must be equal to the first dimension of the input tensor.\n\n  Args:\n    parent_path: the parent of the input and output fields.\n    source_fields: the nonempty list of names of the source fields.\n    operator: an operator that takes len(source_fields) sparse tensors and\n      returns a sparse tensor of the appropriate shape.\n    is_repeated: whether the output is repeated.\n    dtype: the dtype of the result.\n    new_field_name: the name of the resulting field.\n\n  Returns:\n    A new query.\n  \"\"\"\n  return map_prensor.map_ragged_tensor(\n      self,\n      path.create_path(parent_path),\n      [\n          path.Path([f], validate_step_format=self.validate_step_format)\n          for f in source_fields\n      ],\n      operator,\n      is_repeated,\n      dtype,\n      new_field_name,\n  )\n</code></pre> <code></code> map_sparse_tensors \u00b6 <pre><code>map_sparse_tensors(\n    parent_path: CoercableToPath,\n    source_fields: Sequence[Step],\n    operator: Callable[..., SparseTensor],\n    is_repeated: bool,\n    dtype: DType,\n    new_field_name: Step,\n) -&gt; Expression\n</code></pre> <p>Maps a set of primitive fields of a message to a new field.</p> <p>Unlike map_field_values, this operation allows you to some degree reshape the field. For instance, you can take two optional fields and create a repeated field, or perform a reduce_sum on the last dimension of a repeated field and create an optional field. The key constraint is that the operator must return a sparse tensor of the correct dimension: i.e., a 2D sparse tensor if is_repeated is true, or a 1D sparse tensor if is_repeated is false. Moreover, the first dimension of the sparse tensor must be equal to the first dimension of the input tensor.</p> PARAMETER DESCRIPTION <code>parent_path</code> <p>the parent of the input and output fields.</p> <p> TYPE: <code>CoercableToPath</code> </p> <code>source_fields</code> <p>the nonempty list of names of the source fields.</p> <p> TYPE: <code>Sequence[Step]</code> </p> <code>operator</code> <p>an operator that takes len(source_fields) sparse tensors and returns a sparse tensor of the appropriate shape.</p> <p> TYPE: <code>Callable[..., SparseTensor]</code> </p> <code>is_repeated</code> <p>whether the output is repeated.</p> <p> TYPE: <code>bool</code> </p> <code>dtype</code> <p>the dtype of the result.</p> <p> TYPE: <code>DType</code> </p> <code>new_field_name</code> <p>the name of the resulting field.</p> <p> TYPE: <code>Step</code> </p> RETURNS DESCRIPTION <code>Expression</code> <p>A new query.</p> Source code in <code>struct2tensor/expression.py</code> <pre><code>def map_sparse_tensors(self, parent_path: CoercableToPath,\n                       source_fields: Sequence[path.Step],\n                       operator: Callable[..., tf.SparseTensor],\n                       is_repeated: bool, dtype: tf.DType,\n                       new_field_name: path.Step) -&gt; \"Expression\":\n  \"\"\"Maps a set of primitive fields of a message to a new field.\n\n  Unlike map_field_values, this operation allows you to some degree reshape\n  the field. For instance, you can take two optional fields and create a\n  repeated field, or perform a reduce_sum on the last dimension of a repeated\n  field and create an optional field. The key constraint is that the operator\n  must return a sparse tensor of the correct dimension: i.e., a\n  2D sparse tensor if is_repeated is true, or a 1D sparse tensor if\n  is_repeated is false. Moreover, the first dimension of the sparse tensor\n  must be equal to the first dimension of the input tensor.\n\n  Args:\n    parent_path: the parent of the input and output fields.\n    source_fields: the nonempty list of names of the source fields.\n    operator: an operator that takes len(source_fields) sparse tensors and\n      returns a sparse tensor of the appropriate shape.\n    is_repeated: whether the output is repeated.\n    dtype: the dtype of the result.\n    new_field_name: the name of the resulting field.\n\n  Returns:\n    A new query.\n  \"\"\"\n  return map_prensor.map_sparse_tensor(\n      self,\n      path.create_path(parent_path),\n      [\n          path.Path([f], validate_step_format=self.validate_step_format)\n          for f in source_fields\n      ],\n      operator,\n      is_repeated,\n      dtype,\n      new_field_name,\n  )\n</code></pre> <code></code> project \u00b6 <pre><code>project(path_list: Sequence[CoercableToPath]) -&gt; Expression\n</code></pre> <p>Constrains the paths to those listed.</p> Source code in <code>struct2tensor/expression.py</code> <pre><code>def project(self, path_list: Sequence[CoercableToPath]) -&gt; \"Expression\":\n  \"\"\"Constrains the paths to those listed.\"\"\"\n  return project.project(self, [path.create_path(x) for x in path_list])\n</code></pre> <code></code> promote \u00b6 <pre><code>promote(source_path: CoercableToPath, new_field_name: Step)\n</code></pre> <p>Promotes source_path to be a field new_field_name in its grandparent.</p> Source code in <code>struct2tensor/expression.py</code> <pre><code>def promote(self, source_path: CoercableToPath, new_field_name: path.Step):\n  \"\"\"Promotes source_path to be a field new_field_name in its grandparent.\"\"\"\n  return promote.promote(self, path.create_path(source_path), new_field_name)\n</code></pre> <code></code> promote_and_broadcast \u00b6 <pre><code>promote_and_broadcast(\n    path_dictionary: Mapping[Step, CoercableToPath],\n    dest_path_parent: CoercableToPath,\n) -&gt; Expression\n</code></pre> Source code in <code>struct2tensor/expression.py</code> <pre><code>def promote_and_broadcast(\n    self, path_dictionary: Mapping[path.Step, CoercableToPath],\n    dest_path_parent: CoercableToPath) -&gt; \"Expression\":\n  return promote_and_broadcast.promote_and_broadcast(\n      self, {k: path.create_path(v) for k, v in path_dictionary.items()},\n      path.create_path(dest_path_parent))\n</code></pre> <code></code> reroot \u00b6 <pre><code>reroot(new_root: CoercableToPath) -&gt; Expression\n</code></pre> <p>Returns a new list of protocol buffers available at new_root.</p> Source code in <code>struct2tensor/expression.py</code> <pre><code>def reroot(self, new_root: CoercableToPath) -&gt; \"Expression\":\n  \"\"\"Returns a new list of protocol buffers available at new_root.\"\"\"\n  return reroot.reroot(self, path.create_path(new_root))\n</code></pre> <code></code> schema_string \u00b6 <pre><code>schema_string(limit: Optional[int] = None) -&gt; str\n</code></pre> <p>Returns a schema for the expression.</p> <p>For examle, </p><pre><code>repeated root:\n  optional int32 foo\n  optional bar:\n    optional string baz\n  optional int64 bak\n</code></pre> <p>Note that unknown fields and subexpressions are not displayed.</p> PARAMETER DESCRIPTION <code>limit</code> <p>if present, limit the recursion.</p> <p> TYPE: <code>Optional[int]</code> DEFAULT: <code>None</code> </p> RETURNS DESCRIPTION <code>str</code> <p>A string, describing (a part of) the schema.</p> Source code in <code>struct2tensor/expression.py</code> <pre><code>def schema_string(self, limit: Optional[int] = None) -&gt; str:\n  \"\"\"Returns a schema for the expression.\n\n  For examle,\n  ```\n  repeated root:\n    optional int32 foo\n    optional bar:\n      optional string baz\n    optional int64 bak\n  ```\n\n  Note that unknown fields and subexpressions are not displayed.\n\n  Args:\n    limit: if present, limit the recursion.\n\n  Returns:\n    A string, describing (a part of) the schema.\n  \"\"\"\n  return \"\\n\".join(self._schema_string_helper(\"root\", limit))\n</code></pre> <code></code> slice \u00b6 <pre><code>slice(\n    source_path: CoercableToPath,\n    new_field_name: Step,\n    begin: Optional[IndexValue] = None,\n    end: Optional[IndexValue] = None,\n) -&gt; Expression\n</code></pre> <p>Creates a slice copy of source_path at new_field_path.</p> <p>Note that if begin or end is negative, it is considered relative to the size of the array. e.g., slice(...,begin=-1) will get the last element of every array.</p> PARAMETER DESCRIPTION <code>source_path</code> <p>the source of the slice.</p> <p> TYPE: <code>CoercableToPath</code> </p> <code>new_field_name</code> <p>the new field that is generated.</p> <p> TYPE: <code>Step</code> </p> <code>begin</code> <p>the beginning of the slice (inclusive).</p> <p> TYPE: <code>Optional[IndexValue]</code> DEFAULT: <code>None</code> </p> <code>end</code> <p>the end of the slice (exclusive).</p> <p> TYPE: <code>Optional[IndexValue]</code> DEFAULT: <code>None</code> </p> RETURNS DESCRIPTION <code>Expression</code> <p>An Expression object representing the result of the operation.</p> Source code in <code>struct2tensor/expression.py</code> <pre><code>def slice(self,\n          source_path: CoercableToPath,\n          new_field_name: path.Step,\n          begin: Optional[IndexValue] = None,\n          end: Optional[IndexValue] = None) -&gt; \"Expression\":\n  \"\"\"Creates a slice copy of source_path at new_field_path.\n\n  Note that if begin or end is negative, it is considered relative to\n  the size of the array. e.g., slice(...,begin=-1) will get the last\n  element of every array.\n\n  Args:\n    source_path: the source of the slice.\n    new_field_name: the new field that is generated.\n    begin: the beginning of the slice (inclusive).\n    end: the end of the slice (exclusive).\n\n  Returns:\n    An Expression object representing the result of the operation.\n  \"\"\"\n  return slice_expression.slice_expression(self,\n                                           path.create_path(source_path),\n                                           new_field_name, begin, end)\n</code></pre> <code></code> truncate \u00b6 <pre><code>truncate(\n    source_path: CoercableToPath,\n    limit: Union[int, Tensor],\n    new_field_name: Step,\n) -&gt; Expression\n</code></pre> <p>Creates a truncated copy of source_path at new_field_path.</p> Source code in <code>struct2tensor/expression.py</code> <pre><code>def truncate(self, source_path: CoercableToPath, limit: Union[int, tf.Tensor],\n             new_field_name: path.Step) -&gt; \"Expression\":\n  \"\"\"Creates a truncated copy of source_path at new_field_path.\"\"\"\n  return self.slice(source_path, new_field_name, end=limit)\n</code></pre>"},{"location":"api_docs/python/expression_impl/expression_impl/#struct2tensor.expression_impl.promote-functions","title":"Functions","text":""},{"location":"api_docs/python/expression_impl/expression_impl/#struct2tensor.expression_impl.promote.promote","title":"promote","text":"<pre><code>promote(\n    root: Expression, p: Path, new_field_name: Step\n) -&gt; Expression\n</code></pre> <p>Promote a path to be a child of its grandparent, and give it a name.</p> Source code in <code>struct2tensor/expression_impl/promote.py</code> <pre><code>def promote(root: expression.Expression, p: path.Path,\n            new_field_name: path.Step) -&gt; expression.Expression:\n  \"\"\"Promote a path to be a child of its grandparent, and give it a name.\"\"\"\n  return _promote_impl(root, p, new_field_name)[0]\n</code></pre>"},{"location":"api_docs/python/expression_impl/expression_impl/#struct2tensor.expression_impl.promote.promote_anonymous","title":"promote_anonymous","text":"<pre><code>promote_anonymous(\n    root: Expression, p: Path\n) -&gt; Tuple[Expression, Path]\n</code></pre> <p>Promote a path to be a new anonymous child of its grandparent.</p> Source code in <code>struct2tensor/expression_impl/promote.py</code> <pre><code>def promote_anonymous(root: expression.Expression,\n                      p: path.Path) -&gt; Tuple[expression.Expression, path.Path]:\n  \"\"\"Promote a path to be a new anonymous child of its grandparent.\"\"\"\n  return _promote_impl(root, p, path.get_anonymous_field())\n</code></pre>"},{"location":"api_docs/python/expression_impl/expression_impl/#struct2tensor.expression_impl.promote-modules","title":"Modules","text":""},{"location":"api_docs/python/expression_impl/expression_impl/#struct2tensor.expression_impl.promote_and_broadcast","title":"promote_and_broadcast","text":"<p>promote_and_broadcast a set of nodes.</p> <p>For example, suppose an expr represents:</p> <pre><code>+\n|\n+-session*   (stars indicate repeated)\n     |\n     +-event*\n     |   |\n     |   +-val*-int64\n     |\n     +-user_info? (question mark indicates optional)\n           |\n           +-age? int64\n</code></pre> <pre><code>session: {\n  event: {\n    val: 1\n  }\n  event: {\n    val: 4\n    val: 5\n  }\n  user_info: {\n    age: 25\n  }\n}\n\nsession: {\n  event: {\n    val: 7\n  }\n  event: {\n    val: 8\n    val: 9\n  }\n  user_info: {\n    age: 20\n  }\n}\n</code></pre> <pre><code>promote_and_broadcast.promote_and_broadcast(\n    path.Path([\"event\"]),{\"nage\":path.Path([\"user_info\",\"age\"])})\n</code></pre> <p>creates:</p> <pre><code>+\n|\n+-session*   (stars indicate repeated)\n     |\n     +-event*\n     |   |\n     |   +-val*-int64\n     |   |\n     |   +-nage*-int64\n     |\n     +-user_info? (question mark indicates optional)\n           |\n           +-age? int64\n</code></pre> <pre><code>session: {\n  event: {\n    nage: 25\n    val: 1\n  }\n  event: {\n    nage: 25\n    val: 4\n    val: 5\n  }\n  user_info: {\n    age: 25\n  }\n}\n\nsession: {\n  event: {\n    nage: 20\n    val: 7\n  }\n  event: {\n    nage: 20\n    val: 8\n    val: 9\n  }\n  user_info: {\n    age: 20\n  }\n}\n</code></pre> FUNCTION DESCRIPTION <code>promote_and_broadcast</code> <p>Promote and broadcast a set of paths to a particular location.</p> <code>promote_and_broadcast_anonymous</code> <p>Promotes then broadcasts the origin until its parent is new_parent.</p>"},{"location":"api_docs/python/expression_impl/expression_impl/#struct2tensor.expression_impl.promote_and_broadcast-functions","title":"Functions","text":""},{"location":"api_docs/python/expression_impl/expression_impl/#struct2tensor.expression_impl.promote_and_broadcast.promote_and_broadcast","title":"promote_and_broadcast","text":"<pre><code>promote_and_broadcast(\n    root: Expression,\n    path_dictionary: Mapping[Step, Path],\n    dest_path_parent: Path,\n) -&gt; Expression\n</code></pre> <p>Promote and broadcast a set of paths to a particular location.</p> PARAMETER DESCRIPTION <code>root</code> <p>the original expression.</p> <p> TYPE: <code>Expression</code> </p> <code>path_dictionary</code> <p>a map from destination fields to origin paths.</p> <p> TYPE: <code>Mapping[Step, Path]</code> </p> <code>dest_path_parent</code> <p>a map from destination strings.</p> <p> TYPE: <code>Path</code> </p> RETURNS DESCRIPTION <code>Expression</code> <p>A new expression, where all the origin paths are promoted and broadcast until they are children of dest_path_parent.</p> Source code in <code>struct2tensor/expression_impl/promote_and_broadcast.py</code> <pre><code>def promote_and_broadcast(root: expression.Expression,\n                          path_dictionary: Mapping[path.Step, path.Path],\n                          dest_path_parent: path.Path) -&gt; expression.Expression:\n  \"\"\"Promote and broadcast a set of paths to a particular location.\n\n  Args:\n    root: the original expression.\n    path_dictionary: a map from destination fields to origin paths.\n    dest_path_parent: a map from destination strings.\n\n  Returns:\n    A new expression, where all the origin paths are promoted and broadcast\n      until they are children of dest_path_parent.\n  \"\"\"\n\n  result_paths = {}\n  # Here, we branch out and create a different tree for each field that is\n  # promoted and broadcast.\n  for field_name, origin_path in path_dictionary.items():\n    result_path = dest_path_parent.get_child(field_name)\n    new_root = _promote_and_broadcast_name(root, origin_path, dest_path_parent,\n                                           field_name)\n    result_paths[result_path] = new_root\n  # We create a new tree that has all of the generated fields from the older\n  # trees.\n  return expression_add.add_to(root, result_paths)\n</code></pre>"},{"location":"api_docs/python/expression_impl/expression_impl/#struct2tensor.expression_impl.promote_and_broadcast.promote_and_broadcast_anonymous","title":"promote_and_broadcast_anonymous","text":"<pre><code>promote_and_broadcast_anonymous(\n    root: Expression, origin: Path, new_parent: Path\n) -&gt; Tuple[Expression, Path]\n</code></pre> <p>Promotes then broadcasts the origin until its parent is new_parent.</p> Source code in <code>struct2tensor/expression_impl/promote_and_broadcast.py</code> <pre><code>def promote_and_broadcast_anonymous(\n    root: expression.Expression, origin: path.Path,\n    new_parent: path.Path) -&gt; Tuple[expression.Expression, path.Path]:\n  \"\"\"Promotes then broadcasts the origin until its parent is new_parent.\"\"\"\n  least_common_ancestor = origin.get_least_common_ancestor(new_parent)\n\n  new_expr, new_path = root, origin\n  while new_path.get_parent() != least_common_ancestor:\n    new_expr, new_path = promote.promote_anonymous(new_expr, new_path)\n\n  while new_path.get_parent() != new_parent:\n    new_parent_step = new_parent.field_list[len(new_path) - 1]\n    new_expr, new_path = broadcast.broadcast_anonymous(new_expr, new_path,\n                                                       new_parent_step)\n\n  return new_expr, new_path\n</code></pre>"},{"location":"api_docs/python/expression_impl/expression_impl/#struct2tensor.expression_impl.promote_and_broadcast-modules","title":"Modules","text":""},{"location":"api_docs/python/expression_impl/expression_impl/#struct2tensor.expression_impl.proto","title":"proto","text":"<p>Expressions to parse a proto.</p> <p>These expressions return values with more information than standard node values. Specifically, each node calculates additional tensors that are used as inputs for its children.</p> FUNCTION DESCRIPTION <code>create_expression_from_file_descriptor_set</code> <p>Create an expression from a 1D tensor of serialized protos.</p> <code>create_expression_from_proto</code> <p>Create an expression from a 1D tensor of serialized protos.</p> <code>create_transformed_field</code> <p>Create an expression that transforms serialized proto tensors.</p> <code>is_proto_expression</code> <p>Returns true if an expression is a ProtoExpression.</p> ATTRIBUTE DESCRIPTION <code>ProtoExpression</code> <p> </p> <code>ProtoFieldName</code> <p> </p> <code>ProtoFullName</code> <p> </p> <code>StrStep</code> <p> </p> <code>TransformFn</code> <p> </p>"},{"location":"api_docs/python/expression_impl/expression_impl/#struct2tensor.expression_impl.proto-attributes","title":"Attributes","text":""},{"location":"api_docs/python/expression_impl/expression_impl/#struct2tensor.expression_impl.proto.ProtoExpression","title":"ProtoExpression  <code>module-attribute</code>","text":"<pre><code>ProtoExpression = Union[\n    _ProtoRootExpression,\n    _ProtoChildExpression,\n    _ProtoLeafExpression,\n]\n</code></pre>"},{"location":"api_docs/python/expression_impl/expression_impl/#struct2tensor.expression_impl.proto.ProtoFieldName","title":"ProtoFieldName  <code>module-attribute</code>","text":"<pre><code>ProtoFieldName = str\n</code></pre>"},{"location":"api_docs/python/expression_impl/expression_impl/#struct2tensor.expression_impl.proto.ProtoFullName","title":"ProtoFullName  <code>module-attribute</code>","text":"<pre><code>ProtoFullName = str\n</code></pre>"},{"location":"api_docs/python/expression_impl/expression_impl/#struct2tensor.expression_impl.proto.StrStep","title":"StrStep  <code>module-attribute</code>","text":"<pre><code>StrStep = str\n</code></pre>"},{"location":"api_docs/python/expression_impl/expression_impl/#struct2tensor.expression_impl.proto.TransformFn","title":"TransformFn  <code>module-attribute</code>","text":"<pre><code>TransformFn = Callable[\n    [Tensor, Tensor], Tuple[Tensor, Tensor]\n]\n</code></pre>"},{"location":"api_docs/python/expression_impl/expression_impl/#struct2tensor.expression_impl.proto-functions","title":"Functions","text":""},{"location":"api_docs/python/expression_impl/expression_impl/#struct2tensor.expression_impl.proto.create_expression_from_file_descriptor_set","title":"create_expression_from_file_descriptor_set","text":"<pre><code>create_expression_from_file_descriptor_set(\n    tensor_of_protos: Tensor,\n    proto_name: ProtoFullName,\n    file_descriptor_set: FileDescriptorSet,\n    message_format: str = \"binary\",\n) -&gt; Expression\n</code></pre> <p>Create an expression from a 1D tensor of serialized protos.</p> PARAMETER DESCRIPTION <code>tensor_of_protos</code> <p>1D tensor of serialized protos.</p> <p> TYPE: <code>Tensor</code> </p> <code>proto_name</code> <p>fully qualified name (e.g. \"some.package.SomeProto\") of the proto in <code>tensor_of_protos</code>.</p> <p> TYPE: <code>ProtoFullName</code> </p> <code>file_descriptor_set</code> <p>The FileDescriptorSet proto containing <code>proto_name</code>'s and all its dependencies' FileDescriptorProto. Note that if file1 imports file2, then file2's FileDescriptorProto must precede file1's in file_descriptor_set.file.</p> <p> TYPE: <code>FileDescriptorSet</code> </p> <code>message_format</code> <p>Indicates the format of the protocol buffer: is one of  'text' or 'binary'.</p> <p> TYPE: <code>str</code> DEFAULT: <code>'binary'</code> </p> RETURNS DESCRIPTION <code>Expression</code> <p>An expression.</p> Source code in <code>struct2tensor/expression_impl/proto.py</code> <pre><code>def create_expression_from_file_descriptor_set(\n    tensor_of_protos: tf.Tensor,\n    proto_name: ProtoFullName,\n    file_descriptor_set: descriptor_pb2.FileDescriptorSet,\n    message_format: str = \"binary\") -&gt; expression.Expression:\n  \"\"\"Create an expression from a 1D tensor of serialized protos.\n\n  Args:\n    tensor_of_protos: 1D tensor of serialized protos.\n    proto_name: fully qualified name (e.g. \"some.package.SomeProto\") of the\n      proto in `tensor_of_protos`.\n    file_descriptor_set: The FileDescriptorSet proto containing `proto_name`'s\n      and all its dependencies' FileDescriptorProto. Note that if file1 imports\n      file2, then file2's FileDescriptorProto must precede file1's in\n      file_descriptor_set.file.\n    message_format: Indicates the format of the protocol buffer: is one of\n       'text' or 'binary'.\n\n  Returns:\n    An expression.\n  \"\"\"\n\n  pool = DescriptorPool()\n  for f in file_descriptor_set.file:\n    # This method raises if f's dependencies have not been added.\n    pool.Add(f)\n\n  # This method raises if proto not found.\n  desc = pool.FindMessageTypeByName(proto_name)\n\n  return create_expression_from_proto(tensor_of_protos, desc, message_format)\n</code></pre>"},{"location":"api_docs/python/expression_impl/expression_impl/#struct2tensor.expression_impl.proto.create_expression_from_proto","title":"create_expression_from_proto","text":"<pre><code>create_expression_from_proto(\n    tensor_of_protos: Tensor,\n    desc: Descriptor,\n    message_format: str = \"binary\",\n) -&gt; Expression\n</code></pre> <p>Create an expression from a 1D tensor of serialized protos.</p> PARAMETER DESCRIPTION <code>tensor_of_protos</code> <p>1D tensor of serialized protos.</p> <p> TYPE: <code>Tensor</code> </p> <code>desc</code> <p>a descriptor of protos in tensor of protos.</p> <p> TYPE: <code>Descriptor</code> </p> <code>message_format</code> <p>Indicates the format of the protocol buffer: is one of 'text' or 'binary'.</p> <p> TYPE: <code>str</code> DEFAULT: <code>'binary'</code> </p> RETURNS DESCRIPTION <code>Expression</code> <p>An expression.</p> Source code in <code>struct2tensor/expression_impl/proto.py</code> <pre><code>def create_expression_from_proto(\n    tensor_of_protos: tf.Tensor,\n    desc: descriptor.Descriptor,\n    message_format: str = \"binary\") -&gt; expression.Expression:\n  \"\"\"Create an expression from a 1D tensor of serialized protos.\n\n  Args:\n    tensor_of_protos: 1D tensor of serialized protos.\n    desc: a descriptor of protos in tensor of protos.\n    message_format: Indicates the format of the protocol buffer: is one of\n      'text' or 'binary'.\n\n  Returns:\n    An expression.\n  \"\"\"\n  return _ProtoRootExpression(desc, tensor_of_protos, message_format)\n</code></pre>"},{"location":"api_docs/python/expression_impl/expression_impl/#struct2tensor.expression_impl.proto.create_transformed_field","title":"create_transformed_field","text":"<pre><code>create_transformed_field(\n    expr: Expression,\n    source_path: CoercableToPath,\n    dest_field: StrStep,\n    transform_fn: TransformFn,\n) -&gt; Expression\n</code></pre> <p>Create an expression that transforms serialized proto tensors.</p> <p>The transform_fn argument should take the form:</p> <p>def transform_fn(parent_indices, values):   ...   return (transformed_parent_indices, transformed_values)</p> <p>Given:</p> <ul> <li>parent_indices: an int64 vector of non-decreasing parent message indices.</li> <li>values: a string vector of serialized protos having the same shape as   <code>parent_indices</code>.</li> </ul> <p><code>transform_fn</code> must return new parent indices and serialized values encoding the same proto message as the passed in <code>values</code>.  These two vectors must have the same size, but it need not be the same as the input arguments.</p> <p>Note</p> <p>If CalculateOptions.use_string_view (set at calculate time, thus this Expression cannot know beforehand) is True, <code>values</code> passed to <code>transform_fn</code> are string views pointing all the way back to the original input tensor (of serialized root protos). And <code>transform_fn</code> must maintain such views and avoid creating new values that are either not string views into the root protos or self-owned strings. This is because downstream decoding ops will still produce string views referring into its input (which are string views into the root proto) and they will only hold a reference to the original, root proto tensor, keeping it alive. So the input tensor may get destroyed after the decoding op.</p> <p>In short, you can do element-wise transforms to <code>values</code>, but can't mutate the contents of elements in <code>values</code> or create new elements.</p> <p>To lift this restriction, a decoding op must be told to hold a reference of the input tensors of all its upstream decoding ops.</p> PARAMETER DESCRIPTION <code>expr</code> <p>a source expression containing <code>source_path</code>.</p> <p> TYPE: <code>Expression</code> </p> <code>source_path</code> <p>the path to the field to reverse.</p> <p> TYPE: <code>CoercableToPath</code> </p> <code>dest_field</code> <p>the name of the newly created field. This field will be a sibling of the field identified by <code>source_path</code>.</p> <p> TYPE: <code>StrStep</code> </p> <code>transform_fn</code> <p>a callable that accepts parent_indices and serialized proto values and returns a posibly modified parent_indices and values. Note that when CalcuateOptions.use_string_view is set, transform_fn should not have any stateful side effecting uses of serialized proto inputs. Doing so could cause segfaults as the backing string tensor lifetime is not guaranteed when the side effecting operations are run.</p> <p> TYPE: <code>TransformFn</code> </p> RETURNS DESCRIPTION <code>Expression</code> <p>An expression.</p> RAISES DESCRIPTION <code>ValueError</code> <p>if the source path is not a proto message field.</p> Source code in <code>struct2tensor/expression_impl/proto.py</code> <pre><code>def create_transformed_field(\n    expr: expression.Expression, source_path: path.CoercableToPath,\n    dest_field: StrStep, transform_fn: TransformFn) -&gt; expression.Expression:\n  \"\"\"Create an expression that transforms serialized proto tensors.\n\n  The transform_fn argument should take the form:\n\n  def transform_fn(parent_indices, values):\n    ...\n    return (transformed_parent_indices, transformed_values)\n\n  Given:\n\n  - parent_indices: an int64 vector of non-decreasing parent message indices.\n  - values: a string vector of serialized protos having the same shape as\n    `parent_indices`.\n\n  `transform_fn` must return new parent indices and serialized values encoding\n  the same proto message as the passed in `values`.  These two vectors must\n  have the same size, but it need not be the same as the input arguments.\n\n  !!! Note\n      If CalculateOptions.use_string_view (set at calculate time, thus this\n      Expression cannot know beforehand) is True, `values` passed to\n      `transform_fn` are string views pointing all the way back to the original\n      input tensor (of serialized root protos). And `transform_fn` must maintain\n      such views and avoid creating new values that are either not string views\n      into the root protos or self-owned strings. This is because downstream\n      decoding ops will still produce string views referring into its input\n      (which are string views into the root proto) and they will only hold a\n      reference to the original, root proto tensor, keeping it alive. So the input\n      tensor may get destroyed after the decoding op.\n\n      In short, you can do element-wise transforms to `values`, but can't mutate\n      the contents of elements in `values` or create new elements.\n\n      To lift this restriction, a decoding op must be told to hold a reference\n      of the input tensors of all its upstream decoding ops.\n\n\n  Args:\n    expr: a source expression containing `source_path`.\n    source_path: the path to the field to reverse.\n    dest_field: the name of the newly created field. This field will be a\n      sibling of the field identified by `source_path`.\n    transform_fn: a callable that accepts parent_indices and serialized proto\n      values and returns a posibly modified parent_indices and values. Note that\n      when CalcuateOptions.use_string_view is set, transform_fn should not have\n      any stateful side effecting uses of serialized proto inputs. Doing so\n      could cause segfaults as the backing string tensor lifetime is not\n      guaranteed when the side effecting operations are run.\n\n  Returns:\n    An expression.\n\n  Raises:\n    ValueError: if the source path is not a proto message field.\n  \"\"\"\n  source_path = path.create_path(source_path)\n  source_expr = expr.get_descendant_or_error(source_path)\n  if not isinstance(source_expr, _ProtoChildExpression):\n    raise ValueError(\n        \"Expected _ProtoChildExpression for field {}, but found {}.\".format(\n            str(source_path), source_expr))\n\n  if isinstance(source_expr, _TransformProtoChildExpression):\n    # In order to be able to propagate fields needed for parsing, the source\n    # expression of _TransformProtoChildExpression must always be the original\n    # _ProtoChildExpression before any transformation. This means that two\n    # sequentially applied _TransformProtoChildExpression would have the same\n    # source and would apply the transformation to the source directly, instead\n    # of one transform operating on the output of the other.\n    # To work around this, the user supplied transform function is wrapped to\n    # first call the source's transform function.\n    # The downside of this approach is that the initial transform may be\n    # applied redundantly if there are other expressions derived directly\n    # from it.\n    def final_transform(parent_indices: tf.Tensor,\n                        values: tf.Tensor) -&gt; Tuple[tf.Tensor, tf.Tensor]:\n      parent_indices, values = source_expr.transform_fn(parent_indices, values)\n      return transform_fn(parent_indices, values)\n  else:\n    final_transform = transform_fn\n\n  transformed_expr = _TransformProtoChildExpression(\n      parent=source_expr._parent,  # pylint: disable=protected-access\n      desc=source_expr._desc,  # pylint: disable=protected-access\n      is_repeated=source_expr.is_repeated,\n      name_as_field=source_expr.name_as_field,\n      transform_fn=final_transform,\n      backing_str_tensor=source_expr._backing_str_tensor)  # pylint: disable=protected-access\n  dest_path = source_path.get_parent().get_child(dest_field)\n  return expression_add.add_paths(expr, {dest_path: transformed_expr})\n</code></pre>"},{"location":"api_docs/python/expression_impl/expression_impl/#struct2tensor.expression_impl.proto.is_proto_expression","title":"is_proto_expression","text":"<pre><code>is_proto_expression(expr: Expression) -&gt; bool\n</code></pre> <p>Returns true if an expression is a ProtoExpression.</p> Source code in <code>struct2tensor/expression_impl/proto.py</code> <pre><code>def is_proto_expression(expr: expression.Expression) -&gt; bool:\n  \"\"\"Returns true if an expression is a ProtoExpression.\"\"\"\n  return isinstance(\n      expr, (_ProtoRootExpression, _ProtoChildExpression, _ProtoLeafExpression))\n</code></pre>"},{"location":"api_docs/python/expression_impl/expression_impl/#struct2tensor.expression_impl.proto-modules","title":"Modules","text":""},{"location":"api_docs/python/expression_impl/expression_impl/#struct2tensor.expression_impl.reroot","title":"reroot","text":"<p>Reroot to a subtree, maintaining an input proto index.</p> <p>reroot is similar to get_descendant_or_error. However, this method allows you to call create_proto_index(...) later on, that gives you a reference to the original proto.</p> FUNCTION DESCRIPTION <code>create_proto_index_field</code> <code>reroot</code> <p>Reroot to a new path, maintaining a input proto index.</p>"},{"location":"api_docs/python/expression_impl/expression_impl/#struct2tensor.expression_impl.reroot-functions","title":"Functions","text":""},{"location":"api_docs/python/expression_impl/expression_impl/#struct2tensor.expression_impl.reroot.create_proto_index_field","title":"create_proto_index_field","text":"<pre><code>create_proto_index_field(\n    root: Expression, new_field_name: Step\n) -&gt; Expression\n</code></pre> Source code in <code>struct2tensor/expression_impl/reroot.py</code> <pre><code>def create_proto_index_field(root: expression.Expression,\n                             new_field_name: path.Step\n                            ) -&gt; expression.Expression:\n  return expression_add.add_paths(\n      root, {path.Path([new_field_name]): _InputProtoIndexExpression(root)})\n</code></pre>"},{"location":"api_docs/python/expression_impl/expression_impl/#struct2tensor.expression_impl.reroot.reroot","title":"reroot","text":"<pre><code>reroot(root: Expression, source_path: Path) -&gt; Expression\n</code></pre> <p>Reroot to a new path, maintaining a input proto index.</p> <p>Similar to root.get_descendant_or_error(source_path): however, this method retains the ability to get a map to the original index.</p> PARAMETER DESCRIPTION <code>root</code> <p>the original root.</p> <p> TYPE: <code>Expression</code> </p> <code>source_path</code> <p>the path to the new root.</p> <p> TYPE: <code>Path</code> </p> RETURNS DESCRIPTION <code>Expression</code> <p>the new root.</p> Source code in <code>struct2tensor/expression_impl/reroot.py</code> <pre><code>def reroot(root: expression.Expression,\n           source_path: path.Path) -&gt; expression.Expression:\n  \"\"\"Reroot to a new path, maintaining a input proto index.\n\n  Similar to root.get_descendant_or_error(source_path): however, this\n  method retains the ability to get a map to the original index.\n\n  Args:\n    root: the original root.\n    source_path: the path to the new root.\n\n  Returns:\n    the new root.\n  \"\"\"\n\n  new_root = root\n  for step in source_path.field_list:\n    new_root = _RerootExpression(new_root, step)\n  return new_root\n</code></pre>"},{"location":"api_docs/python/expression_impl/expression_impl/#struct2tensor.expression_impl.reroot-modules","title":"Modules","text":""},{"location":"api_docs/python/expression_impl/expression_impl/#struct2tensor.expression_impl.size","title":"size","text":"<p>Functions for creating new size or has expression.</p> <p>Given a field \"foo.bar\",</p> <pre><code>root = size(expr, path.Path([\"foo\",\"bar\"]), \"bar_size\")\n</code></pre> <p>creates a new expression root that has an optional field \"foo.bar_size\", which is always present, and contains the number of bar in a particular foo.</p> <pre><code>root_2 = has(expr, path.Path([\"foo\",\"bar\"]), \"bar_has\")\n</code></pre> <p>creates a new expression root that has an optional field \"foo.bar_has\", which is always present, and is true if there are one or more bar in foo.</p> CLASS DESCRIPTION <code>SizeExpression</code> <p>Size of the given expression.</p> FUNCTION DESCRIPTION <code>has</code> <p>Get the has of a field as a new sibling field.</p> <code>size</code> <p>Get the size of a field as a new sibling field.</p> <code>size_anonymous</code> <p>Calculate the size of a field, and store it as an anonymous sibling.</p>"},{"location":"api_docs/python/expression_impl/expression_impl/#struct2tensor.expression_impl.size-classes","title":"Classes","text":""},{"location":"api_docs/python/expression_impl/expression_impl/#struct2tensor.expression_impl.size.SizeExpression","title":"SizeExpression","text":"<pre><code>SizeExpression(\n    origin: Expression, origin_parent: Expression\n)\n</code></pre> <p>               Bases: <code>Leaf</code></p> <p>Size of the given expression.</p> <p>SizeExpression is intended to be a sibling of origin. origin_parent should be the parent of origin.</p> <p>Initialize a Leaf.</p> <p>Note that a leaf must have a specified type.</p> PARAMETER DESCRIPTION <code>is_repeated</code> <p>if the expression is repeated.</p> <p> TYPE: <code>bool</code> </p> <code>my_type</code> <p>the DType of the field.</p> <p> TYPE: <code>DType</code> </p> <code>schema_feature</code> <p>schema information about the field.</p> <p> TYPE: <code>Optional[Feature]</code> DEFAULT: <code>None</code> </p> METHOD DESCRIPTION <code>apply</code> <code>apply_schema</code> <code>broadcast</code> <p>Broadcasts the existing field at source_path to the sibling_field.</p> <code>calculate</code> <p>Calculates the node tensor of the expression.</p> <code>calculation_equal</code> <p>self.calculate is equal to another expression.calculate.</p> <code>calculation_is_identity</code> <p>True iff the self.calculate is the identity.</p> <code>cogroup_by_index</code> <p>Creates a cogroup of left_name and right_name at new_field_name.</p> <code>create_has_field</code> <p>Creates a field that is the presence of the source path.</p> <code>create_proto_index</code> <p>Creates a proto index field as a direct child of the current root.</p> <code>create_size_field</code> <p>Creates a field that is the size of the source path.</p> <code>get_child</code> <p>Gets a named child.</p> <code>get_child_or_error</code> <p>Gets a named child.</p> <code>get_descendant</code> <p>Finds the descendant at the path.</p> <code>get_descendant_or_error</code> <p>Finds the descendant at the path.</p> <code>get_known_children</code> <code>get_known_descendants</code> <p>Gets a mapping from known paths to subexpressions.</p> <code>get_paths_with_schema</code> <p>Extract only paths that contain schema information.</p> <code>get_schema</code> <p>Returns a schema for the entire tree.</p> <code>get_source_expressions</code> <p>Gets the sources of this expression.</p> <code>known_field_names</code> <p>Returns known field names of the expression.</p> <code>map_field_values</code> <p>Map a primitive field to create a new primitive field.</p> <code>map_ragged_tensors</code> <p>Maps a set of primitive fields of a message to a new field.</p> <code>map_sparse_tensors</code> <p>Maps a set of primitive fields of a message to a new field.</p> <code>project</code> <p>Constrains the paths to those listed.</p> <code>promote</code> <p>Promotes source_path to be a field new_field_name in its grandparent.</p> <code>promote_and_broadcast</code> <code>reroot</code> <p>Returns a new list of protocol buffers available at new_root.</p> <code>schema_string</code> <p>Returns a schema for the expression.</p> <code>slice</code> <p>Creates a slice copy of source_path at new_field_path.</p> <code>truncate</code> <p>Creates a truncated copy of source_path at new_field_path.</p> ATTRIBUTE DESCRIPTION <code>is_leaf</code> <p>True iff the node tensor is a LeafNodeTensor.</p> <p> TYPE: <code>bool</code> </p> <code>is_repeated</code> <p>True iff the same parent value can have multiple children values.</p> <p> TYPE: <code>bool</code> </p> <code>schema_feature</code> <p>Return the schema of the field.</p> <p> TYPE: <code>Optional[Feature]</code> </p> <code>type</code> <p>dtype of the expression, or None if not a leaf expression.</p> <p> TYPE: <code>Optional[DType]</code> </p> <code>validate_step_format</code> <p> TYPE: <code>bool</code> </p> Source code in <code>struct2tensor/expression_impl/size.py</code> <pre><code>def __init__(self, origin: expression.Expression,\n             origin_parent: expression.Expression):\n  super().__init__(False, tf.int64)\n  self._origin = origin\n  self._origin_parent = origin_parent\n</code></pre> Attributes\u00b6 <code></code> is_leaf <code>property</code> \u00b6 <pre><code>is_leaf: bool\n</code></pre> <p>True iff the node tensor is a LeafNodeTensor.</p> <code></code> is_repeated <code>property</code> \u00b6 <pre><code>is_repeated: bool\n</code></pre> <p>True iff the same parent value can have multiple children values.</p> <code></code> schema_feature <code>property</code> \u00b6 <pre><code>schema_feature: Optional[Feature]\n</code></pre> <p>Return the schema of the field.</p> <code></code> type <code>property</code> \u00b6 <pre><code>type: Optional[DType]\n</code></pre> <p>dtype of the expression, or None if not a leaf expression.</p> <code></code> validate_step_format <code>property</code> \u00b6 <pre><code>validate_step_format: bool\n</code></pre> Functions\u00b6 <code></code> apply \u00b6 <pre><code>apply(\n    transform: Callable[[Expression], Expression],\n) -&gt; Expression\n</code></pre> Source code in <code>struct2tensor/expression.py</code> <pre><code>def apply(self,\n          transform: Callable[[\"Expression\"], \"Expression\"]) -&gt; \"Expression\":\n  return transform(self)\n</code></pre> <code></code> apply_schema \u00b6 <pre><code>apply_schema(schema: Schema) -&gt; Expression\n</code></pre> Source code in <code>struct2tensor/expression.py</code> <pre><code>def apply_schema(self, schema: schema_pb2.Schema) -&gt; \"Expression\":\n  return apply_schema.apply_schema(self, schema)\n</code></pre> <code></code> broadcast \u00b6 <pre><code>broadcast(\n    source_path: CoercableToPath,\n    sibling_field: Step,\n    new_field_name: Step,\n) -&gt; Expression\n</code></pre> <p>Broadcasts the existing field at source_path to the sibling_field.</p> Source code in <code>struct2tensor/expression.py</code> <pre><code>def broadcast(self, source_path: CoercableToPath, sibling_field: path.Step,\n              new_field_name: path.Step) -&gt; \"Expression\":\n  \"\"\"Broadcasts the existing field at source_path to the sibling_field.\"\"\"\n  return broadcast.broadcast(self, path.create_path(source_path),\n                             sibling_field, new_field_name)\n</code></pre> <code></code> calculate \u00b6 <pre><code>calculate(\n    sources: Sequence[NodeTensor],\n    destinations: Sequence[Expression],\n    options: Options,\n    side_info: Optional[Prensor] = None,\n) -&gt; NodeTensor\n</code></pre> <p>Calculates the node tensor of the expression.</p> <p>The node tensor must be a function of the properties of the expression and the node tensors of the expressions from get_source_expressions().</p> <p>If is_leaf, then calculate must return a LeafNodeTensor. Otherwise, it must return a ChildNodeTensor or RootNodeTensor.</p> <p>If calculate_is_identity is true, then this must return source_tensors[0].</p> <p>Sometimes, for operations such as parsing the proto, calculate will return additional information. For example, calculate() for the root of the proto expression also parses out the tensors required to calculate the tensors of the children. This is why destinations are required.</p> <p>For a reference use, see calculate_value_slowly(...) below.</p> PARAMETER DESCRIPTION <code>source_tensors</code> <p>The node tensors of the expressions in get_source_expressions().</p> <p> TYPE: <code>Sequence[NodeTensor]</code> </p> <code>destinations</code> <p>The expressions that will use the output of this method.</p> <p> TYPE: <code>Sequence[Expression]</code> </p> <code>options</code> <p>Options for the calculation.</p> <p> TYPE: <code>Options</code> </p> <code>side_info</code> <p>An optional prensor that is used to bind to a placeholder expression.</p> <p> TYPE: <code>Optional[Prensor]</code> DEFAULT: <code>None</code> </p> RETURNS DESCRIPTION <code>NodeTensor</code> <p>A NodeTensor representing the output of this expression.</p> Source code in <code>struct2tensor/expression_impl/size.py</code> <pre><code>def calculate(\n    self,\n    sources: Sequence[prensor.NodeTensor],\n    destinations: Sequence[expression.Expression],\n    options: calculate_options.Options,\n    side_info: Optional[prensor.Prensor] = None) -&gt; prensor.NodeTensor:\n\n  [origin_value, origin_parent_value] = sources\n  if not isinstance(origin_value,\n                    (prensor.LeafNodeTensor, prensor.ChildNodeTensor)):\n    raise ValueError(\n        \"origin_value must be a LeafNodeTensor or a ChildNodeTensor, \"\n        \"but was a \" + str(type(origin_value)))\n\n  if not isinstance(origin_parent_value,\n                    (prensor.ChildNodeTensor, prensor.RootNodeTensor)):\n    raise ValueError(\"origin_parent_value must be a ChildNodeTensor \"\n                     \"or a RootNodeTensor, but was a \" +\n                     str(type(origin_parent_value)))\n\n  parent_index = origin_value.parent_index\n  num_parent_protos = origin_parent_value.size\n  # A vector of 1s of the same size as the parent_index.\n  updates = tf.ones(tf.shape(parent_index), dtype=tf.int64)\n  indices = tf.expand_dims(parent_index, 1)\n  # This is incrementing the size by 1 for each element.\n  # Obviously, not the fastest way to do this.\n  values = tf.scatter_nd(indices, updates, tf.reshape(num_parent_protos, [1]))\n\n  # Need to create a new_parent_index = 0,1,2,3,4...n.\n  new_parent_index = tf.range(num_parent_protos, dtype=tf.int64)\n  return prensor.LeafNodeTensor(new_parent_index, values, False)\n</code></pre> <code></code> calculation_equal \u00b6 <pre><code>calculation_equal(expr: Expression) -&gt; bool\n</code></pre> <p>self.calculate is equal to another expression.calculate.</p> <p>Given the same source node tensors, self.calculate(...) and expression.calculate(...) will have the same result.</p> <p>Note that this does not check that the source expressions of the two expressions are the same. Therefore, two operations can have the same calculation, but not the same output, because their sources are different. For example, if a.calculation_is_identity() is True and b.calculation_is_identity() is True, then a.calculation_equal(b) is True. However, unless a and b have the same source, the expressions themselves are not equal.</p> PARAMETER DESCRIPTION <code>expression</code> <p>The expression to compare to.</p> <p> TYPE: <code>Expression</code> </p> Source code in <code>struct2tensor/expression_impl/size.py</code> <pre><code>def calculation_equal(self, expr: expression.Expression) -&gt; bool:\n  return isinstance(expr, SizeExpression)\n</code></pre> <code></code> calculation_is_identity \u00b6 <pre><code>calculation_is_identity() -&gt; bool\n</code></pre> <p>True iff the self.calculate is the identity.</p> <p>There is exactly one source, and the output of self.calculate(...) is the node tensor of this source.</p> Source code in <code>struct2tensor/expression_impl/size.py</code> <pre><code>def calculation_is_identity(self) -&gt; bool:\n  return False\n</code></pre> <code></code> cogroup_by_index \u00b6 <pre><code>cogroup_by_index(\n    source_path: CoercableToPath,\n    left_name: Step,\n    right_name: Step,\n    new_field_name: Step,\n) -&gt; Expression\n</code></pre> <p>Creates a cogroup of left_name and right_name at new_field_name.</p> Source code in <code>struct2tensor/expression.py</code> <pre><code>def cogroup_by_index(self, source_path: CoercableToPath, left_name: path.Step,\n                     right_name: path.Step,\n                     new_field_name: path.Step) -&gt; \"Expression\":\n  \"\"\"Creates a cogroup of left_name and right_name at new_field_name.\"\"\"\n  raise NotImplementedError(\"cogroup_by_index is not implemented\")\n</code></pre> <code></code> create_has_field \u00b6 <pre><code>create_has_field(\n    source_path: CoercableToPath, new_field_name: Step\n) -&gt; Expression\n</code></pre> <p>Creates a field that is the presence of the source path.</p> Source code in <code>struct2tensor/expression.py</code> <pre><code>def create_has_field(self, source_path: CoercableToPath,\n                     new_field_name: path.Step) -&gt; \"Expression\":\n  \"\"\"Creates a field that is the presence of the source path.\"\"\"\n  return size.has(self, path.create_path(source_path), new_field_name)\n</code></pre> <code></code> create_proto_index \u00b6 <pre><code>create_proto_index(field_name: Step) -&gt; Expression\n</code></pre> <p>Creates a proto index field as a direct child of the current root.</p> <p>The proto index maps each root element to the original batch index. For example: [0, 2] means the first element came from the first proto in the original input tensor and the second element came from the third proto. The created field is always \"dense\" -- it has the same valency as the current root.</p> PARAMETER DESCRIPTION <code>field_name</code> <p>the name of the field to be created.</p> <p> TYPE: <code>Step</code> </p> RETURNS DESCRIPTION <code>Expression</code> <p>An Expression object representing the result of the operation.</p> Source code in <code>struct2tensor/expression.py</code> <pre><code>def create_proto_index(self, field_name: path.Step) -&gt; \"Expression\":\n  \"\"\"Creates a proto index field as a direct child of the current root.\n\n  The proto index maps each root element to the original batch index.\n  For example: [0, 2] means the first element came from the first proto\n  in the original input tensor and the second element came from the third\n  proto. The created field is always \"dense\" -- it has the same valency as\n  the current root.\n\n  Args:\n    field_name: the name of the field to be created.\n\n  Returns:\n    An Expression object representing the result of the operation.\n  \"\"\"\n\n  return reroot.create_proto_index_field(self, field_name)\n</code></pre> <code></code> create_size_field \u00b6 <pre><code>create_size_field(\n    source_path: CoercableToPath, new_field_name: Step\n) -&gt; Expression\n</code></pre> <p>Creates a field that is the size of the source path.</p> Source code in <code>struct2tensor/expression.py</code> <pre><code>def create_size_field(self, source_path: CoercableToPath,\n                      new_field_name: path.Step) -&gt; \"Expression\":\n  \"\"\"Creates a field that is the size of the source path.\"\"\"\n  return size.size(self, path.create_path(source_path), new_field_name)\n</code></pre> <code></code> get_child \u00b6 <pre><code>get_child(field_name: Step) -&gt; Optional[Expression]\n</code></pre> <p>Gets a named child.</p> Source code in <code>struct2tensor/expression.py</code> <pre><code>def get_child(self, field_name: path.Step) -&gt; Optional[\"Expression\"]:\n  \"\"\"Gets a named child.\"\"\"\n  if field_name in self._child_cache:\n    return self._child_cache[field_name]\n  result = self._get_child_impl(field_name)\n  self._child_cache[field_name] = result\n  return result\n</code></pre> <code></code> get_child_or_error \u00b6 <pre><code>get_child_or_error(field_name: Step) -&gt; Expression\n</code></pre> <p>Gets a named child.</p> Source code in <code>struct2tensor/expression.py</code> <pre><code>def get_child_or_error(self, field_name: path.Step) -&gt; \"Expression\":\n  \"\"\"Gets a named child.\"\"\"\n  result = self.get_child(field_name)\n  if result is None:\n    raise KeyError(\"No such field: {}\".format(field_name))\n  return result\n</code></pre> <code></code> get_descendant \u00b6 <pre><code>get_descendant(p: Path) -&gt; Optional[Expression]\n</code></pre> <p>Finds the descendant at the path.</p> Source code in <code>struct2tensor/expression.py</code> <pre><code>def get_descendant(self, p: path.Path) -&gt; Optional[\"Expression\"]:\n  \"\"\"Finds the descendant at the path.\"\"\"\n  result = self\n  for field_name in p.field_list:\n    result = result.get_child(field_name)\n    if result is None:\n      return None\n  return result\n</code></pre> <code></code> get_descendant_or_error \u00b6 <pre><code>get_descendant_or_error(p: Path) -&gt; Expression\n</code></pre> <p>Finds the descendant at the path.</p> Source code in <code>struct2tensor/expression.py</code> <pre><code>def get_descendant_or_error(self, p: path.Path) -&gt; \"Expression\":\n  \"\"\"Finds the descendant at the path.\"\"\"\n  result = self.get_descendant(p)\n  if result is None:\n    raise ValueError(\"Missing path: {} in {}\".format(\n        str(p), self.schema_string(limit=20)))\n  return result\n</code></pre> <code></code> get_known_children \u00b6 <pre><code>get_known_children() -&gt; Mapping[Step, Expression]\n</code></pre> Source code in <code>struct2tensor/expression.py</code> <pre><code>def get_known_children(self) -&gt; Mapping[path.Step, \"Expression\"]:\n  known_field_names = self.known_field_names()\n  result = {}\n  for name in known_field_names:\n    result[name] = self.get_child_or_error(name)\n  return result\n</code></pre> <code></code> get_known_descendants \u00b6 <pre><code>get_known_descendants() -&gt; Mapping[Path, Expression]\n</code></pre> <p>Gets a mapping from known paths to subexpressions.</p> <p>The difference between this and get_descendants in Prensor is that all paths in a Prensor are realized, thus all known. But an Expression's descendants might not all be known at the point this method is called, because an expression may have an infinite number of children.</p> RETURNS DESCRIPTION <code>Mapping[Path, Expression]</code> <p>A mapping from paths (relative to the root of the subexpression) to expressions.</p> Source code in <code>struct2tensor/expression.py</code> <pre><code>def get_known_descendants(self) -&gt; Mapping[path.Path, \"Expression\"]:\n  # Rename get_known_descendants\n  \"\"\"Gets a mapping from known paths to subexpressions.\n\n  The difference between this and get_descendants in Prensor is that\n  all paths in a Prensor are realized, thus all known. But an Expression's\n  descendants might not all be known at the point this method is called,\n  because an expression may have an infinite number of children.\n\n  Returns:\n    A mapping from paths (relative to the root of the subexpression) to\n      expressions.\n  \"\"\"\n  known_subexpressions = {\n      k: v.get_known_descendants()\n      for k, v in self.get_known_children().items()\n  }\n  result = {}\n  for field_name, subexpression in known_subexpressions.items():\n    subexpression_path = path.Path(\n        [field_name], validate_step_format=self.validate_step_format\n    )\n    for p, expr in subexpression.items():\n      result[subexpression_path.concat(p)] = expr\n  result[path.Path([], validate_step_format=self.validate_step_format)] = self\n  return result\n</code></pre> <code></code> get_paths_with_schema \u00b6 <pre><code>get_paths_with_schema() -&gt; List[Path]\n</code></pre> <p>Extract only paths that contain schema information.</p> Source code in <code>struct2tensor/expression.py</code> <pre><code>def get_paths_with_schema(self) -&gt; List[path.Path]:\n  \"\"\"Extract only paths that contain schema information.\"\"\"\n  result = []\n  for name, child in self.get_known_children().items():\n    if child.schema_feature is None:\n      continue\n    result.extend(\n        [\n            path.Path(\n                [name], validate_step_format=self.validate_step_format\n            ).concat(x)\n            for x in child.get_paths_with_schema()\n        ]\n    )\n  # Note: We always take the root path and so will return an empty schema\n  # if there is no schema information on any nodes, including the root.\n  if not result:\n    result.append(\n        path.Path([], validate_step_format=self.validate_step_format)\n    )\n  return result\n</code></pre> <code></code> get_schema \u00b6 <pre><code>get_schema(create_schema_features=True) -&gt; Schema\n</code></pre> <p>Returns a schema for the entire tree.</p> PARAMETER DESCRIPTION <code>create_schema_features</code> <p>If True, schema features are added for all children and a schema entry is created if not available on the child. If False, features are left off of the returned schema if there is no schema_feature on the child.</p> <p> DEFAULT: <code>True</code> </p> Source code in <code>struct2tensor/expression.py</code> <pre><code>def get_schema(self, create_schema_features=True) -&gt; schema_pb2.Schema:\n  \"\"\"Returns a schema for the entire tree.\n\n  Args:\n    create_schema_features: If True, schema features are added for all\n      children and a schema entry is created if not available on the child. If\n      False, features are left off of the returned schema if there is no\n      schema_feature on the child.\n  \"\"\"\n  if not create_schema_features:\n    return self.project(self.get_paths_with_schema()).get_schema()\n  result = schema_pb2.Schema()\n  self._populate_schema_feature_children(result.feature)\n  return result\n</code></pre> <code></code> get_source_expressions \u00b6 <pre><code>get_source_expressions() -&gt; Sequence[Expression]\n</code></pre> <p>Gets the sources of this expression.</p> <p>The node tensors of the source expressions must be sufficient to calculate the node tensor of this expression (see calculate and calculate_value_slowly).</p> RETURNS DESCRIPTION <code>Sequence[Expression]</code> <p>The sources of this expression.</p> Source code in <code>struct2tensor/expression_impl/size.py</code> <pre><code>def get_source_expressions(self) -&gt; Sequence[expression.Expression]:\n  return [self._origin, self._origin_parent]\n</code></pre> <code></code> known_field_names \u00b6 <pre><code>known_field_names() -&gt; FrozenSet[Step]\n</code></pre> <p>Returns known field names of the expression.</p> <p>TODO(martinz): implement set_field and project. Known field names of a parsed proto correspond to the fields declared in the message. Examples of \"unknown\" fields are extensions and explicit casts in an any field. The only way to know if an unknown field \"(foo.bar)\" is present in an expression expr is to call (expr[\"(foo.bar)\"] is not None).</p> <p>Notice that simply accessing a field does not make it \"known\". However, setting a field (or setting a descendant of a field) will make it known.</p> <p>project(...) returns an expression where the known field names are the only field names. In general, if you want to depend upon known_field_names (e.g., if you want to compile a expression), then the best approach is to project() the expression first.</p> RETURNS DESCRIPTION <code>FrozenSet[Step]</code> <p>An immutable set of field names.</p> Source code in <code>struct2tensor/expression.py</code> <pre><code>def known_field_names(self) -&gt; FrozenSet[path.Step]:\n  return frozenset()\n</code></pre> <code></code> map_field_values \u00b6 <pre><code>map_field_values(\n    source_path: CoercableToPath,\n    operator: Callable[[Tensor], Tensor],\n    dtype: DType,\n    new_field_name: Step,\n) -&gt; Expression\n</code></pre> <p>Map a primitive field to create a new primitive field.</p> <p>Note</p> <p>The dtype argument is added since the v1 API.</p> PARAMETER DESCRIPTION <code>source_path</code> <p>the origin path.</p> <p> TYPE: <code>CoercableToPath</code> </p> <code>operator</code> <p>an element-wise operator that takes a 1-dimensional vector.</p> <p> TYPE: <code>Callable[[Tensor], Tensor]</code> </p> <code>dtype</code> <p>the type of the output.</p> <p> TYPE: <code>DType</code> </p> <code>new_field_name</code> <p>the name of a new sibling of source_path.</p> <p> TYPE: <code>Step</code> </p> RETURNS DESCRIPTION <code>Expression</code> <p>the resulting root expression.</p> Source code in <code>struct2tensor/expression.py</code> <pre><code>def map_field_values(self, source_path: CoercableToPath,\n                     operator: Callable[[tf.Tensor], tf.Tensor],\n                     dtype: tf.DType,\n                     new_field_name: path.Step) -&gt; \"Expression\":\n  \"\"\"Map a primitive field to create a new primitive field.\n\n  !!! Note\n      The dtype argument is added since the v1 API.\n\n  Args:\n    source_path: the origin path.\n    operator: an element-wise operator that takes a 1-dimensional vector.\n    dtype: the type of the output.\n    new_field_name: the name of a new sibling of source_path.\n\n  Returns:\n    the resulting root expression.\n  \"\"\"\n  return map_values.map_values(self, path.create_path(source_path), operator,\n                               dtype, new_field_name)\n</code></pre> <code></code> map_ragged_tensors \u00b6 <pre><code>map_ragged_tensors(\n    parent_path: CoercableToPath,\n    source_fields: Sequence[Step],\n    operator: Callable[..., SparseTensor],\n    is_repeated: bool,\n    dtype: DType,\n    new_field_name: Step,\n) -&gt; Expression\n</code></pre> <p>Maps a set of primitive fields of a message to a new field.</p> <p>Unlike map_field_values, this operation allows you to some degree reshape the field. For instance, you can take two optional fields and create a repeated field, or perform a reduce_sum on the last dimension of a repeated field and create an optional field. The key constraint is that the operator must return a sparse tensor of the correct dimension: i.e., a 2D sparse tensor if is_repeated is true, or a 1D sparse tensor if is_repeated is false. Moreover, the first dimension of the sparse tensor must be equal to the first dimension of the input tensor.</p> PARAMETER DESCRIPTION <code>parent_path</code> <p>the parent of the input and output fields.</p> <p> TYPE: <code>CoercableToPath</code> </p> <code>source_fields</code> <p>the nonempty list of names of the source fields.</p> <p> TYPE: <code>Sequence[Step]</code> </p> <code>operator</code> <p>an operator that takes len(source_fields) sparse tensors and returns a sparse tensor of the appropriate shape.</p> <p> TYPE: <code>Callable[..., SparseTensor]</code> </p> <code>is_repeated</code> <p>whether the output is repeated.</p> <p> TYPE: <code>bool</code> </p> <code>dtype</code> <p>the dtype of the result.</p> <p> TYPE: <code>DType</code> </p> <code>new_field_name</code> <p>the name of the resulting field.</p> <p> TYPE: <code>Step</code> </p> RETURNS DESCRIPTION <code>Expression</code> <p>A new query.</p> Source code in <code>struct2tensor/expression.py</code> <pre><code>def map_ragged_tensors(self, parent_path: CoercableToPath,\n                       source_fields: Sequence[path.Step],\n                       operator: Callable[..., tf.SparseTensor],\n                       is_repeated: bool, dtype: tf.DType,\n                       new_field_name: path.Step) -&gt; \"Expression\":\n  \"\"\"Maps a set of primitive fields of a message to a new field.\n\n  Unlike map_field_values, this operation allows you to some degree reshape\n  the field. For instance, you can take two optional fields and create a\n  repeated field, or perform a reduce_sum on the last dimension of a repeated\n  field and create an optional field. The key constraint is that the operator\n  must return a sparse tensor of the correct dimension: i.e., a\n  2D sparse tensor if is_repeated is true, or a 1D sparse tensor if\n  is_repeated is false. Moreover, the first dimension of the sparse tensor\n  must be equal to the first dimension of the input tensor.\n\n  Args:\n    parent_path: the parent of the input and output fields.\n    source_fields: the nonempty list of names of the source fields.\n    operator: an operator that takes len(source_fields) sparse tensors and\n      returns a sparse tensor of the appropriate shape.\n    is_repeated: whether the output is repeated.\n    dtype: the dtype of the result.\n    new_field_name: the name of the resulting field.\n\n  Returns:\n    A new query.\n  \"\"\"\n  return map_prensor.map_ragged_tensor(\n      self,\n      path.create_path(parent_path),\n      [\n          path.Path([f], validate_step_format=self.validate_step_format)\n          for f in source_fields\n      ],\n      operator,\n      is_repeated,\n      dtype,\n      new_field_name,\n  )\n</code></pre> <code></code> map_sparse_tensors \u00b6 <pre><code>map_sparse_tensors(\n    parent_path: CoercableToPath,\n    source_fields: Sequence[Step],\n    operator: Callable[..., SparseTensor],\n    is_repeated: bool,\n    dtype: DType,\n    new_field_name: Step,\n) -&gt; Expression\n</code></pre> <p>Maps a set of primitive fields of a message to a new field.</p> <p>Unlike map_field_values, this operation allows you to some degree reshape the field. For instance, you can take two optional fields and create a repeated field, or perform a reduce_sum on the last dimension of a repeated field and create an optional field. The key constraint is that the operator must return a sparse tensor of the correct dimension: i.e., a 2D sparse tensor if is_repeated is true, or a 1D sparse tensor if is_repeated is false. Moreover, the first dimension of the sparse tensor must be equal to the first dimension of the input tensor.</p> PARAMETER DESCRIPTION <code>parent_path</code> <p>the parent of the input and output fields.</p> <p> TYPE: <code>CoercableToPath</code> </p> <code>source_fields</code> <p>the nonempty list of names of the source fields.</p> <p> TYPE: <code>Sequence[Step]</code> </p> <code>operator</code> <p>an operator that takes len(source_fields) sparse tensors and returns a sparse tensor of the appropriate shape.</p> <p> TYPE: <code>Callable[..., SparseTensor]</code> </p> <code>is_repeated</code> <p>whether the output is repeated.</p> <p> TYPE: <code>bool</code> </p> <code>dtype</code> <p>the dtype of the result.</p> <p> TYPE: <code>DType</code> </p> <code>new_field_name</code> <p>the name of the resulting field.</p> <p> TYPE: <code>Step</code> </p> RETURNS DESCRIPTION <code>Expression</code> <p>A new query.</p> Source code in <code>struct2tensor/expression.py</code> <pre><code>def map_sparse_tensors(self, parent_path: CoercableToPath,\n                       source_fields: Sequence[path.Step],\n                       operator: Callable[..., tf.SparseTensor],\n                       is_repeated: bool, dtype: tf.DType,\n                       new_field_name: path.Step) -&gt; \"Expression\":\n  \"\"\"Maps a set of primitive fields of a message to a new field.\n\n  Unlike map_field_values, this operation allows you to some degree reshape\n  the field. For instance, you can take two optional fields and create a\n  repeated field, or perform a reduce_sum on the last dimension of a repeated\n  field and create an optional field. The key constraint is that the operator\n  must return a sparse tensor of the correct dimension: i.e., a\n  2D sparse tensor if is_repeated is true, or a 1D sparse tensor if\n  is_repeated is false. Moreover, the first dimension of the sparse tensor\n  must be equal to the first dimension of the input tensor.\n\n  Args:\n    parent_path: the parent of the input and output fields.\n    source_fields: the nonempty list of names of the source fields.\n    operator: an operator that takes len(source_fields) sparse tensors and\n      returns a sparse tensor of the appropriate shape.\n    is_repeated: whether the output is repeated.\n    dtype: the dtype of the result.\n    new_field_name: the name of the resulting field.\n\n  Returns:\n    A new query.\n  \"\"\"\n  return map_prensor.map_sparse_tensor(\n      self,\n      path.create_path(parent_path),\n      [\n          path.Path([f], validate_step_format=self.validate_step_format)\n          for f in source_fields\n      ],\n      operator,\n      is_repeated,\n      dtype,\n      new_field_name,\n  )\n</code></pre> <code></code> project \u00b6 <pre><code>project(path_list: Sequence[CoercableToPath]) -&gt; Expression\n</code></pre> <p>Constrains the paths to those listed.</p> Source code in <code>struct2tensor/expression.py</code> <pre><code>def project(self, path_list: Sequence[CoercableToPath]) -&gt; \"Expression\":\n  \"\"\"Constrains the paths to those listed.\"\"\"\n  return project.project(self, [path.create_path(x) for x in path_list])\n</code></pre> <code></code> promote \u00b6 <pre><code>promote(source_path: CoercableToPath, new_field_name: Step)\n</code></pre> <p>Promotes source_path to be a field new_field_name in its grandparent.</p> Source code in <code>struct2tensor/expression.py</code> <pre><code>def promote(self, source_path: CoercableToPath, new_field_name: path.Step):\n  \"\"\"Promotes source_path to be a field new_field_name in its grandparent.\"\"\"\n  return promote.promote(self, path.create_path(source_path), new_field_name)\n</code></pre> <code></code> promote_and_broadcast \u00b6 <pre><code>promote_and_broadcast(\n    path_dictionary: Mapping[Step, CoercableToPath],\n    dest_path_parent: CoercableToPath,\n) -&gt; Expression\n</code></pre> Source code in <code>struct2tensor/expression.py</code> <pre><code>def promote_and_broadcast(\n    self, path_dictionary: Mapping[path.Step, CoercableToPath],\n    dest_path_parent: CoercableToPath) -&gt; \"Expression\":\n  return promote_and_broadcast.promote_and_broadcast(\n      self, {k: path.create_path(v) for k, v in path_dictionary.items()},\n      path.create_path(dest_path_parent))\n</code></pre> <code></code> reroot \u00b6 <pre><code>reroot(new_root: CoercableToPath) -&gt; Expression\n</code></pre> <p>Returns a new list of protocol buffers available at new_root.</p> Source code in <code>struct2tensor/expression.py</code> <pre><code>def reroot(self, new_root: CoercableToPath) -&gt; \"Expression\":\n  \"\"\"Returns a new list of protocol buffers available at new_root.\"\"\"\n  return reroot.reroot(self, path.create_path(new_root))\n</code></pre> <code></code> schema_string \u00b6 <pre><code>schema_string(limit: Optional[int] = None) -&gt; str\n</code></pre> <p>Returns a schema for the expression.</p> <p>For examle, </p><pre><code>repeated root:\n  optional int32 foo\n  optional bar:\n    optional string baz\n  optional int64 bak\n</code></pre> <p>Note that unknown fields and subexpressions are not displayed.</p> PARAMETER DESCRIPTION <code>limit</code> <p>if present, limit the recursion.</p> <p> TYPE: <code>Optional[int]</code> DEFAULT: <code>None</code> </p> RETURNS DESCRIPTION <code>str</code> <p>A string, describing (a part of) the schema.</p> Source code in <code>struct2tensor/expression.py</code> <pre><code>def schema_string(self, limit: Optional[int] = None) -&gt; str:\n  \"\"\"Returns a schema for the expression.\n\n  For examle,\n  ```\n  repeated root:\n    optional int32 foo\n    optional bar:\n      optional string baz\n    optional int64 bak\n  ```\n\n  Note that unknown fields and subexpressions are not displayed.\n\n  Args:\n    limit: if present, limit the recursion.\n\n  Returns:\n    A string, describing (a part of) the schema.\n  \"\"\"\n  return \"\\n\".join(self._schema_string_helper(\"root\", limit))\n</code></pre> <code></code> slice \u00b6 <pre><code>slice(\n    source_path: CoercableToPath,\n    new_field_name: Step,\n    begin: Optional[IndexValue] = None,\n    end: Optional[IndexValue] = None,\n) -&gt; Expression\n</code></pre> <p>Creates a slice copy of source_path at new_field_path.</p> <p>Note that if begin or end is negative, it is considered relative to the size of the array. e.g., slice(...,begin=-1) will get the last element of every array.</p> PARAMETER DESCRIPTION <code>source_path</code> <p>the source of the slice.</p> <p> TYPE: <code>CoercableToPath</code> </p> <code>new_field_name</code> <p>the new field that is generated.</p> <p> TYPE: <code>Step</code> </p> <code>begin</code> <p>the beginning of the slice (inclusive).</p> <p> TYPE: <code>Optional[IndexValue]</code> DEFAULT: <code>None</code> </p> <code>end</code> <p>the end of the slice (exclusive).</p> <p> TYPE: <code>Optional[IndexValue]</code> DEFAULT: <code>None</code> </p> RETURNS DESCRIPTION <code>Expression</code> <p>An Expression object representing the result of the operation.</p> Source code in <code>struct2tensor/expression.py</code> <pre><code>def slice(self,\n          source_path: CoercableToPath,\n          new_field_name: path.Step,\n          begin: Optional[IndexValue] = None,\n          end: Optional[IndexValue] = None) -&gt; \"Expression\":\n  \"\"\"Creates a slice copy of source_path at new_field_path.\n\n  Note that if begin or end is negative, it is considered relative to\n  the size of the array. e.g., slice(...,begin=-1) will get the last\n  element of every array.\n\n  Args:\n    source_path: the source of the slice.\n    new_field_name: the new field that is generated.\n    begin: the beginning of the slice (inclusive).\n    end: the end of the slice (exclusive).\n\n  Returns:\n    An Expression object representing the result of the operation.\n  \"\"\"\n  return slice_expression.slice_expression(self,\n                                           path.create_path(source_path),\n                                           new_field_name, begin, end)\n</code></pre> <code></code> truncate \u00b6 <pre><code>truncate(\n    source_path: CoercableToPath,\n    limit: Union[int, Tensor],\n    new_field_name: Step,\n) -&gt; Expression\n</code></pre> <p>Creates a truncated copy of source_path at new_field_path.</p> Source code in <code>struct2tensor/expression.py</code> <pre><code>def truncate(self, source_path: CoercableToPath, limit: Union[int, tf.Tensor],\n             new_field_name: path.Step) -&gt; \"Expression\":\n  \"\"\"Creates a truncated copy of source_path at new_field_path.\"\"\"\n  return self.slice(source_path, new_field_name, end=limit)\n</code></pre>"},{"location":"api_docs/python/expression_impl/expression_impl/#struct2tensor.expression_impl.size-functions","title":"Functions","text":""},{"location":"api_docs/python/expression_impl/expression_impl/#struct2tensor.expression_impl.size.has","title":"has","text":"<pre><code>has(\n    root: Expression,\n    source_path: Path,\n    new_field_name: Step,\n) -&gt; Expression\n</code></pre> <p>Get the has of a field as a new sibling field.</p> PARAMETER DESCRIPTION <code>root</code> <p>the original expression.</p> <p> TYPE: <code>Expression</code> </p> <code>source_path</code> <p>the source path to measure. Cannot be root.</p> <p> TYPE: <code>Path</code> </p> <code>new_field_name</code> <p>the name of the sibling field.</p> <p> TYPE: <code>Step</code> </p> RETURNS DESCRIPTION <code>Expression</code> <p>The new expression.</p> Source code in <code>struct2tensor/expression_impl/size.py</code> <pre><code>def has(root: expression.Expression, source_path: path.Path,\n        new_field_name: path.Step) -&gt; expression.Expression:\n  \"\"\"Get the has of a field as a new sibling field.\n\n  Args:\n    root: the original expression.\n    source_path: the source path to measure. Cannot be root.\n    new_field_name: the name of the sibling field.\n\n  Returns:\n    The new expression.\n  \"\"\"\n  new_root, size_p = size_anonymous(root, source_path)\n  # TODO(martinz): consider using copy_over to \"remove\" the size field\n  # from the result.\n  return map_values.map_values(\n      new_root, size_p, lambda x: tf.greater(x, tf.constant(0, dtype=tf.int64)),\n      tf.bool, new_field_name)\n</code></pre>"},{"location":"api_docs/python/expression_impl/expression_impl/#struct2tensor.expression_impl.size.size","title":"size","text":"<pre><code>size(\n    root: Expression,\n    source_path: Path,\n    new_field_name: Step,\n) -&gt; Expression\n</code></pre> <p>Get the size of a field as a new sibling field.</p> PARAMETER DESCRIPTION <code>root</code> <p>the original expression.</p> <p> TYPE: <code>Expression</code> </p> <code>source_path</code> <p>the source path to measure. Cannot be root.</p> <p> TYPE: <code>Path</code> </p> <code>new_field_name</code> <p>the name of the sibling field.</p> <p> TYPE: <code>Step</code> </p> RETURNS DESCRIPTION <code>Expression</code> <p>The new expression.</p> Source code in <code>struct2tensor/expression_impl/size.py</code> <pre><code>def size(root: expression.Expression, source_path: path.Path,\n         new_field_name: path.Step) -&gt; expression.Expression:\n  \"\"\"Get the size of a field as a new sibling field.\n\n  Args:\n    root: the original expression.\n    source_path: the source path to measure. Cannot be root.\n    new_field_name: the name of the sibling field.\n\n  Returns:\n    The new expression.\n  \"\"\"\n  return _size_impl(root, source_path, new_field_name)[0]\n</code></pre>"},{"location":"api_docs/python/expression_impl/expression_impl/#struct2tensor.expression_impl.size.size_anonymous","title":"size_anonymous","text":"<pre><code>size_anonymous(\n    root: Expression, source_path: Path\n) -&gt; Tuple[Expression, Path]\n</code></pre> <p>Calculate the size of a field, and store it as an anonymous sibling.</p> PARAMETER DESCRIPTION <code>root</code> <p>the original expression.</p> <p> TYPE: <code>Expression</code> </p> <code>source_path</code> <p>the source path to measure. Cannot be root.</p> <p> TYPE: <code>Path</code> </p> RETURNS DESCRIPTION <code>Tuple[Expression, Path]</code> <p>The new expression and the new field as a pair.</p> Source code in <code>struct2tensor/expression_impl/size.py</code> <pre><code>def size_anonymous(root: expression.Expression, source_path: path.Path\n                  ) -&gt; Tuple[expression.Expression, path.Path]:\n  \"\"\"Calculate the size of a field, and store it as an anonymous sibling.\n\n  Args:\n    root: the original expression.\n    source_path: the source path to measure. Cannot be root.\n\n  Returns:\n    The new expression and the new field as a pair.\n  \"\"\"\n  return _size_impl(root, source_path, path.get_anonymous_field())\n</code></pre>"},{"location":"api_docs/python/expression_impl/expression_impl/#struct2tensor.expression_impl.size-modules","title":"Modules","text":""},{"location":"api_docs/python/expression_impl/expression_impl/#struct2tensor.expression_impl.slice_expression","title":"slice_expression","text":"<p>Implementation of slice.</p> <p>The slice operation is meant to replicate the slicing of a list in python.</p> <p>Slicing a list in python is done by specifying a beginning and ending. The resulting list consists of all elements in the range.</p> <p>For example:</p> <pre><code>&gt;&gt;&gt; x = ['a', 'b', 'c', 'd', 'e', 'f', 'g']\n&gt;&gt;&gt; print(x[2:5]) # all elements between index 2 inclusive and index 5 exclusive\n['c', 'd', 'e']\n&gt;&gt;&gt; print(x[2:]) # all elements between index 2 and the end.\n['c', 'd', 'e', 'f', 'g']\n&gt;&gt;&gt; print(x[:4]) # all elements between the beginning and index 4 (exclusive).\n['a', 'b', 'c', 'd']\n&gt;&gt;&gt; print(x[-3:-1]) # all elements starting three from the end.\n&gt;&gt;&gt;                 # until one from the end (exclusive).\n['e', 'f']\n&gt;&gt;&gt; print(x[-3:6]) # all elements starting three from the end\n                   # until index 6 exclusive.\n['e', 'f', 'g']\n</code></pre> <p>TODO(martinz): there is a third argument to slice, which allows one to step over the elements (e.g. x[2:6:2]=['c', 'e'], giving you every other element. This is not implemented.</p> <p>A prensor can be considered to be interleaved lists and dictionaries. E.g.:</p> <pre><code>my_expression = [{\n  \"foo\":[\n    {\"bar\":[\n      {\"baz\":[\"a\",\"b\",\"c\", \"d\"]},\n      {\"baz\":[\"d\",\"e\",\"f\"]}\n      ]\n    },\n    {\"bar\":[\n      {\"baz\":[\"g\",\"h\",\"i\"]},\n      {\"baz\":[\"j\",\"k\",\"l\", ]}\n      {\"baz\":[\"m\"]}\n    ]\n    }]\n}]\n</code></pre> <pre><code>result_1 = slice_expression.slice_expression(\n  my_expression, \"foo.bar\", \"new_bar\",begin=1, end=3)\n\nresult_1 = [{\n  \"foo\":[\n    {\"bar\":[\n      {\"baz\":[\"a\",\"b\",\"c\", \"d\"]},\n      {\"baz\":[\"d\",\"e\",\"f\"]}\n      ],\n     \"new_bar\":[\n      {\"baz\":[\"d\",\"e\",\"f\"]}\n      ]\n    },\n    {\"bar\":[\n      {\"baz\":[\"g\",\"h\",\"i\"]},\n      {\"baz\":[\"j\",\"k\",\"l\", ]}\n      {\"baz\":[\"m\", ]}\n     ],\n    \"new_bar\":[\n      {\"baz\":[\"j\",\"k\",\"l\", ]}\n      {\"baz\":[\"m\", ]}\n    ]\n    }]\n}]\n</code></pre> <pre><code>result_2 = slice_expression.slice_expression(\n  my_expression, \"foo.bar.baz\", \"new_baz\",begin=1, end=3)\n\nresult_2 = [{\n  \"foo\":[\n    {\"bar\":[\n      {\"baz\":[\"a\",\"b\",\"c\", \"d\"],\n       \"new_baz\":[\"b\",\"c\"],\n      },\n      {\"baz\":[\"d\",\"e\",\"f\"], \"new_baz\":[\"e\",\"f\"]}\n      ]\n    },\n    {\"bar\":[\n      {\"baz\":[\"g\",\"h\",\"i\"], \"new_baz\":[\"h\",\"i\"]},\n      {\"baz\":[\"j\",\"k\",\"l\"], \"new_baz\":[\"k\",\"l\"]},\n      {\"baz\":[\"m\", ]}\n      ]\n    }]\n}]\n</code></pre> FUNCTION DESCRIPTION <code>slice_expression</code> <p>Creates a new subtree with a sliced expression.</p> ATTRIBUTE DESCRIPTION <code>IndexValue</code> <p> </p>"},{"location":"api_docs/python/expression_impl/expression_impl/#struct2tensor.expression_impl.slice_expression-attributes","title":"Attributes","text":""},{"location":"api_docs/python/expression_impl/expression_impl/#struct2tensor.expression_impl.slice_expression.IndexValue","title":"IndexValue  <code>module-attribute</code>","text":"<pre><code>IndexValue = IndexValue\n</code></pre>"},{"location":"api_docs/python/expression_impl/expression_impl/#struct2tensor.expression_impl.slice_expression-functions","title":"Functions","text":""},{"location":"api_docs/python/expression_impl/expression_impl/#struct2tensor.expression_impl.slice_expression.slice_expression","title":"slice_expression","text":"<pre><code>slice_expression(\n    expr: Expression,\n    p: Path,\n    new_field_name: Step,\n    begin: Optional[IndexValue],\n    end: Optional[IndexValue],\n) -&gt; Expression\n</code></pre> <p>Creates a new subtree with a sliced expression.</p> <p>This follows the pattern of python slice() method. See module-level comments for examples.</p> PARAMETER DESCRIPTION <code>expr</code> <p>the original root expression</p> <p> TYPE: <code>Expression</code> </p> <code>p</code> <p>the path to the source to be sliced.</p> <p> TYPE: <code>Path</code> </p> <code>new_field_name</code> <p>the name of the new subtree.</p> <p> TYPE: <code>Step</code> </p> <code>begin</code> <p>beginning index</p> <p> TYPE: <code>Optional[IndexValue]</code> </p> <code>end</code> <p>end index.</p> <p> TYPE: <code>Optional[IndexValue]</code> </p> RETURNS DESCRIPTION <code>Expression</code> <p>A new root expression.</p> Source code in <code>struct2tensor/expression_impl/slice_expression.py</code> <pre><code>def slice_expression(expr: expression.Expression, p: path.Path,\n                     new_field_name: path.Step, begin: Optional[IndexValue],\n                     end: Optional[IndexValue]) -&gt; expression.Expression:\n  \"\"\"Creates a new subtree with a sliced expression.\n\n  This follows the pattern of python slice() method.\n  See module-level comments for examples.\n\n  Args:\n    expr: the original root expression\n    p: the path to the source to be sliced.\n    new_field_name: the name of the new subtree.\n    begin: beginning index\n    end: end index.\n\n  Returns:\n    A new root expression.\n  \"\"\"\n  work_expr, mask_anonymous_path = _get_slice_mask(expr, p, begin, end)\n  work_expr = filter_expression.filter_by_sibling(\n      work_expr, p, mask_anonymous_path.field_list[-1], new_field_name)\n  new_path = p.get_parent().get_child(new_field_name)\n  # We created a lot of anonymous fields and intermediate expressions. Just grab\n  # the final result (and its children).\n  return expression_add.add_to(expr, {new_path: work_expr})\n</code></pre>"},{"location":"api_docs/python/expression_impl/expression_impl/#struct2tensor.expression_impl.slice_expression-modules","title":"Modules","text":""},{"location":"api_docs/python/s2t/","title":"Module: s2t","text":"View source on GitHub      <p>Import core names for struct2tensor.</p>"},{"location":"api_docs/python/s2t/#classes","title":"Classes","text":"<p><code>class ChildNodeTensor</code>: The value of an intermediate node.</p> <p><code>class Expression</code>: An expression represents the calculation of a prensor object.</p> <p><code>class LeafNodeTensor</code>: The value of a leaf node.</p> <p><code>class Path</code>: A representation of a path in the expression.</p> <p><code>class Prensor</code>: A expression of NodeTensor objects.</p> <p><code>class RootNodeTensor</code>: The value of the root.</p>"},{"location":"api_docs/python/s2t/#functions","title":"Functions","text":"<p><code>calculate_prensors(...)</code>: Gets the prensor value of the expressions.</p> <p><code>calculate_prensors_with_graph(...)</code>: Gets the prensor value of the expressions and the graph used.</p> <p><code>calculate_prensors_with_source_paths(...)</code>: Returns a list of prensor trees, and proto summaries.</p> <p><code>create_expression_from_file_descriptor_set(...)</code>: Create an expression from a 1D tensor of serialized protos.</p> <p><code>create_expression_from_prensor(...)</code>: Gets an expression representing the prensor.</p> <p><code>create_expression_from_proto(...)</code>: Create an expression from a 1D tensor of serialized protos.</p> <p><code>create_path(...)</code>: Create a path from an object.</p> <p><code>create_prensor_from_descendant_nodes(...)</code>: Create a prensor from a map of paths to NodeTensor.</p> <p><code>create_prensor_from_root_and_children(...)</code></p> <p><code>get_default_options(...)</code>: Get the default options.</p> <p><code>get_options_with_minimal_checks(...)</code>: Options for calculation with minimal runtime checks.</p> <p><code>get_ragged_tensor(...)</code>: Get a ragged tensor for a path. (deprecated)</p> <p><code>get_ragged_tensors(...)</code>: Gets ragged tensors for all the leaves of the prensor expression. (deprecated)</p> <p><code>get_sparse_tensor(...)</code>: Gets a sparse tensor for path p. (deprecated)</p> <p><code>get_sparse_tensors(...)</code>: Gets sparse tensors for all the leaves of the prensor expression. (deprecated)</p>"},{"location":"api_docs/python/s2t/#type-aliases","title":"Type Aliases","text":"<p><code>NodeTensor</code></p> <p><code>Step</code></p>"},{"location":"api_docs/python/s2t/s2t/","title":"<code>s2t</code>","text":""},{"location":"api_docs/python/s2t/s2t/#struct2tensor.struct2tensor","title":"struct2tensor.struct2tensor","text":"<p>Import core names for struct2tensor.</p> CLASS DESCRIPTION <code>ChildNodeTensor</code> <p>The value of an intermediate node.</p> <code>Expression</code> <p>An expression represents the calculation of a prensor object.</p> <code>LeafNodeTensor</code> <p>The value of a leaf node.</p> <code>Path</code> <p>A representation of a path in the expression.</p> <code>Prensor</code> <p>A expression of NodeTensor objects.</p> <code>RootNodeTensor</code> <p>The value of the root.</p> FUNCTION DESCRIPTION <code>calculate_prensors</code> <p>Gets the prensor value of the expressions.</p> <code>calculate_prensors_with_graph</code> <p>Gets the prensor value of the expressions and the graph used.</p> <code>calculate_prensors_with_source_paths</code> <p>Returns a list of prensor trees, and proto summaries.</p> <code>create_expression_from_file_descriptor_set</code> <p>Create an expression from a 1D tensor of serialized protos.</p> <code>create_expression_from_prensor</code> <p>Gets an expression representing the prensor.</p> <code>create_expression_from_proto</code> <p>Create an expression from a 1D tensor of serialized protos.</p> <code>create_path</code> <p>Create a path from an object.</p> <code>create_prensor_from_descendant_nodes</code> <p>Create a prensor from a map of paths to NodeTensor.</p> <code>create_prensor_from_root_and_children</code> <code>get_default_options</code> <p>Get the default options.</p> <code>get_options_with_minimal_checks</code> <p>Options for calculation with minimal runtime checks.</p> <code>get_ragged_tensor</code> <p>Get a ragged tensor for a path.</p> <code>get_ragged_tensors</code> <p>Gets ragged tensors for all the leaves of the prensor expression.</p> <code>get_sparse_tensor</code> <p>Gets a sparse tensor for path p.</p> <code>get_sparse_tensors</code> <p>Gets sparse tensors for all the leaves of the prensor expression.</p> ATTRIBUTE DESCRIPTION <code>NodeTensor</code> <p> </p> <code>Step</code> <p> </p>"},{"location":"api_docs/python/s2t/s2t/#struct2tensor.struct2tensor-attributes","title":"Attributes","text":""},{"location":"api_docs/python/s2t/s2t/#struct2tensor.struct2tensor.NodeTensor","title":"NodeTensor  <code>module-attribute</code>","text":"<pre><code>NodeTensor = Union[\n    LeafNodeTensor, ChildNodeTensor, RootNodeTensor\n]\n</code></pre>"},{"location":"api_docs/python/s2t/s2t/#struct2tensor.struct2tensor.Step","title":"Step  <code>module-attribute</code>","text":"<pre><code>Step = Union[AnonymousId, str]\n</code></pre>"},{"location":"api_docs/python/s2t/s2t/#struct2tensor.struct2tensor-classes","title":"Classes","text":""},{"location":"api_docs/python/s2t/s2t/#struct2tensor.struct2tensor.ChildNodeTensor","title":"ChildNodeTensor","text":"<pre><code>ChildNodeTensor(\n    parent_index: Tensor,\n    is_repeated: bool,\n    index_to_value: Optional[Tensor] = None,\n)\n</code></pre> <p>               Bases: <code>object</code></p> <p>The value of an intermediate node.</p> <p>Creates a child node.</p> PARAMETER DESCRIPTION <code>parent_index</code> <p>a 1-D int64 tensor where parent_index[i] represents the parent index of the ith child.</p> <p> TYPE: <code>Tensor</code> </p> <code>is_repeated</code> <p>a bool indicating if there can be more than one child per parent.</p> <p> TYPE: <code>bool</code> </p> <code>index_to_value</code> <p>a 1-D int64 tensor where index_to_value[i] represents the <code>value</code> of the ith child. Where <code>value</code> is a subtree.</p> <p> TYPE: <code>Optional[Tensor]</code> DEFAULT: <code>None</code> </p> METHOD DESCRIPTION <code>get_positional_index</code> <p>Gets the positional index for this ChildNodeTensor.</p> ATTRIBUTE DESCRIPTION <code>index_to_value</code> <p> </p> <code>is_repeated</code> <p> </p> <code>parent_index</code> <p> </p> <code>size</code> <p>Returns the size, as if this was the root prensor.</p> <p> </p> Source code in <code>struct2tensor/prensor.py</code> <pre><code>def __init__(self,\n             parent_index: tf.Tensor,\n             is_repeated: bool,\n             index_to_value: Optional[tf.Tensor] = None):\n  \"\"\"Creates a child node.\n\n  Args:\n    parent_index: a 1-D int64 tensor where parent_index[i] represents the\n      parent index of the ith child.\n    is_repeated: a bool indicating if there can be more than one child per\n      parent.\n    index_to_value: a 1-D int64 tensor where index_to_value[i] represents the\n      `value` of the ith child. Where `value` is a subtree.\n  \"\"\"\n  self._parent_index = parent_index\n  self._is_repeated = is_repeated\n  self._index_to_value = index_to_value\n</code></pre>"},{"location":"api_docs/python/s2t/s2t/#struct2tensor.struct2tensor.ChildNodeTensor-attributes","title":"Attributes","text":""},{"location":"api_docs/python/s2t/s2t/#struct2tensor.struct2tensor.ChildNodeTensor.index_to_value","title":"index_to_value  <code>property</code>","text":"<pre><code>index_to_value\n</code></pre>"},{"location":"api_docs/python/s2t/s2t/#struct2tensor.struct2tensor.ChildNodeTensor.is_repeated","title":"is_repeated  <code>property</code>","text":"<pre><code>is_repeated\n</code></pre>"},{"location":"api_docs/python/s2t/s2t/#struct2tensor.struct2tensor.ChildNodeTensor.parent_index","title":"parent_index  <code>property</code>","text":"<pre><code>parent_index\n</code></pre>"},{"location":"api_docs/python/s2t/s2t/#struct2tensor.struct2tensor.ChildNodeTensor.size","title":"size  <code>property</code>","text":"<pre><code>size\n</code></pre> <p>Returns the size, as if this was the root prensor.</p> RETURNS DESCRIPTION <p>A scalar int64 tensor.</p>"},{"location":"api_docs/python/s2t/s2t/#struct2tensor.struct2tensor.ChildNodeTensor-functions","title":"Functions","text":""},{"location":"api_docs/python/s2t/s2t/#struct2tensor.struct2tensor.ChildNodeTensor.get_positional_index","title":"get_positional_index","text":"<pre><code>get_positional_index() -&gt; Tensor\n</code></pre> <p>Gets the positional index for this ChildNodeTensor.</p> <p>The positional index tells us which index of the parent an element is.</p> <p>For example, with the following parent indices: <code>[0, 0, 2]</code> we would have positional index:</p> <pre><code>[\n  0, # The 0th element of the 0th parent.\n  1, # The 1st element of the 0th parent.\n  0  # The 0th element of the 2nd parent.\n]\n</code></pre> <p>For more information, view ops/run_length_before_op.cc</p> <p>This is the same for Leaf NodeTensors.</p> RETURNS DESCRIPTION <code>Tensor</code> <p>A tensor of positional indices.</p> Source code in <code>struct2tensor/prensor.py</code> <pre><code>def get_positional_index(self) -&gt; tf.Tensor:\n  \"\"\"Gets the positional index for this ChildNodeTensor.\n\n  The positional index tells us which index of the parent an element is.\n\n  For example, with the following parent indices: `[0, 0, 2]`\n  we would have positional index:\n\n  ```python\n  [\n    0, # The 0th element of the 0th parent.\n    1, # The 1st element of the 0th parent.\n    0  # The 0th element of the 2nd parent.\n  ]\n  ```\n\n  For more information, view ops/run_length_before_op.cc\n\n  This is the same for Leaf NodeTensors.\n\n  Returns:\n    A tensor of positional indices.\n  \"\"\"\n  return struct2tensor_ops.run_length_before(self.parent_index)\n</code></pre>"},{"location":"api_docs/python/s2t/s2t/#struct2tensor.struct2tensor.Expression","title":"Expression","text":"<pre><code>Expression(\n    is_repeated: bool,\n    my_type: Optional[DType],\n    schema_feature: Optional[Feature] = None,\n    validate_step_format: bool = True,\n)\n</code></pre> <p>               Bases: <code>object</code></p> <p>An expression represents the calculation of a prensor object.</p> <p>Initialize an expression.</p> PARAMETER DESCRIPTION <code>is_repeated</code> <p>if the expression is repeated.</p> <p> TYPE: <code>bool</code> </p> <code>my_type</code> <p>the DType of a field, or None for an internal node.</p> <p> TYPE: <code>Optional[DType]</code> </p> <code>schema_feature</code> <p>the local schema (StructDomain information should not be present).</p> <p> TYPE: <code>Optional[Feature]</code> DEFAULT: <code>None</code> </p> <code>validate_step_format</code> <p>If True, validates that steps do not have any characters that could be ambiguously understood as structure delimiters (e.g. \".\"). If False, such characters are allowed and the client is responsible to ensure to not rely on any auto-coercion of strings to paths.</p> <p> TYPE: <code>bool</code> DEFAULT: <code>True</code> </p> METHOD DESCRIPTION <code>apply</code> <code>apply_schema</code> <code>broadcast</code> <p>Broadcasts the existing field at source_path to the sibling_field.</p> <code>calculate</code> <p>Calculates the node tensor of the expression.</p> <code>calculation_equal</code> <p>self.calculate is equal to another expression.calculate.</p> <code>calculation_is_identity</code> <p>True iff the self.calculate is the identity.</p> <code>cogroup_by_index</code> <p>Creates a cogroup of left_name and right_name at new_field_name.</p> <code>create_has_field</code> <p>Creates a field that is the presence of the source path.</p> <code>create_proto_index</code> <p>Creates a proto index field as a direct child of the current root.</p> <code>create_size_field</code> <p>Creates a field that is the size of the source path.</p> <code>get_child</code> <p>Gets a named child.</p> <code>get_child_or_error</code> <p>Gets a named child.</p> <code>get_descendant</code> <p>Finds the descendant at the path.</p> <code>get_descendant_or_error</code> <p>Finds the descendant at the path.</p> <code>get_known_children</code> <code>get_known_descendants</code> <p>Gets a mapping from known paths to subexpressions.</p> <code>get_paths_with_schema</code> <p>Extract only paths that contain schema information.</p> <code>get_schema</code> <p>Returns a schema for the entire tree.</p> <code>get_source_expressions</code> <p>Gets the sources of this expression.</p> <code>known_field_names</code> <p>Returns known field names of the expression.</p> <code>map_field_values</code> <p>Map a primitive field to create a new primitive field.</p> <code>map_ragged_tensors</code> <p>Maps a set of primitive fields of a message to a new field.</p> <code>map_sparse_tensors</code> <p>Maps a set of primitive fields of a message to a new field.</p> <code>project</code> <p>Constrains the paths to those listed.</p> <code>promote</code> <p>Promotes source_path to be a field new_field_name in its grandparent.</p> <code>promote_and_broadcast</code> <code>reroot</code> <p>Returns a new list of protocol buffers available at new_root.</p> <code>schema_string</code> <p>Returns a schema for the expression.</p> <code>slice</code> <p>Creates a slice copy of source_path at new_field_path.</p> <code>truncate</code> <p>Creates a truncated copy of source_path at new_field_path.</p> ATTRIBUTE DESCRIPTION <code>is_leaf</code> <p>True iff the node tensor is a LeafNodeTensor.</p> <p> TYPE: <code>bool</code> </p> <code>is_repeated</code> <p>True iff the same parent value can have multiple children values.</p> <p> TYPE: <code>bool</code> </p> <code>schema_feature</code> <p>Return the schema of the field.</p> <p> TYPE: <code>Optional[Feature]</code> </p> <code>type</code> <p>dtype of the expression, or None if not a leaf expression.</p> <p> TYPE: <code>Optional[DType]</code> </p> <code>validate_step_format</code> <p> TYPE: <code>bool</code> </p> Source code in <code>struct2tensor/expression.py</code> <pre><code>def __init__(\n    self,\n    is_repeated: bool,\n    my_type: Optional[tf.DType],\n    schema_feature: Optional[schema_pb2.Feature] = None,\n    validate_step_format: bool = True,\n):\n  \"\"\"Initialize an expression.\n\n  Args:\n    is_repeated: if the expression is repeated.\n    my_type: the DType of a field, or None for an internal node.\n    schema_feature: the local schema (StructDomain information should not be\n      present).\n    validate_step_format: If True, validates that steps do not have any\n      characters that could be ambiguously understood as structure delimiters\n      (e.g. \".\"). If False, such characters are allowed and the client is\n      responsible to ensure to not rely on any auto-coercion of strings to\n      paths.\n  \"\"\"\n  self._is_repeated = is_repeated\n  self._type = my_type\n  self._child_cache = {}\n  self._schema_feature = schema_feature\n  self._validate_step_format = validate_step_format\n</code></pre>"},{"location":"api_docs/python/s2t/s2t/#struct2tensor.struct2tensor.Expression-attributes","title":"Attributes","text":""},{"location":"api_docs/python/s2t/s2t/#struct2tensor.struct2tensor.Expression.is_leaf","title":"is_leaf  <code>property</code>","text":"<pre><code>is_leaf: bool\n</code></pre> <p>True iff the node tensor is a LeafNodeTensor.</p>"},{"location":"api_docs/python/s2t/s2t/#struct2tensor.struct2tensor.Expression.is_repeated","title":"is_repeated  <code>property</code>","text":"<pre><code>is_repeated: bool\n</code></pre> <p>True iff the same parent value can have multiple children values.</p>"},{"location":"api_docs/python/s2t/s2t/#struct2tensor.struct2tensor.Expression.schema_feature","title":"schema_feature  <code>property</code>","text":"<pre><code>schema_feature: Optional[Feature]\n</code></pre> <p>Return the schema of the field.</p>"},{"location":"api_docs/python/s2t/s2t/#struct2tensor.struct2tensor.Expression.type","title":"type  <code>property</code>","text":"<pre><code>type: Optional[DType]\n</code></pre> <p>dtype of the expression, or None if not a leaf expression.</p>"},{"location":"api_docs/python/s2t/s2t/#struct2tensor.struct2tensor.Expression.validate_step_format","title":"validate_step_format  <code>property</code>","text":"<pre><code>validate_step_format: bool\n</code></pre>"},{"location":"api_docs/python/s2t/s2t/#struct2tensor.struct2tensor.Expression-functions","title":"Functions","text":""},{"location":"api_docs/python/s2t/s2t/#struct2tensor.struct2tensor.Expression.apply","title":"apply","text":"<pre><code>apply(\n    transform: Callable[[Expression], Expression],\n) -&gt; Expression\n</code></pre> Source code in <code>struct2tensor/expression.py</code> <pre><code>def apply(self,\n          transform: Callable[[\"Expression\"], \"Expression\"]) -&gt; \"Expression\":\n  return transform(self)\n</code></pre>"},{"location":"api_docs/python/s2t/s2t/#struct2tensor.struct2tensor.Expression.apply_schema","title":"apply_schema","text":"<pre><code>apply_schema(schema: Schema) -&gt; Expression\n</code></pre> Source code in <code>struct2tensor/expression.py</code> <pre><code>def apply_schema(self, schema: schema_pb2.Schema) -&gt; \"Expression\":\n  return apply_schema.apply_schema(self, schema)\n</code></pre>"},{"location":"api_docs/python/s2t/s2t/#struct2tensor.struct2tensor.Expression.broadcast","title":"broadcast","text":"<pre><code>broadcast(\n    source_path: CoercableToPath,\n    sibling_field: Step,\n    new_field_name: Step,\n) -&gt; Expression\n</code></pre> <p>Broadcasts the existing field at source_path to the sibling_field.</p> Source code in <code>struct2tensor/expression.py</code> <pre><code>def broadcast(self, source_path: CoercableToPath, sibling_field: path.Step,\n              new_field_name: path.Step) -&gt; \"Expression\":\n  \"\"\"Broadcasts the existing field at source_path to the sibling_field.\"\"\"\n  return broadcast.broadcast(self, path.create_path(source_path),\n                             sibling_field, new_field_name)\n</code></pre>"},{"location":"api_docs/python/s2t/s2t/#struct2tensor.struct2tensor.Expression.calculate","title":"calculate  <code>abstractmethod</code>","text":"<pre><code>calculate(\n    source_tensors: Sequence[NodeTensor],\n    destinations: Sequence[Expression],\n    options: Options,\n    side_info: Optional[Prensor] = None,\n) -&gt; NodeTensor\n</code></pre> <p>Calculates the node tensor of the expression.</p> <p>The node tensor must be a function of the properties of the expression and the node tensors of the expressions from get_source_expressions().</p> <p>If is_leaf, then calculate must return a LeafNodeTensor. Otherwise, it must return a ChildNodeTensor or RootNodeTensor.</p> <p>If calculate_is_identity is true, then this must return source_tensors[0].</p> <p>Sometimes, for operations such as parsing the proto, calculate will return additional information. For example, calculate() for the root of the proto expression also parses out the tensors required to calculate the tensors of the children. This is why destinations are required.</p> <p>For a reference use, see calculate_value_slowly(...) below.</p> PARAMETER DESCRIPTION <code>source_tensors</code> <p>The node tensors of the expressions in get_source_expressions().</p> <p> TYPE: <code>Sequence[NodeTensor]</code> </p> <code>destinations</code> <p>The expressions that will use the output of this method.</p> <p> TYPE: <code>Sequence[Expression]</code> </p> <code>options</code> <p>Options for the calculation.</p> <p> TYPE: <code>Options</code> </p> <code>side_info</code> <p>An optional prensor that is used to bind to a placeholder expression.</p> <p> TYPE: <code>Optional[Prensor]</code> DEFAULT: <code>None</code> </p> RETURNS DESCRIPTION <code>NodeTensor</code> <p>A NodeTensor representing the output of this expression.</p> Source code in <code>struct2tensor/expression.py</code> <pre><code>@abc.abstractmethod\ndef calculate(\n    self,\n    source_tensors: Sequence[prensor.NodeTensor],\n    destinations: Sequence[\"Expression\"],\n    options: calculate_options.Options,\n    side_info: Optional[prensor.Prensor] = None) -&gt; prensor.NodeTensor:\n  \"\"\"Calculates the node tensor of the expression.\n\n  The node tensor must be a function of the properties of the expression\n  and the node tensors of the expressions from get_source_expressions().\n\n  If is_leaf, then calculate must return a LeafNodeTensor.\n  Otherwise, it must return a ChildNodeTensor or RootNodeTensor.\n\n  If calculate_is_identity is true, then this must return source_tensors[0].\n\n  Sometimes, for operations such as parsing the proto, calculate will return\n  additional information. For example, calculate() for the root of the\n  proto expression also parses out the tensors required to calculate the\n  tensors of the children. This is why destinations are required.\n\n  For a reference use, see calculate_value_slowly(...) below.\n\n  Args:\n    source_tensors: The node tensors of the expressions in\n      get_source_expressions().\n    destinations: The expressions that will use the output of this method.\n    options: Options for the calculation.\n    side_info: An optional prensor that is used to bind to a placeholder\n      expression.\n\n  Returns:\n    A NodeTensor representing the output of this expression.\n  \"\"\"\n  raise NotImplementedError()\n</code></pre>"},{"location":"api_docs/python/s2t/s2t/#struct2tensor.struct2tensor.Expression.calculation_equal","title":"calculation_equal  <code>abstractmethod</code>","text":"<pre><code>calculation_equal(expression: Expression) -&gt; bool\n</code></pre> <p>self.calculate is equal to another expression.calculate.</p> <p>Given the same source node tensors, self.calculate(...) and expression.calculate(...) will have the same result.</p> <p>Note that this does not check that the source expressions of the two expressions are the same. Therefore, two operations can have the same calculation, but not the same output, because their sources are different. For example, if a.calculation_is_identity() is True and b.calculation_is_identity() is True, then a.calculation_equal(b) is True. However, unless a and b have the same source, the expressions themselves are not equal.</p> PARAMETER DESCRIPTION <code>expression</code> <p>The expression to compare to.</p> <p> TYPE: <code>Expression</code> </p> Source code in <code>struct2tensor/expression.py</code> <pre><code>@abc.abstractmethod\ndef calculation_equal(self, expression: \"Expression\") -&gt; bool:\n  \"\"\"self.calculate is equal to another expression.calculate.\n\n  Given the same source node tensors, self.calculate(...) and\n  expression.calculate(...) will have the same result.\n\n  Note that this does not check that the source expressions of the two\n  expressions are the same. Therefore, two operations can have the same\n  calculation, but not the same output, because their sources are different.\n  For example, if a.calculation_is_identity() is True and\n  b.calculation_is_identity() is True, then a.calculation_equal(b) is True.\n  However, unless a and b have the same source, the expressions themselves are\n  not equal.\n\n  Args:\n    expression: The expression to compare to.\n  \"\"\"\n  raise NotImplementedError()\n</code></pre>"},{"location":"api_docs/python/s2t/s2t/#struct2tensor.struct2tensor.Expression.calculation_is_identity","title":"calculation_is_identity  <code>abstractmethod</code>","text":"<pre><code>calculation_is_identity() -&gt; bool\n</code></pre> <p>True iff the self.calculate is the identity.</p> <p>There is exactly one source, and the output of self.calculate(...) is the node tensor of this source.</p> Source code in <code>struct2tensor/expression.py</code> <pre><code>@abc.abstractmethod\ndef calculation_is_identity(self) -&gt; bool:\n  \"\"\"True iff the self.calculate is the identity.\n\n  There is exactly one source, and the output of self.calculate(...) is the\n  node tensor of this source.\n  \"\"\"\n  raise NotImplementedError()\n</code></pre>"},{"location":"api_docs/python/s2t/s2t/#struct2tensor.struct2tensor.Expression.cogroup_by_index","title":"cogroup_by_index","text":"<pre><code>cogroup_by_index(\n    source_path: CoercableToPath,\n    left_name: Step,\n    right_name: Step,\n    new_field_name: Step,\n) -&gt; Expression\n</code></pre> <p>Creates a cogroup of left_name and right_name at new_field_name.</p> Source code in <code>struct2tensor/expression.py</code> <pre><code>def cogroup_by_index(self, source_path: CoercableToPath, left_name: path.Step,\n                     right_name: path.Step,\n                     new_field_name: path.Step) -&gt; \"Expression\":\n  \"\"\"Creates a cogroup of left_name and right_name at new_field_name.\"\"\"\n  raise NotImplementedError(\"cogroup_by_index is not implemented\")\n</code></pre>"},{"location":"api_docs/python/s2t/s2t/#struct2tensor.struct2tensor.Expression.create_has_field","title":"create_has_field","text":"<pre><code>create_has_field(\n    source_path: CoercableToPath, new_field_name: Step\n) -&gt; Expression\n</code></pre> <p>Creates a field that is the presence of the source path.</p> Source code in <code>struct2tensor/expression.py</code> <pre><code>def create_has_field(self, source_path: CoercableToPath,\n                     new_field_name: path.Step) -&gt; \"Expression\":\n  \"\"\"Creates a field that is the presence of the source path.\"\"\"\n  return size.has(self, path.create_path(source_path), new_field_name)\n</code></pre>"},{"location":"api_docs/python/s2t/s2t/#struct2tensor.struct2tensor.Expression.create_proto_index","title":"create_proto_index","text":"<pre><code>create_proto_index(field_name: Step) -&gt; Expression\n</code></pre> <p>Creates a proto index field as a direct child of the current root.</p> <p>The proto index maps each root element to the original batch index. For example: [0, 2] means the first element came from the first proto in the original input tensor and the second element came from the third proto. The created field is always \"dense\" -- it has the same valency as the current root.</p> PARAMETER DESCRIPTION <code>field_name</code> <p>the name of the field to be created.</p> <p> TYPE: <code>Step</code> </p> RETURNS DESCRIPTION <code>Expression</code> <p>An Expression object representing the result of the operation.</p> Source code in <code>struct2tensor/expression.py</code> <pre><code>def create_proto_index(self, field_name: path.Step) -&gt; \"Expression\":\n  \"\"\"Creates a proto index field as a direct child of the current root.\n\n  The proto index maps each root element to the original batch index.\n  For example: [0, 2] means the first element came from the first proto\n  in the original input tensor and the second element came from the third\n  proto. The created field is always \"dense\" -- it has the same valency as\n  the current root.\n\n  Args:\n    field_name: the name of the field to be created.\n\n  Returns:\n    An Expression object representing the result of the operation.\n  \"\"\"\n\n  return reroot.create_proto_index_field(self, field_name)\n</code></pre>"},{"location":"api_docs/python/s2t/s2t/#struct2tensor.struct2tensor.Expression.create_size_field","title":"create_size_field","text":"<pre><code>create_size_field(\n    source_path: CoercableToPath, new_field_name: Step\n) -&gt; Expression\n</code></pre> <p>Creates a field that is the size of the source path.</p> Source code in <code>struct2tensor/expression.py</code> <pre><code>def create_size_field(self, source_path: CoercableToPath,\n                      new_field_name: path.Step) -&gt; \"Expression\":\n  \"\"\"Creates a field that is the size of the source path.\"\"\"\n  return size.size(self, path.create_path(source_path), new_field_name)\n</code></pre>"},{"location":"api_docs/python/s2t/s2t/#struct2tensor.struct2tensor.Expression.get_child","title":"get_child","text":"<pre><code>get_child(field_name: Step) -&gt; Optional[Expression]\n</code></pre> <p>Gets a named child.</p> Source code in <code>struct2tensor/expression.py</code> <pre><code>def get_child(self, field_name: path.Step) -&gt; Optional[\"Expression\"]:\n  \"\"\"Gets a named child.\"\"\"\n  if field_name in self._child_cache:\n    return self._child_cache[field_name]\n  result = self._get_child_impl(field_name)\n  self._child_cache[field_name] = result\n  return result\n</code></pre>"},{"location":"api_docs/python/s2t/s2t/#struct2tensor.struct2tensor.Expression.get_child_or_error","title":"get_child_or_error","text":"<pre><code>get_child_or_error(field_name: Step) -&gt; Expression\n</code></pre> <p>Gets a named child.</p> Source code in <code>struct2tensor/expression.py</code> <pre><code>def get_child_or_error(self, field_name: path.Step) -&gt; \"Expression\":\n  \"\"\"Gets a named child.\"\"\"\n  result = self.get_child(field_name)\n  if result is None:\n    raise KeyError(\"No such field: {}\".format(field_name))\n  return result\n</code></pre>"},{"location":"api_docs/python/s2t/s2t/#struct2tensor.struct2tensor.Expression.get_descendant","title":"get_descendant","text":"<pre><code>get_descendant(p: Path) -&gt; Optional[Expression]\n</code></pre> <p>Finds the descendant at the path.</p> Source code in <code>struct2tensor/expression.py</code> <pre><code>def get_descendant(self, p: path.Path) -&gt; Optional[\"Expression\"]:\n  \"\"\"Finds the descendant at the path.\"\"\"\n  result = self\n  for field_name in p.field_list:\n    result = result.get_child(field_name)\n    if result is None:\n      return None\n  return result\n</code></pre>"},{"location":"api_docs/python/s2t/s2t/#struct2tensor.struct2tensor.Expression.get_descendant_or_error","title":"get_descendant_or_error","text":"<pre><code>get_descendant_or_error(p: Path) -&gt; Expression\n</code></pre> <p>Finds the descendant at the path.</p> Source code in <code>struct2tensor/expression.py</code> <pre><code>def get_descendant_or_error(self, p: path.Path) -&gt; \"Expression\":\n  \"\"\"Finds the descendant at the path.\"\"\"\n  result = self.get_descendant(p)\n  if result is None:\n    raise ValueError(\"Missing path: {} in {}\".format(\n        str(p), self.schema_string(limit=20)))\n  return result\n</code></pre>"},{"location":"api_docs/python/s2t/s2t/#struct2tensor.struct2tensor.Expression.get_known_children","title":"get_known_children","text":"<pre><code>get_known_children() -&gt; Mapping[Step, Expression]\n</code></pre> Source code in <code>struct2tensor/expression.py</code> <pre><code>def get_known_children(self) -&gt; Mapping[path.Step, \"Expression\"]:\n  known_field_names = self.known_field_names()\n  result = {}\n  for name in known_field_names:\n    result[name] = self.get_child_or_error(name)\n  return result\n</code></pre>"},{"location":"api_docs/python/s2t/s2t/#struct2tensor.struct2tensor.Expression.get_known_descendants","title":"get_known_descendants","text":"<pre><code>get_known_descendants() -&gt; Mapping[Path, Expression]\n</code></pre> <p>Gets a mapping from known paths to subexpressions.</p> <p>The difference between this and get_descendants in Prensor is that all paths in a Prensor are realized, thus all known. But an Expression's descendants might not all be known at the point this method is called, because an expression may have an infinite number of children.</p> RETURNS DESCRIPTION <code>Mapping[Path, Expression]</code> <p>A mapping from paths (relative to the root of the subexpression) to expressions.</p> Source code in <code>struct2tensor/expression.py</code> <pre><code>def get_known_descendants(self) -&gt; Mapping[path.Path, \"Expression\"]:\n  # Rename get_known_descendants\n  \"\"\"Gets a mapping from known paths to subexpressions.\n\n  The difference between this and get_descendants in Prensor is that\n  all paths in a Prensor are realized, thus all known. But an Expression's\n  descendants might not all be known at the point this method is called,\n  because an expression may have an infinite number of children.\n\n  Returns:\n    A mapping from paths (relative to the root of the subexpression) to\n      expressions.\n  \"\"\"\n  known_subexpressions = {\n      k: v.get_known_descendants()\n      for k, v in self.get_known_children().items()\n  }\n  result = {}\n  for field_name, subexpression in known_subexpressions.items():\n    subexpression_path = path.Path(\n        [field_name], validate_step_format=self.validate_step_format\n    )\n    for p, expr in subexpression.items():\n      result[subexpression_path.concat(p)] = expr\n  result[path.Path([], validate_step_format=self.validate_step_format)] = self\n  return result\n</code></pre>"},{"location":"api_docs/python/s2t/s2t/#struct2tensor.struct2tensor.Expression.get_paths_with_schema","title":"get_paths_with_schema","text":"<pre><code>get_paths_with_schema() -&gt; List[Path]\n</code></pre> <p>Extract only paths that contain schema information.</p> Source code in <code>struct2tensor/expression.py</code> <pre><code>def get_paths_with_schema(self) -&gt; List[path.Path]:\n  \"\"\"Extract only paths that contain schema information.\"\"\"\n  result = []\n  for name, child in self.get_known_children().items():\n    if child.schema_feature is None:\n      continue\n    result.extend(\n        [\n            path.Path(\n                [name], validate_step_format=self.validate_step_format\n            ).concat(x)\n            for x in child.get_paths_with_schema()\n        ]\n    )\n  # Note: We always take the root path and so will return an empty schema\n  # if there is no schema information on any nodes, including the root.\n  if not result:\n    result.append(\n        path.Path([], validate_step_format=self.validate_step_format)\n    )\n  return result\n</code></pre>"},{"location":"api_docs/python/s2t/s2t/#struct2tensor.struct2tensor.Expression.get_schema","title":"get_schema","text":"<pre><code>get_schema(create_schema_features=True) -&gt; Schema\n</code></pre> <p>Returns a schema for the entire tree.</p> PARAMETER DESCRIPTION <code>create_schema_features</code> <p>If True, schema features are added for all children and a schema entry is created if not available on the child. If False, features are left off of the returned schema if there is no schema_feature on the child.</p> <p> DEFAULT: <code>True</code> </p> Source code in <code>struct2tensor/expression.py</code> <pre><code>def get_schema(self, create_schema_features=True) -&gt; schema_pb2.Schema:\n  \"\"\"Returns a schema for the entire tree.\n\n  Args:\n    create_schema_features: If True, schema features are added for all\n      children and a schema entry is created if not available on the child. If\n      False, features are left off of the returned schema if there is no\n      schema_feature on the child.\n  \"\"\"\n  if not create_schema_features:\n    return self.project(self.get_paths_with_schema()).get_schema()\n  result = schema_pb2.Schema()\n  self._populate_schema_feature_children(result.feature)\n  return result\n</code></pre>"},{"location":"api_docs/python/s2t/s2t/#struct2tensor.struct2tensor.Expression.get_source_expressions","title":"get_source_expressions  <code>abstractmethod</code>","text":"<pre><code>get_source_expressions() -&gt; Sequence[Expression]\n</code></pre> <p>Gets the sources of this expression.</p> <p>The node tensors of the source expressions must be sufficient to calculate the node tensor of this expression (see calculate and calculate_value_slowly).</p> RETURNS DESCRIPTION <code>Sequence[Expression]</code> <p>The sources of this expression.</p> Source code in <code>struct2tensor/expression.py</code> <pre><code>@abc.abstractmethod\ndef get_source_expressions(self) -&gt; Sequence[\"Expression\"]:\n  \"\"\"Gets the sources of this expression.\n\n  The node tensors of the source expressions must be sufficient to\n  calculate the node tensor of this expression\n  (see calculate and calculate_value_slowly).\n\n  Returns:\n    The sources of this expression.\n  \"\"\"\n  raise NotImplementedError()\n</code></pre>"},{"location":"api_docs/python/s2t/s2t/#struct2tensor.struct2tensor.Expression.known_field_names","title":"known_field_names  <code>abstractmethod</code>","text":"<pre><code>known_field_names() -&gt; FrozenSet[Step]\n</code></pre> <p>Returns known field names of the expression.</p> <p>TODO(martinz): implement set_field and project. Known field names of a parsed proto correspond to the fields declared in the message. Examples of \"unknown\" fields are extensions and explicit casts in an any field. The only way to know if an unknown field \"(foo.bar)\" is present in an expression expr is to call (expr[\"(foo.bar)\"] is not None).</p> <p>Notice that simply accessing a field does not make it \"known\". However, setting a field (or setting a descendant of a field) will make it known.</p> <p>project(...) returns an expression where the known field names are the only field names. In general, if you want to depend upon known_field_names (e.g., if you want to compile a expression), then the best approach is to project() the expression first.</p> RETURNS DESCRIPTION <code>FrozenSet[Step]</code> <p>An immutable set of field names.</p> Source code in <code>struct2tensor/expression.py</code> <pre><code>@abc.abstractmethod\ndef known_field_names(self) -&gt; FrozenSet[path.Step]:\n  \"\"\"Returns known field names of the expression.\n\n  TODO(martinz): implement set_field and project.\n  Known field names of a parsed proto correspond to the fields declared in\n  the message. Examples of \"unknown\" fields are extensions and explicit casts\n  in an any field. The only way to know if an unknown field \"(foo.bar)\" is\n  present in an expression expr is to call (expr[\"(foo.bar)\"] is not None).\n\n  Notice that simply accessing a field does not make it \"known\". However,\n  setting a field (or setting a descendant of a field) will make it known.\n\n  project(...) returns an expression where the known field names are the only\n  field names. In general, if you want to depend upon known_field_names\n  (e.g., if you want to compile a expression), then the best approach is to\n  project() the expression first.\n\n  Returns:\n    An immutable set of field names.\n  \"\"\"\n</code></pre>"},{"location":"api_docs/python/s2t/s2t/#struct2tensor.struct2tensor.Expression.map_field_values","title":"map_field_values","text":"<pre><code>map_field_values(\n    source_path: CoercableToPath,\n    operator: Callable[[Tensor], Tensor],\n    dtype: DType,\n    new_field_name: Step,\n) -&gt; Expression\n</code></pre> <p>Map a primitive field to create a new primitive field.</p> <p>Note</p> <p>The dtype argument is added since the v1 API.</p> PARAMETER DESCRIPTION <code>source_path</code> <p>the origin path.</p> <p> TYPE: <code>CoercableToPath</code> </p> <code>operator</code> <p>an element-wise operator that takes a 1-dimensional vector.</p> <p> TYPE: <code>Callable[[Tensor], Tensor]</code> </p> <code>dtype</code> <p>the type of the output.</p> <p> TYPE: <code>DType</code> </p> <code>new_field_name</code> <p>the name of a new sibling of source_path.</p> <p> TYPE: <code>Step</code> </p> RETURNS DESCRIPTION <code>Expression</code> <p>the resulting root expression.</p> Source code in <code>struct2tensor/expression.py</code> <pre><code>def map_field_values(self, source_path: CoercableToPath,\n                     operator: Callable[[tf.Tensor], tf.Tensor],\n                     dtype: tf.DType,\n                     new_field_name: path.Step) -&gt; \"Expression\":\n  \"\"\"Map a primitive field to create a new primitive field.\n\n  !!! Note\n      The dtype argument is added since the v1 API.\n\n  Args:\n    source_path: the origin path.\n    operator: an element-wise operator that takes a 1-dimensional vector.\n    dtype: the type of the output.\n    new_field_name: the name of a new sibling of source_path.\n\n  Returns:\n    the resulting root expression.\n  \"\"\"\n  return map_values.map_values(self, path.create_path(source_path), operator,\n                               dtype, new_field_name)\n</code></pre>"},{"location":"api_docs/python/s2t/s2t/#struct2tensor.struct2tensor.Expression.map_ragged_tensors","title":"map_ragged_tensors","text":"<pre><code>map_ragged_tensors(\n    parent_path: CoercableToPath,\n    source_fields: Sequence[Step],\n    operator: Callable[..., SparseTensor],\n    is_repeated: bool,\n    dtype: DType,\n    new_field_name: Step,\n) -&gt; Expression\n</code></pre> <p>Maps a set of primitive fields of a message to a new field.</p> <p>Unlike map_field_values, this operation allows you to some degree reshape the field. For instance, you can take two optional fields and create a repeated field, or perform a reduce_sum on the last dimension of a repeated field and create an optional field. The key constraint is that the operator must return a sparse tensor of the correct dimension: i.e., a 2D sparse tensor if is_repeated is true, or a 1D sparse tensor if is_repeated is false. Moreover, the first dimension of the sparse tensor must be equal to the first dimension of the input tensor.</p> PARAMETER DESCRIPTION <code>parent_path</code> <p>the parent of the input and output fields.</p> <p> TYPE: <code>CoercableToPath</code> </p> <code>source_fields</code> <p>the nonempty list of names of the source fields.</p> <p> TYPE: <code>Sequence[Step]</code> </p> <code>operator</code> <p>an operator that takes len(source_fields) sparse tensors and returns a sparse tensor of the appropriate shape.</p> <p> TYPE: <code>Callable[..., SparseTensor]</code> </p> <code>is_repeated</code> <p>whether the output is repeated.</p> <p> TYPE: <code>bool</code> </p> <code>dtype</code> <p>the dtype of the result.</p> <p> TYPE: <code>DType</code> </p> <code>new_field_name</code> <p>the name of the resulting field.</p> <p> TYPE: <code>Step</code> </p> RETURNS DESCRIPTION <code>Expression</code> <p>A new query.</p> Source code in <code>struct2tensor/expression.py</code> <pre><code>def map_ragged_tensors(self, parent_path: CoercableToPath,\n                       source_fields: Sequence[path.Step],\n                       operator: Callable[..., tf.SparseTensor],\n                       is_repeated: bool, dtype: tf.DType,\n                       new_field_name: path.Step) -&gt; \"Expression\":\n  \"\"\"Maps a set of primitive fields of a message to a new field.\n\n  Unlike map_field_values, this operation allows you to some degree reshape\n  the field. For instance, you can take two optional fields and create a\n  repeated field, or perform a reduce_sum on the last dimension of a repeated\n  field and create an optional field. The key constraint is that the operator\n  must return a sparse tensor of the correct dimension: i.e., a\n  2D sparse tensor if is_repeated is true, or a 1D sparse tensor if\n  is_repeated is false. Moreover, the first dimension of the sparse tensor\n  must be equal to the first dimension of the input tensor.\n\n  Args:\n    parent_path: the parent of the input and output fields.\n    source_fields: the nonempty list of names of the source fields.\n    operator: an operator that takes len(source_fields) sparse tensors and\n      returns a sparse tensor of the appropriate shape.\n    is_repeated: whether the output is repeated.\n    dtype: the dtype of the result.\n    new_field_name: the name of the resulting field.\n\n  Returns:\n    A new query.\n  \"\"\"\n  return map_prensor.map_ragged_tensor(\n      self,\n      path.create_path(parent_path),\n      [\n          path.Path([f], validate_step_format=self.validate_step_format)\n          for f in source_fields\n      ],\n      operator,\n      is_repeated,\n      dtype,\n      new_field_name,\n  )\n</code></pre>"},{"location":"api_docs/python/s2t/s2t/#struct2tensor.struct2tensor.Expression.map_sparse_tensors","title":"map_sparse_tensors","text":"<pre><code>map_sparse_tensors(\n    parent_path: CoercableToPath,\n    source_fields: Sequence[Step],\n    operator: Callable[..., SparseTensor],\n    is_repeated: bool,\n    dtype: DType,\n    new_field_name: Step,\n) -&gt; Expression\n</code></pre> <p>Maps a set of primitive fields of a message to a new field.</p> <p>Unlike map_field_values, this operation allows you to some degree reshape the field. For instance, you can take two optional fields and create a repeated field, or perform a reduce_sum on the last dimension of a repeated field and create an optional field. The key constraint is that the operator must return a sparse tensor of the correct dimension: i.e., a 2D sparse tensor if is_repeated is true, or a 1D sparse tensor if is_repeated is false. Moreover, the first dimension of the sparse tensor must be equal to the first dimension of the input tensor.</p> PARAMETER DESCRIPTION <code>parent_path</code> <p>the parent of the input and output fields.</p> <p> TYPE: <code>CoercableToPath</code> </p> <code>source_fields</code> <p>the nonempty list of names of the source fields.</p> <p> TYPE: <code>Sequence[Step]</code> </p> <code>operator</code> <p>an operator that takes len(source_fields) sparse tensors and returns a sparse tensor of the appropriate shape.</p> <p> TYPE: <code>Callable[..., SparseTensor]</code> </p> <code>is_repeated</code> <p>whether the output is repeated.</p> <p> TYPE: <code>bool</code> </p> <code>dtype</code> <p>the dtype of the result.</p> <p> TYPE: <code>DType</code> </p> <code>new_field_name</code> <p>the name of the resulting field.</p> <p> TYPE: <code>Step</code> </p> RETURNS DESCRIPTION <code>Expression</code> <p>A new query.</p> Source code in <code>struct2tensor/expression.py</code> <pre><code>def map_sparse_tensors(self, parent_path: CoercableToPath,\n                       source_fields: Sequence[path.Step],\n                       operator: Callable[..., tf.SparseTensor],\n                       is_repeated: bool, dtype: tf.DType,\n                       new_field_name: path.Step) -&gt; \"Expression\":\n  \"\"\"Maps a set of primitive fields of a message to a new field.\n\n  Unlike map_field_values, this operation allows you to some degree reshape\n  the field. For instance, you can take two optional fields and create a\n  repeated field, or perform a reduce_sum on the last dimension of a repeated\n  field and create an optional field. The key constraint is that the operator\n  must return a sparse tensor of the correct dimension: i.e., a\n  2D sparse tensor if is_repeated is true, or a 1D sparse tensor if\n  is_repeated is false. Moreover, the first dimension of the sparse tensor\n  must be equal to the first dimension of the input tensor.\n\n  Args:\n    parent_path: the parent of the input and output fields.\n    source_fields: the nonempty list of names of the source fields.\n    operator: an operator that takes len(source_fields) sparse tensors and\n      returns a sparse tensor of the appropriate shape.\n    is_repeated: whether the output is repeated.\n    dtype: the dtype of the result.\n    new_field_name: the name of the resulting field.\n\n  Returns:\n    A new query.\n  \"\"\"\n  return map_prensor.map_sparse_tensor(\n      self,\n      path.create_path(parent_path),\n      [\n          path.Path([f], validate_step_format=self.validate_step_format)\n          for f in source_fields\n      ],\n      operator,\n      is_repeated,\n      dtype,\n      new_field_name,\n  )\n</code></pre>"},{"location":"api_docs/python/s2t/s2t/#struct2tensor.struct2tensor.Expression.project","title":"project","text":"<pre><code>project(path_list: Sequence[CoercableToPath]) -&gt; Expression\n</code></pre> <p>Constrains the paths to those listed.</p> Source code in <code>struct2tensor/expression.py</code> <pre><code>def project(self, path_list: Sequence[CoercableToPath]) -&gt; \"Expression\":\n  \"\"\"Constrains the paths to those listed.\"\"\"\n  return project.project(self, [path.create_path(x) for x in path_list])\n</code></pre>"},{"location":"api_docs/python/s2t/s2t/#struct2tensor.struct2tensor.Expression.promote","title":"promote","text":"<pre><code>promote(source_path: CoercableToPath, new_field_name: Step)\n</code></pre> <p>Promotes source_path to be a field new_field_name in its grandparent.</p> Source code in <code>struct2tensor/expression.py</code> <pre><code>def promote(self, source_path: CoercableToPath, new_field_name: path.Step):\n  \"\"\"Promotes source_path to be a field new_field_name in its grandparent.\"\"\"\n  return promote.promote(self, path.create_path(source_path), new_field_name)\n</code></pre>"},{"location":"api_docs/python/s2t/s2t/#struct2tensor.struct2tensor.Expression.promote_and_broadcast","title":"promote_and_broadcast","text":"<pre><code>promote_and_broadcast(\n    path_dictionary: Mapping[Step, CoercableToPath],\n    dest_path_parent: CoercableToPath,\n) -&gt; Expression\n</code></pre> Source code in <code>struct2tensor/expression.py</code> <pre><code>def promote_and_broadcast(\n    self, path_dictionary: Mapping[path.Step, CoercableToPath],\n    dest_path_parent: CoercableToPath) -&gt; \"Expression\":\n  return promote_and_broadcast.promote_and_broadcast(\n      self, {k: path.create_path(v) for k, v in path_dictionary.items()},\n      path.create_path(dest_path_parent))\n</code></pre>"},{"location":"api_docs/python/s2t/s2t/#struct2tensor.struct2tensor.Expression.reroot","title":"reroot","text":"<pre><code>reroot(new_root: CoercableToPath) -&gt; Expression\n</code></pre> <p>Returns a new list of protocol buffers available at new_root.</p> Source code in <code>struct2tensor/expression.py</code> <pre><code>def reroot(self, new_root: CoercableToPath) -&gt; \"Expression\":\n  \"\"\"Returns a new list of protocol buffers available at new_root.\"\"\"\n  return reroot.reroot(self, path.create_path(new_root))\n</code></pre>"},{"location":"api_docs/python/s2t/s2t/#struct2tensor.struct2tensor.Expression.schema_string","title":"schema_string","text":"<pre><code>schema_string(limit: Optional[int] = None) -&gt; str\n</code></pre> <p>Returns a schema for the expression.</p> <p>For examle, </p><pre><code>repeated root:\n  optional int32 foo\n  optional bar:\n    optional string baz\n  optional int64 bak\n</code></pre> <p>Note that unknown fields and subexpressions are not displayed.</p> PARAMETER DESCRIPTION <code>limit</code> <p>if present, limit the recursion.</p> <p> TYPE: <code>Optional[int]</code> DEFAULT: <code>None</code> </p> RETURNS DESCRIPTION <code>str</code> <p>A string, describing (a part of) the schema.</p> Source code in <code>struct2tensor/expression.py</code> <pre><code>def schema_string(self, limit: Optional[int] = None) -&gt; str:\n  \"\"\"Returns a schema for the expression.\n\n  For examle,\n  ```\n  repeated root:\n    optional int32 foo\n    optional bar:\n      optional string baz\n    optional int64 bak\n  ```\n\n  Note that unknown fields and subexpressions are not displayed.\n\n  Args:\n    limit: if present, limit the recursion.\n\n  Returns:\n    A string, describing (a part of) the schema.\n  \"\"\"\n  return \"\\n\".join(self._schema_string_helper(\"root\", limit))\n</code></pre>"},{"location":"api_docs/python/s2t/s2t/#struct2tensor.struct2tensor.Expression.slice","title":"slice","text":"<pre><code>slice(\n    source_path: CoercableToPath,\n    new_field_name: Step,\n    begin: Optional[IndexValue] = None,\n    end: Optional[IndexValue] = None,\n) -&gt; Expression\n</code></pre> <p>Creates a slice copy of source_path at new_field_path.</p> <p>Note that if begin or end is negative, it is considered relative to the size of the array. e.g., slice(...,begin=-1) will get the last element of every array.</p> PARAMETER DESCRIPTION <code>source_path</code> <p>the source of the slice.</p> <p> TYPE: <code>CoercableToPath</code> </p> <code>new_field_name</code> <p>the new field that is generated.</p> <p> TYPE: <code>Step</code> </p> <code>begin</code> <p>the beginning of the slice (inclusive).</p> <p> TYPE: <code>Optional[IndexValue]</code> DEFAULT: <code>None</code> </p> <code>end</code> <p>the end of the slice (exclusive).</p> <p> TYPE: <code>Optional[IndexValue]</code> DEFAULT: <code>None</code> </p> RETURNS DESCRIPTION <code>Expression</code> <p>An Expression object representing the result of the operation.</p> Source code in <code>struct2tensor/expression.py</code> <pre><code>def slice(self,\n          source_path: CoercableToPath,\n          new_field_name: path.Step,\n          begin: Optional[IndexValue] = None,\n          end: Optional[IndexValue] = None) -&gt; \"Expression\":\n  \"\"\"Creates a slice copy of source_path at new_field_path.\n\n  Note that if begin or end is negative, it is considered relative to\n  the size of the array. e.g., slice(...,begin=-1) will get the last\n  element of every array.\n\n  Args:\n    source_path: the source of the slice.\n    new_field_name: the new field that is generated.\n    begin: the beginning of the slice (inclusive).\n    end: the end of the slice (exclusive).\n\n  Returns:\n    An Expression object representing the result of the operation.\n  \"\"\"\n  return slice_expression.slice_expression(self,\n                                           path.create_path(source_path),\n                                           new_field_name, begin, end)\n</code></pre>"},{"location":"api_docs/python/s2t/s2t/#struct2tensor.struct2tensor.Expression.truncate","title":"truncate","text":"<pre><code>truncate(\n    source_path: CoercableToPath,\n    limit: Union[int, Tensor],\n    new_field_name: Step,\n) -&gt; Expression\n</code></pre> <p>Creates a truncated copy of source_path at new_field_path.</p> Source code in <code>struct2tensor/expression.py</code> <pre><code>def truncate(self, source_path: CoercableToPath, limit: Union[int, tf.Tensor],\n             new_field_name: path.Step) -&gt; \"Expression\":\n  \"\"\"Creates a truncated copy of source_path at new_field_path.\"\"\"\n  return self.slice(source_path, new_field_name, end=limit)\n</code></pre>"},{"location":"api_docs/python/s2t/s2t/#struct2tensor.struct2tensor.LeafNodeTensor","title":"LeafNodeTensor","text":"<pre><code>LeafNodeTensor(\n    parent_index: Tensor, values: Tensor, is_repeated: bool\n)\n</code></pre> <p>               Bases: <code>object</code></p> <p>The value of a leaf node.</p> <p>Creates a LeafNodeTensor.</p> PARAMETER DESCRIPTION <code>parent_index</code> <p>a 1-D int64 tensor where parent_index[i] represents the parent index of values[i]</p> <p> TYPE: <code>Tensor</code> </p> <code>values</code> <p>a 1-D tensor of equal length to parent_index.</p> <p> TYPE: <code>Tensor</code> </p> <code>is_repeated</code> <p>a bool indicating if there can be more than one child per parent.</p> <p> TYPE: <code>bool</code> </p> METHOD DESCRIPTION <code>get_positional_index</code> <p>Gets the positional index for this LeafNodeTensor.</p> ATTRIBUTE DESCRIPTION <code>is_repeated</code> <p> </p> <code>parent_index</code> <p> </p> <code>values</code> <p> </p> Source code in <code>struct2tensor/prensor.py</code> <pre><code>def __init__(self, parent_index: tf.Tensor, values: tf.Tensor,\n             is_repeated: bool):\n  \"\"\"Creates a LeafNodeTensor.\n\n  Args:\n    parent_index: a 1-D int64 tensor where parent_index[i] represents the\n      parent index of values[i]\n    values: a 1-D tensor of equal length to parent_index.\n    is_repeated: a bool indicating if there can be more than one child per\n      parent.\n  \"\"\"\n  self._parent_index = parent_index\n  self._values = values\n  self._is_repeated = is_repeated\n</code></pre>"},{"location":"api_docs/python/s2t/s2t/#struct2tensor.struct2tensor.LeafNodeTensor-attributes","title":"Attributes","text":""},{"location":"api_docs/python/s2t/s2t/#struct2tensor.struct2tensor.LeafNodeTensor.is_repeated","title":"is_repeated  <code>property</code>","text":"<pre><code>is_repeated\n</code></pre>"},{"location":"api_docs/python/s2t/s2t/#struct2tensor.struct2tensor.LeafNodeTensor.parent_index","title":"parent_index  <code>property</code>","text":"<pre><code>parent_index\n</code></pre>"},{"location":"api_docs/python/s2t/s2t/#struct2tensor.struct2tensor.LeafNodeTensor.values","title":"values  <code>property</code>","text":"<pre><code>values\n</code></pre>"},{"location":"api_docs/python/s2t/s2t/#struct2tensor.struct2tensor.LeafNodeTensor-functions","title":"Functions","text":""},{"location":"api_docs/python/s2t/s2t/#struct2tensor.struct2tensor.LeafNodeTensor.get_positional_index","title":"get_positional_index","text":"<pre><code>get_positional_index() -&gt; Tensor\n</code></pre> <p>Gets the positional index for this LeafNodeTensor.</p> <p>The positional index tells us which index of the parent an element is.</p> <p>For example, with the following parent indices: <code>[0, 0, 2]</code> we would have positional index:</p> <pre><code>[\n  0, # The 0th element of the 0th parent.\n  1, # The 1st element of the 0th parent.\n  0  # The 0th element of the 2nd parent.\n]\n</code></pre> <p>For more information, view ops/run_length_before_op.cc</p> <p>This is the same for Child NodeTensors.</p> RETURNS DESCRIPTION <code>Tensor</code> <p>A tensor of positional indices.</p> Source code in <code>struct2tensor/prensor.py</code> <pre><code>def get_positional_index(self) -&gt; tf.Tensor:\n  \"\"\"Gets the positional index for this LeafNodeTensor.\n\n  The positional index tells us which index of the parent an element is.\n\n  For example, with the following parent indices: `[0, 0, 2]`\n  we would have positional index:\n\n  ```python\n  [\n    0, # The 0th element of the 0th parent.\n    1, # The 1st element of the 0th parent.\n    0  # The 0th element of the 2nd parent.\n  ]\n  ```\n\n  For more information, view ops/run_length_before_op.cc\n\n  This is the same for Child NodeTensors.\n\n  Returns:\n    A tensor of positional indices.\n  \"\"\"\n  return struct2tensor_ops.run_length_before(self.parent_index)\n</code></pre>"},{"location":"api_docs/python/s2t/s2t/#struct2tensor.struct2tensor.Path","title":"Path","text":"<pre><code>Path(field_list: Sequence[Step], validate_step_format=True)\n</code></pre> <p>               Bases: <code>object</code></p> <p>A representation of a path in the expression.</p> <p>Do not implement nonzero, eq, ne, et cetera as these are implicitly defined by cmp and len.</p> <p>Create a path object.</p> PARAMETER DESCRIPTION <code>field_list</code> <p>a list or tuple of fields leading from one node to another.</p> <p> TYPE: <code>Sequence[Step]</code> </p> <code>validate_step_format</code> <p>If True, validates that steps do not have any characters that could be ambiguously understood as structure delimiters (e.g. \".\"). If False, such characters are allowed and the client is responsible to ensure do not rely on any auto-coercion of strings to paths.</p> <p> DEFAULT: <code>True</code> </p> RAISES DESCRIPTION <code>ValueError</code> <p>if any field is not a valid step (see is_valid_step).</p> METHOD DESCRIPTION <code>as_proto</code> <p>Serialize a path as a proto.</p> <code>concat</code> <code>get_child</code> <p>Get the child path.</p> <code>get_least_common_ancestor</code> <p>Get the least common ancestor, the longest shared prefix.</p> <code>get_parent</code> <p>Get the parent path.</p> <code>is_ancestor</code> <p>True if self is ancestor of other (i.e. a prefix).</p> <code>prefix</code> <code>suffix</code> ATTRIBUTE DESCRIPTION <code>field_list</code> <p> </p> Source code in <code>struct2tensor/path.py</code> <pre><code>def __init__(self, field_list: Sequence[Step], validate_step_format=True):\n  \"\"\"Create a path object.\n\n  Args:\n    field_list: a list or tuple of fields leading from one node to another.\n    validate_step_format: If True, validates that steps do not have any\n      characters that could be ambiguously understood as structure delimiters\n      (e.g. \".\"). If False, such characters are allowed and the client is\n      responsible to ensure do not rely on any auto-coercion of strings to\n      paths.\n\n  Raises:\n    ValueError: if any field is not a valid step (see is_valid_step).\n  \"\"\"\n  for field in field_list:\n    if (\n        isinstance(field, str)\n        and validate_step_format\n        and not is_valid_step(field)\n    ):\n      raise ValueError('Field \"' + field + '\" is invalid.')\n  self.field_list = tuple(field_list)\n  self._validate_step_format = validate_step_format\n</code></pre>"},{"location":"api_docs/python/s2t/s2t/#struct2tensor.struct2tensor.Path-attributes","title":"Attributes","text":""},{"location":"api_docs/python/s2t/s2t/#struct2tensor.struct2tensor.Path.field_list","title":"field_list  <code>instance-attribute</code>","text":"<pre><code>field_list = tuple(field_list)\n</code></pre>"},{"location":"api_docs/python/s2t/s2t/#struct2tensor.struct2tensor.Path-functions","title":"Functions","text":""},{"location":"api_docs/python/s2t/s2t/#struct2tensor.struct2tensor.Path.as_proto","title":"as_proto","text":"<pre><code>as_proto()\n</code></pre> <p>Serialize a path as a proto.</p> <p>This fails if there are any anonymous fields.</p> RETURNS DESCRIPTION <p>a Path proto.</p> Source code in <code>struct2tensor/path.py</code> <pre><code>def as_proto(self):\n  \"\"\"Serialize a path as a proto.\n\n  This fails if there are any anonymous fields.\n\n  Returns:\n    a Path proto.\n  \"\"\"\n  result = tf_metadata_path_pb2.Path()\n  for x in self.field_list:\n    if isinstance(x, str):\n      result.step.append(x)\n    elif isinstance(x, AnonymousId):\n      raise ValueError(\"Cannot serialize a path with anonymous fields\")\n    else:\n      raise ValueError(\"Unexpected path element type: %s\" % type(x))\n  return result\n</code></pre>"},{"location":"api_docs/python/s2t/s2t/#struct2tensor.struct2tensor.Path.concat","title":"concat","text":"<pre><code>concat(other_path: Path) -&gt; Path\n</code></pre> Source code in <code>struct2tensor/path.py</code> <pre><code>def concat(self, other_path: \"Path\") -&gt; \"Path\":\n  return Path(\n      self.field_list + other_path.field_list,\n      validate_step_format=self._validate_step_format,\n  )\n</code></pre>"},{"location":"api_docs/python/s2t/s2t/#struct2tensor.struct2tensor.Path.get_child","title":"get_child","text":"<pre><code>get_child(field_name: Step) -&gt; Path\n</code></pre> <p>Get the child path.</p> Source code in <code>struct2tensor/path.py</code> <pre><code>def get_child(self, field_name: Step) -&gt; \"Path\":\n  \"\"\"Get the child path.\"\"\"\n  if (\n      isinstance(field_name, str)\n      and self._validate_step_format\n      and not is_valid_step(field_name)\n  ):\n    raise ValueError(\"field_name is not valid: \" + field_name)\n  return Path(\n      self.field_list + (field_name,),\n      validate_step_format=self._validate_step_format,\n  )\n</code></pre>"},{"location":"api_docs/python/s2t/s2t/#struct2tensor.struct2tensor.Path.get_least_common_ancestor","title":"get_least_common_ancestor","text":"<pre><code>get_least_common_ancestor(other: Path) -&gt; Path\n</code></pre> <p>Get the least common ancestor, the longest shared prefix.</p> Source code in <code>struct2tensor/path.py</code> <pre><code>def get_least_common_ancestor(self, other: \"Path\") -&gt; \"Path\":\n  \"\"\"Get the least common ancestor, the longest shared prefix.\"\"\"\n  lca_len = self._get_least_common_ancestor_len(other)\n  return Path(\n      self.field_list[:lca_len],\n      validate_step_format=self._validate_step_format,\n  )\n</code></pre>"},{"location":"api_docs/python/s2t/s2t/#struct2tensor.struct2tensor.Path.get_parent","title":"get_parent","text":"<pre><code>get_parent() -&gt; Path\n</code></pre> <p>Get the parent path.</p> RETURNS DESCRIPTION <code>Path</code> <p>The parent path.</p> RAISES DESCRIPTION <code>ValueError</code> <p>If this is the root path.</p> Source code in <code>struct2tensor/path.py</code> <pre><code>def get_parent(self) -&gt; \"Path\":\n  \"\"\"Get the parent path.\n\n  Returns:\n    The parent path.\n\n  Raises:\n    ValueError: If this is the root path.\n  \"\"\"\n  if not self:\n    raise ValueError(\"Tried to find parent of root\")\n  return Path(self.field_list[:-1],\n              validate_step_format=self._validate_step_format)\n</code></pre>"},{"location":"api_docs/python/s2t/s2t/#struct2tensor.struct2tensor.Path.is_ancestor","title":"is_ancestor","text":"<pre><code>is_ancestor(other: Path) -&gt; bool\n</code></pre> <p>True if self is ancestor of other (i.e. a prefix).</p> Source code in <code>struct2tensor/path.py</code> <pre><code>def is_ancestor(self, other: \"Path\") -&gt; bool:\n  \"\"\"True if self is ancestor of other (i.e. a prefix).\"\"\"\n  return len(self.field_list) &lt;= len(other.field_list) and self == Path(\n      other.field_list[:len(self.field_list)])\n</code></pre>"},{"location":"api_docs/python/s2t/s2t/#struct2tensor.struct2tensor.Path.prefix","title":"prefix","text":"<pre><code>prefix(ending_index: int) -&gt; Path\n</code></pre> Source code in <code>struct2tensor/path.py</code> <pre><code>def prefix(self, ending_index: int) -&gt; \"Path\":\n  return Path(\n      self.field_list[:ending_index],\n      validate_step_format=self._validate_step_format,\n  )\n</code></pre>"},{"location":"api_docs/python/s2t/s2t/#struct2tensor.struct2tensor.Path.suffix","title":"suffix","text":"<pre><code>suffix(starting_index: int) -&gt; Path\n</code></pre> Source code in <code>struct2tensor/path.py</code> <pre><code>def suffix(self, starting_index: int) -&gt; \"Path\":\n  return Path(\n      self.field_list[starting_index:],\n      validate_step_format=self._validate_step_format,\n  )\n</code></pre>"},{"location":"api_docs/python/s2t/s2t/#struct2tensor.struct2tensor.Prensor","title":"Prensor","text":"<pre><code>Prensor(\n    node: NodeTensor, children: OrderedDict[Step, Prensor]\n)\n</code></pre> <p>               Bases: <code>CompositeTensor</code></p> <p>A expression of NodeTensor objects.</p> <p>Construct a Prensor.</p> <p>Do not call directly, instead call either:   create_prensor_from_descendant_nodes or   create_prensor_from_root_and_children</p> PARAMETER DESCRIPTION <code>node</code> <p>the NodeTensor of the root.</p> <p> TYPE: <code>NodeTensor</code> </p> <code>children</code> <p>a map from edge to subexpression.</p> <p> TYPE: <code>OrderedDict[Step, Prensor]</code> </p> METHOD DESCRIPTION <code>field_names</code> <p>Returns the field names of the children.</p> <code>get_child</code> <p>Gets the child at field_name.</p> <code>get_child_or_error</code> <p>Gets the child at field_name.</p> <code>get_children</code> <p>A map from field name to subexpression.</p> <code>get_descendant</code> <p>Finds the descendant at the path.</p> <code>get_descendant_or_error</code> <p>Finds the descendant at the path.</p> <code>get_descendants</code> <p>A map from paths to all subexpressions.</p> <code>get_ragged_tensor</code> <p>Get a ragged tensor for a path.</p> <code>get_ragged_tensors</code> <p>Gets ragged tensors for all the leaves of the prensor expression.</p> <code>get_sparse_tensor</code> <p>Gets a sparse tensor for path p.</p> <code>get_sparse_tensors</code> <p>Gets sparse tensors for all the leaves of the prensor expression.</p> ATTRIBUTE DESCRIPTION <code>is_leaf</code> <p>True iff the node value is a LeafNodeTensor.</p> <p> TYPE: <code>bool</code> </p> <code>node</code> <p>The node of the root of the subtree.</p> <p> TYPE: <code>NodeTensor</code> </p> Source code in <code>struct2tensor/prensor.py</code> <pre><code>def __init__(self, node: NodeTensor,\n             children: \"collections.OrderedDict[path.Step, Prensor]\"):\n  \"\"\"Construct a Prensor.\n\n  Do not call directly, instead call either:\n    create_prensor_from_descendant_nodes or\n    create_prensor_from_root_and_children\n\n  Args:\n    node: the NodeTensor of the root.\n    children: a map from edge to subexpression.\n  \"\"\"\n  self._node = node\n  self._children = children\n</code></pre>"},{"location":"api_docs/python/s2t/s2t/#struct2tensor.struct2tensor.Prensor-attributes","title":"Attributes","text":""},{"location":"api_docs/python/s2t/s2t/#struct2tensor.struct2tensor.Prensor.is_leaf","title":"is_leaf  <code>property</code>","text":"<pre><code>is_leaf: bool\n</code></pre> <p>True iff the node value is a LeafNodeTensor.</p>"},{"location":"api_docs/python/s2t/s2t/#struct2tensor.struct2tensor.Prensor.node","title":"node  <code>property</code>","text":"<pre><code>node: NodeTensor\n</code></pre> <p>The node of the root of the subtree.</p>"},{"location":"api_docs/python/s2t/s2t/#struct2tensor.struct2tensor.Prensor-functions","title":"Functions","text":""},{"location":"api_docs/python/s2t/s2t/#struct2tensor.struct2tensor.Prensor.field_names","title":"field_names","text":"<pre><code>field_names() -&gt; FrozenSet[Step]\n</code></pre> <p>Returns the field names of the children.</p> Source code in <code>struct2tensor/prensor.py</code> <pre><code>def field_names(self) -&gt; FrozenSet[path.Step]:\n  \"\"\"Returns the field names of the children.\"\"\"\n  return frozenset(self._children.keys())\n</code></pre>"},{"location":"api_docs/python/s2t/s2t/#struct2tensor.struct2tensor.Prensor.get_child","title":"get_child","text":"<pre><code>get_child(field_name: Step) -&gt; Optional[Prensor]\n</code></pre> <p>Gets the child at field_name.</p> Source code in <code>struct2tensor/prensor.py</code> <pre><code>def get_child(self, field_name: path.Step) -&gt; Optional[\"Prensor\"]:\n  \"\"\"Gets the child at field_name.\"\"\"\n  return self._children.get(field_name)\n</code></pre>"},{"location":"api_docs/python/s2t/s2t/#struct2tensor.struct2tensor.Prensor.get_child_or_error","title":"get_child_or_error","text":"<pre><code>get_child_or_error(field_name: Step) -&gt; Prensor\n</code></pre> <p>Gets the child at field_name.</p> Source code in <code>struct2tensor/prensor.py</code> <pre><code>def get_child_or_error(self, field_name: path.Step) -&gt; \"Prensor\":\n  \"\"\"Gets the child at field_name.\"\"\"\n  result = self._children.get(field_name)\n  if result is not None:\n    return result\n  raise ValueError(\"Field not found: {} in {}\".format(\n      str(field_name), str(self)))\n</code></pre>"},{"location":"api_docs/python/s2t/s2t/#struct2tensor.struct2tensor.Prensor.get_children","title":"get_children","text":"<pre><code>get_children() -&gt; OrderedDict[Step, Prensor]\n</code></pre> <p>A map from field name to subexpression.</p> Source code in <code>struct2tensor/prensor.py</code> <pre><code>def get_children(self) -&gt; \"collections.OrderedDict[path.Step, Prensor]\":\n  \"\"\"A map from field name to subexpression.\"\"\"\n  return self._children\n</code></pre>"},{"location":"api_docs/python/s2t/s2t/#struct2tensor.struct2tensor.Prensor.get_descendant","title":"get_descendant","text":"<pre><code>get_descendant(p: Path) -&gt; Optional[Prensor]\n</code></pre> <p>Finds the descendant at the path.</p> Source code in <code>struct2tensor/prensor.py</code> <pre><code>def get_descendant(self, p: path.Path) -&gt; Optional[\"Prensor\"]:\n  \"\"\"Finds the descendant at the path.\"\"\"\n  result = self\n  for field_name in p.field_list:\n    result = result.get_child(field_name)\n    if result is None:\n      return None\n  return result\n</code></pre>"},{"location":"api_docs/python/s2t/s2t/#struct2tensor.struct2tensor.Prensor.get_descendant_or_error","title":"get_descendant_or_error","text":"<pre><code>get_descendant_or_error(p: Path) -&gt; Prensor\n</code></pre> <p>Finds the descendant at the path.</p> Source code in <code>struct2tensor/prensor.py</code> <pre><code>def get_descendant_or_error(self, p: path.Path) -&gt; \"Prensor\":\n  \"\"\"Finds the descendant at the path.\"\"\"\n  result = self.get_descendant(p)\n  if result is None:\n    raise ValueError(\"Missing path: {} in {}\".format(str(p), str(self)))\n  return result\n</code></pre>"},{"location":"api_docs/python/s2t/s2t/#struct2tensor.struct2tensor.Prensor.get_descendants","title":"get_descendants","text":"<pre><code>get_descendants() -&gt; Mapping[Path, Prensor]\n</code></pre> <p>A map from paths to all subexpressions.</p> Source code in <code>struct2tensor/prensor.py</code> <pre><code>def get_descendants(self) -&gt; Mapping[path.Path, \"Prensor\"]:\n  \"\"\"A map from paths to all subexpressions.\"\"\"\n  result = {path.Path([]): self}\n  for k, v in self._children.items():\n    subexpression_descendants = v.get_descendants()\n    for k2, v2 in subexpression_descendants.items():\n      # Since k is already a path.Step, we know it is valid and needn't\n      # validate it again.\n      result[path.Path([k], validate_step_format=False).concat(k2)] = v2\n  return result\n</code></pre>"},{"location":"api_docs/python/s2t/s2t/#struct2tensor.struct2tensor.Prensor.get_ragged_tensor","title":"get_ragged_tensor","text":"<pre><code>get_ragged_tensor(\n    p: Path, options: Options = get_default_options()\n) -&gt; RaggedTensor\n</code></pre> <p>Get a ragged tensor for a path.</p> <p>All steps are represented in the ragged tensor.</p> PARAMETER DESCRIPTION <code>p</code> <p>the path to a leaf node in <code>t</code>.</p> <p> TYPE: <code>Path</code> </p> <code>options</code> <p>Options for calculating ragged tensors.</p> <p> TYPE: <code>Options</code> DEFAULT: <code>get_default_options()</code> </p> RETURNS DESCRIPTION <code>RaggedTensor</code> <p>A ragged tensor containing values of the leaf node, preserving the structure along the path. Raises an error if the path is not found.</p> Source code in <code>struct2tensor/prensor.py</code> <pre><code>def get_ragged_tensor(\n    self,\n    p: path.Path,\n    options: calculate_options.Options = calculate_options\n    .get_default_options()\n) -&gt; tf.RaggedTensor:\n  \"\"\"Get a ragged tensor for a path.\n\n  All steps are represented in the ragged tensor.\n\n  Args:\n    p: the path to a leaf node in `t`.\n    options: Options for calculating ragged tensors.\n\n  Returns:\n    A ragged tensor containing values of the leaf node, preserving the\n      structure along the path. Raises an error if the path is not found.\n  \"\"\"\n  return _get_ragged_tensor(self, p, options=options)\n</code></pre>"},{"location":"api_docs/python/s2t/s2t/#struct2tensor.struct2tensor.Prensor.get_ragged_tensors","title":"get_ragged_tensors","text":"<pre><code>get_ragged_tensors(\n    options: Options = get_default_options(),\n) -&gt; Mapping[Path, RaggedTensor]\n</code></pre> <p>Gets ragged tensors for all the leaves of the prensor expression.</p> PARAMETER DESCRIPTION <code>options</code> <p>Options for calculating ragged tensors.</p> <p> TYPE: <code>Options</code> DEFAULT: <code>get_default_options()</code> </p> RETURNS DESCRIPTION <code>Mapping[Path, RaggedTensor]</code> <p>A map from paths to ragged tensors.</p> Source code in <code>struct2tensor/prensor.py</code> <pre><code>def get_ragged_tensors(\n    self,\n    options: calculate_options.Options = calculate_options\n    .get_default_options()\n) -&gt; Mapping[path.Path, tf.RaggedTensor]:\n  \"\"\"Gets ragged tensors for all the leaves of the prensor expression.\n\n  Args:\n    options: Options for calculating ragged tensors.\n\n  Returns:\n    A map from paths to ragged tensors.\n  \"\"\"\n  return _get_ragged_tensors(self, options=options)\n</code></pre>"},{"location":"api_docs/python/s2t/s2t/#struct2tensor.struct2tensor.Prensor.get_sparse_tensor","title":"get_sparse_tensor","text":"<pre><code>get_sparse_tensor(\n    p: Path, options: Options = get_default_options()\n) -&gt; SparseTensor\n</code></pre> <p>Gets a sparse tensor for path p.</p> <p>Note that any optional fields are not registered as dimensions, as they can't be represented in a sparse tensor.</p> PARAMETER DESCRIPTION <code>p</code> <p>The path to a leaf node in <code>t</code>.</p> <p> TYPE: <code>Path</code> </p> <code>options</code> <p>Currently unused.</p> <p> TYPE: <code>Options</code> DEFAULT: <code>get_default_options()</code> </p> RETURNS DESCRIPTION <code>SparseTensor</code> <p>A sparse tensor containing values of the leaf node, preserving the structure along the path. Raises an error if the path is not found.</p> Source code in <code>struct2tensor/prensor.py</code> <pre><code>def get_sparse_tensor(\n    self,\n    p: path.Path,\n    options: calculate_options.Options = calculate_options\n    .get_default_options()\n) -&gt; tf.SparseTensor:\n  \"\"\"Gets a sparse tensor for path p.\n\n  Note that any optional fields are not registered as dimensions, as they\n  can't be represented in a sparse tensor.\n\n  Args:\n    p: The path to a leaf node in `t`.\n    options: Currently unused.\n\n  Returns:\n    A sparse tensor containing values of the leaf node, preserving the\n      structure along the path. Raises an error if the path is not found.\n  \"\"\"\n  return _get_sparse_tensor(self, p, options=options)\n</code></pre>"},{"location":"api_docs/python/s2t/s2t/#struct2tensor.struct2tensor.Prensor.get_sparse_tensors","title":"get_sparse_tensors","text":"<pre><code>get_sparse_tensors(\n    options: Options = get_default_options(),\n) -&gt; Mapping[Path, SparseTensor]\n</code></pre> <p>Gets sparse tensors for all the leaves of the prensor expression.</p> PARAMETER DESCRIPTION <code>options</code> <p>Currently unused.</p> <p> TYPE: <code>Options</code> DEFAULT: <code>get_default_options()</code> </p> RETURNS DESCRIPTION <code>Mapping[Path, SparseTensor]</code> <p>A map from paths to sparse tensors.</p> Source code in <code>struct2tensor/prensor.py</code> <pre><code>def get_sparse_tensors(\n    self,\n    options: calculate_options.Options = calculate_options\n    .get_default_options()\n) -&gt; Mapping[path.Path, tf.SparseTensor]:\n  \"\"\"Gets sparse tensors for all the leaves of the prensor expression.\n\n  Args:\n    options: Currently unused.\n\n  Returns:\n    A map from paths to sparse tensors.\n  \"\"\"\n  return _get_sparse_tensors(self, options=options)\n</code></pre>"},{"location":"api_docs/python/s2t/s2t/#struct2tensor.struct2tensor.RootNodeTensor","title":"RootNodeTensor","text":"<pre><code>RootNodeTensor(size: Tensor)\n</code></pre> <p>               Bases: <code>object</code></p> <p>The value of the root.</p> <p>Creates a root node.</p> PARAMETER DESCRIPTION <code>size</code> <p>A scalar int64 tensor saying how many root objects there are.</p> <p> TYPE: <code>Tensor</code> </p> METHOD DESCRIPTION <code>get_positional_index</code> <p>Gets the positional index for this RootNodeTensor.</p> ATTRIBUTE DESCRIPTION <code>is_repeated</code> <p> </p> <code>size</code> <p> </p> Source code in <code>struct2tensor/prensor.py</code> <pre><code>def __init__(self, size: tf.Tensor):\n  \"\"\"Creates a root node.\n\n  Args:\n    size: A scalar int64 tensor saying how many root objects there are.\n  \"\"\"\n  self._size = size\n</code></pre>"},{"location":"api_docs/python/s2t/s2t/#struct2tensor.struct2tensor.RootNodeTensor-attributes","title":"Attributes","text":""},{"location":"api_docs/python/s2t/s2t/#struct2tensor.struct2tensor.RootNodeTensor.is_repeated","title":"is_repeated  <code>property</code>","text":"<pre><code>is_repeated\n</code></pre>"},{"location":"api_docs/python/s2t/s2t/#struct2tensor.struct2tensor.RootNodeTensor.size","title":"size  <code>property</code>","text":"<pre><code>size\n</code></pre>"},{"location":"api_docs/python/s2t/s2t/#struct2tensor.struct2tensor.RootNodeTensor-functions","title":"Functions","text":""},{"location":"api_docs/python/s2t/s2t/#struct2tensor.struct2tensor.RootNodeTensor.get_positional_index","title":"get_positional_index","text":"<pre><code>get_positional_index() -&gt; Tensor\n</code></pre> <p>Gets the positional index for this RootNodeTensor.</p> <p>The positional index relative to the node's parent, and thus is always monotonically increasing at step size 1 for a RootNodeTensor.</p> RETURNS DESCRIPTION <code>Tensor</code> <p>A tensor of positional indices.</p> Source code in <code>struct2tensor/prensor.py</code> <pre><code>def get_positional_index(self) -&gt; tf.Tensor:\n  \"\"\"Gets the positional index for this RootNodeTensor.\n\n  The positional index relative to the node's parent, and thus is always\n  monotonically increasing at step size 1 for a RootNodeTensor.\n\n  Returns:\n    A tensor of positional indices.\n  \"\"\"\n  return tf.range(self.size)\n</code></pre>"},{"location":"api_docs/python/s2t/s2t/#struct2tensor.struct2tensor-functions","title":"Functions","text":""},{"location":"api_docs/python/s2t/s2t/#struct2tensor.struct2tensor.calculate_prensors","title":"calculate_prensors","text":"<pre><code>calculate_prensors(\n    expressions: Sequence[Expression],\n    options: Optional[Options] = None,\n    feed_dict: Optional[Dict[Expression, Prensor]] = None,\n) -&gt; Sequence[Prensor]\n</code></pre> <p>Gets the prensor value of the expressions.</p> PARAMETER DESCRIPTION <code>expressions</code> <p>expressions to calculate prensors for.</p> <p> TYPE: <code>Sequence[Expression]</code> </p> <code>options</code> <p>options for calculate(...).</p> <p> TYPE: <code>Optional[Options]</code> DEFAULT: <code>None</code> </p> <code>feed_dict</code> <p>a dictionary, mapping expression to prensor that will be used as the initial expression in the expression graph.</p> <p> TYPE: <code>Optional[Dict[Expression, Prensor]]</code> DEFAULT: <code>None</code> </p> RETURNS DESCRIPTION <code>Sequence[Prensor]</code> <p>a list of prensors.</p> Source code in <code>struct2tensor/calculate.py</code> <pre><code>def calculate_prensors(\n    expressions: Sequence[expression.Expression],\n    options: Optional[calculate_options.Options] = None,\n    feed_dict: Optional[Dict[expression.Expression, prensor.Prensor]] = None\n) -&gt; Sequence[prensor.Prensor]:\n  \"\"\"Gets the prensor value of the expressions.\n\n  Args:\n    expressions: expressions to calculate prensors for.\n    options: options for calculate(...).\n    feed_dict: a dictionary, mapping expression to prensor that will be used\n      as the initial expression in the expression graph.\n\n  Returns:\n    a list of prensors.\n  \"\"\"\n\n  return calculate_prensors_with_graph(\n      expressions, options=options, feed_dict=feed_dict)[0]\n</code></pre>"},{"location":"api_docs/python/s2t/s2t/#struct2tensor.struct2tensor.calculate_prensors_with_graph","title":"calculate_prensors_with_graph","text":"<pre><code>calculate_prensors_with_graph(\n    expressions: Sequence[Expression],\n    options: Optional[Options] = None,\n    feed_dict: Optional[Dict[Expression, Prensor]] = None,\n) -&gt; Tuple[Sequence[Prensor], ExpressionGraph]\n</code></pre> <p>Gets the prensor value of the expressions and the graph used.</p> <p>This method is useful for getting information like the protobuf fields parsed to create an expression.</p> PARAMETER DESCRIPTION <code>expressions</code> <p>expressions to calculate prensors for.</p> <p> TYPE: <code>Sequence[Expression]</code> </p> <code>options</code> <p>options for calculate(...) methods.</p> <p> TYPE: <code>Optional[Options]</code> DEFAULT: <code>None</code> </p> <code>feed_dict</code> <p>a dictionary, mapping expression to prensor that will be used as the initial expression in the expression graph.</p> <p> TYPE: <code>Optional[Dict[Expression, Prensor]]</code> DEFAULT: <code>None</code> </p> RETURNS DESCRIPTION <code>Tuple[Sequence[Prensor], ExpressionGraph]</code> <p>a list of prensors, and the graph used to calculate them.</p> Source code in <code>struct2tensor/calculate.py</code> <pre><code>def calculate_prensors_with_graph(\n    expressions: Sequence[expression.Expression],\n    options: Optional[calculate_options.Options] = None,\n    feed_dict: Optional[Dict[expression.Expression, prensor.Prensor]] = None\n) -&gt; Tuple[Sequence[prensor.Prensor], \"ExpressionGraph\"]:\n  \"\"\"Gets the prensor value of the expressions and the graph used.\n\n  This method is useful for getting information like the protobuf fields parsed\n  to create an expression.\n\n  Args:\n    expressions: expressions to calculate prensors for.\n    options: options for calculate(...) methods.\n    feed_dict: a dictionary, mapping expression to prensor that will be used\n      as the initial expression in the expression graph.\n\n  Returns:\n    a list of prensors, and the graph used to calculate them.\n  \"\"\"\n  subtrees = [x.get_known_descendants() for x in expressions]\n  all_expressions = []\n  for tree in subtrees:\n    all_expressions.extend(tree.values())\n  values, graph = calculate_values_with_graph(\n      all_expressions, options=options, feed_dict=feed_dict)\n  expr_value_pairs = zip(all_expressions, values)\n  value_map = {}\n  for expr, value in expr_value_pairs:\n    if id(expr) not in value_map:\n      value_map[id(expr)] = value\n  return ([_get_prensor(subtree, value_map) for subtree in subtrees], graph)\n</code></pre>"},{"location":"api_docs/python/s2t/s2t/#struct2tensor.struct2tensor.calculate_prensors_with_source_paths","title":"calculate_prensors_with_source_paths","text":"<pre><code>calculate_prensors_with_source_paths(\n    trees: Sequence[Expression],\n    options: Optional[Options] = None,\n) -&gt; Tuple[Sequence[Prensor], Sequence[ProtoRequirements]]\n</code></pre> <p>Returns a list of prensor trees, and proto summaries.</p> Source code in <code>struct2tensor/calculate_with_source_paths.py</code> <pre><code>def calculate_prensors_with_source_paths(\n    trees: Sequence[expression.Expression],\n    options: Optional[calculate_options.Options] = None\n) -&gt; Tuple[Sequence[prensor.Prensor], Sequence[ProtoRequirements]]:\n  \"\"\"Returns a list of prensor trees, and proto summaries.\"\"\"\n  prensors, graph = calculate.calculate_prensors_with_graph(\n      trees, options=options)\n  proto_expressions = [\n      x for x in graph.get_expressions_needed() if proto.is_proto_expression(x)\n  ]\n  summaries = _get_proto_summaries(proto_expressions)\n  return prensors, summaries\n</code></pre>"},{"location":"api_docs/python/s2t/s2t/#struct2tensor.struct2tensor.create_expression_from_file_descriptor_set","title":"create_expression_from_file_descriptor_set","text":"<pre><code>create_expression_from_file_descriptor_set(\n    tensor_of_protos: Tensor,\n    proto_name: ProtoFullName,\n    file_descriptor_set: FileDescriptorSet,\n    message_format: str = \"binary\",\n) -&gt; Expression\n</code></pre> <p>Create an expression from a 1D tensor of serialized protos.</p> PARAMETER DESCRIPTION <code>tensor_of_protos</code> <p>1D tensor of serialized protos.</p> <p> TYPE: <code>Tensor</code> </p> <code>proto_name</code> <p>fully qualified name (e.g. \"some.package.SomeProto\") of the proto in <code>tensor_of_protos</code>.</p> <p> TYPE: <code>ProtoFullName</code> </p> <code>file_descriptor_set</code> <p>The FileDescriptorSet proto containing <code>proto_name</code>'s and all its dependencies' FileDescriptorProto. Note that if file1 imports file2, then file2's FileDescriptorProto must precede file1's in file_descriptor_set.file.</p> <p> TYPE: <code>FileDescriptorSet</code> </p> <code>message_format</code> <p>Indicates the format of the protocol buffer: is one of  'text' or 'binary'.</p> <p> TYPE: <code>str</code> DEFAULT: <code>'binary'</code> </p> RETURNS DESCRIPTION <code>Expression</code> <p>An expression.</p> Source code in <code>struct2tensor/expression_impl/proto.py</code> <pre><code>def create_expression_from_file_descriptor_set(\n    tensor_of_protos: tf.Tensor,\n    proto_name: ProtoFullName,\n    file_descriptor_set: descriptor_pb2.FileDescriptorSet,\n    message_format: str = \"binary\") -&gt; expression.Expression:\n  \"\"\"Create an expression from a 1D tensor of serialized protos.\n\n  Args:\n    tensor_of_protos: 1D tensor of serialized protos.\n    proto_name: fully qualified name (e.g. \"some.package.SomeProto\") of the\n      proto in `tensor_of_protos`.\n    file_descriptor_set: The FileDescriptorSet proto containing `proto_name`'s\n      and all its dependencies' FileDescriptorProto. Note that if file1 imports\n      file2, then file2's FileDescriptorProto must precede file1's in\n      file_descriptor_set.file.\n    message_format: Indicates the format of the protocol buffer: is one of\n       'text' or 'binary'.\n\n  Returns:\n    An expression.\n  \"\"\"\n\n  pool = DescriptorPool()\n  for f in file_descriptor_set.file:\n    # This method raises if f's dependencies have not been added.\n    pool.Add(f)\n\n  # This method raises if proto not found.\n  desc = pool.FindMessageTypeByName(proto_name)\n\n  return create_expression_from_proto(tensor_of_protos, desc, message_format)\n</code></pre>"},{"location":"api_docs/python/s2t/s2t/#struct2tensor.struct2tensor.create_expression_from_prensor","title":"create_expression_from_prensor","text":"<pre><code>create_expression_from_prensor(\n    t: Prensor, validate_step_format: bool = True\n) -&gt; Expression\n</code></pre> <p>Gets an expression representing the prensor.</p> PARAMETER DESCRIPTION <code>t</code> <p>The prensor to represent.</p> <p> TYPE: <code>Prensor</code> </p> <code>validate_step_format</code> <p>If True, validates that steps do not have any characters that could be ambiguously understood as structure delimiters (e.g. \".\"). If False, such characters are allowed and the client is responsible to ensure to not rely on any auto-coercion of strings to paths.</p> <p> TYPE: <code>bool</code> DEFAULT: <code>True</code> </p> RETURNS DESCRIPTION <code>Expression</code> <p>An expression representing the prensor.</p> Source code in <code>struct2tensor/create_expression.py</code> <pre><code>def create_expression_from_prensor(\n    t: prensor.Prensor, validate_step_format: bool = True\n) -&gt; expression.Expression:\n  \"\"\"Gets an expression representing the prensor.\n\n  Args:\n    t: The prensor to represent.\n    validate_step_format: If True, validates that steps do not have any\n      characters that could be ambiguously understood as structure delimiters\n      (e.g. \".\"). If False, such characters are allowed and the client is\n      responsible to ensure to not rely on any auto-coercion of strings to\n      paths.\n\n  Returns:\n    An expression representing the prensor.\n  \"\"\"\n  node_tensor = t.node\n  children = {\n      k: create_expression_from_prensor(\n          v, validate_step_format=validate_step_format\n      )\n      for k, v in t.get_children().items()\n  }\n  if isinstance(node_tensor, prensor.RootNodeTensor):\n    return _DirectExpression(\n        True, None, node_tensor, children, validate_step_format\n    )\n  elif isinstance(node_tensor, prensor.ChildNodeTensor):\n    return _DirectExpression(\n        node_tensor.is_repeated,\n        None,\n        node_tensor,\n        children,\n        validate_step_format,\n    )\n  else:\n    # isinstance(node_tensor, LeafNodeTensor)\n    return _DirectExpression(\n        node_tensor.is_repeated,\n        node_tensor.values.dtype,\n        node_tensor,\n        children,\n        validate_step_format,\n    )\n</code></pre>"},{"location":"api_docs/python/s2t/s2t/#struct2tensor.struct2tensor.create_expression_from_proto","title":"create_expression_from_proto","text":"<pre><code>create_expression_from_proto(\n    tensor_of_protos: Tensor,\n    desc: Descriptor,\n    message_format: str = \"binary\",\n) -&gt; Expression\n</code></pre> <p>Create an expression from a 1D tensor of serialized protos.</p> PARAMETER DESCRIPTION <code>tensor_of_protos</code> <p>1D tensor of serialized protos.</p> <p> TYPE: <code>Tensor</code> </p> <code>desc</code> <p>a descriptor of protos in tensor of protos.</p> <p> TYPE: <code>Descriptor</code> </p> <code>message_format</code> <p>Indicates the format of the protocol buffer: is one of 'text' or 'binary'.</p> <p> TYPE: <code>str</code> DEFAULT: <code>'binary'</code> </p> RETURNS DESCRIPTION <code>Expression</code> <p>An expression.</p> Source code in <code>struct2tensor/expression_impl/proto.py</code> <pre><code>def create_expression_from_proto(\n    tensor_of_protos: tf.Tensor,\n    desc: descriptor.Descriptor,\n    message_format: str = \"binary\") -&gt; expression.Expression:\n  \"\"\"Create an expression from a 1D tensor of serialized protos.\n\n  Args:\n    tensor_of_protos: 1D tensor of serialized protos.\n    desc: a descriptor of protos in tensor of protos.\n    message_format: Indicates the format of the protocol buffer: is one of\n      'text' or 'binary'.\n\n  Returns:\n    An expression.\n  \"\"\"\n  return _ProtoRootExpression(desc, tensor_of_protos, message_format)\n</code></pre>"},{"location":"api_docs/python/s2t/s2t/#struct2tensor.struct2tensor.create_path","title":"create_path","text":"<pre><code>create_path(path_source: CoercableToPath) -&gt; Path\n</code></pre> <p>Create a path from an object.</p> <p>The BNF for a path is: </p><pre><code>letter := [A-Za-z]\ndigit := [0-9]\n&lt;simple_step_char&gt; := \"_\"|\"-\"| | letter | digit\n&lt;simple_step&gt; := &lt;simple_step_char&gt;+\n&lt;extension&gt; := \"(\" (&lt;simple_step&gt; \".\")* &lt;simple_step&gt; \")\"\n&lt;step&gt; := &lt;simple_step&gt; | &lt;extension&gt;\n&lt;path&gt; := ((&lt;step&gt; \".\") * &lt;step&gt;)?\n</code></pre> <p>TODO(martinz): consider removing dash. This would break YouTube WatchNext.</p> PARAMETER DESCRIPTION <code>path_source</code> <p>a string or a Path object.</p> <p> TYPE: <code>CoercableToPath</code> </p> RETURNS DESCRIPTION <code>Path</code> <p>A Path.</p> <p>Raises:   ValueError: if this is not a valid path.</p> Source code in <code>struct2tensor/path.py</code> <pre><code>def create_path(path_source: CoercableToPath) -&gt; Path:\n  \"\"\"Create a path from an object.\n\n  The BNF for a path is:\n  ```\n  letter := [A-Za-z]\n  digit := [0-9]\n  &lt;simple_step_char&gt; := \"_\"|\"-\"| | letter | digit\n  &lt;simple_step&gt; := &lt;simple_step_char&gt;+\n  &lt;extension&gt; := \"(\" (&lt;simple_step&gt; \".\")* &lt;simple_step&gt; \")\"\n  &lt;step&gt; := &lt;simple_step&gt; | &lt;extension&gt;\n  &lt;path&gt; := ((&lt;step&gt; \".\") * &lt;step&gt;)?\n  ```\n\n  TODO(martinz): consider removing dash. This would break YouTube WatchNext.\n\n  Args:\n    path_source: a string or a Path object.\n\n  Returns:\n    A Path.\n  Raises:\n    ValueError: if this is not a valid path.\n  \"\"\"\n  if isinstance(path_source, Path):\n    return path_source\n  if path_source and path_source[-1] == \".\":\n    # If we removed this then the period at the end would be ignored, and\n    # \"foo.bar.\" would become ['foo', 'bar']\n    raise ValueError(\"Path cannot end with .\")\n  result = []\n  path_remaining = path_source\n  # Capture a simple or extension step, then capture the next dot or end.\n  path_step_separator_re = re.compile(\n      \"(\" + _EXTENSION_REGEX + \"|\" + _SIMPLE_STEP_REGEX + \"|\" +\n      _MAP_INDEXING_STEP_REGEX + r\"\"\")(\\.|$)\"\"\", re.VERBOSE)\n  while path_remaining:\n    next_match = path_step_separator_re.match(path_remaining)\n    if next_match:\n      result.append(next_match.group(1))\n      path_remaining = path_remaining[next_match.end():]\n    else:\n      raise ValueError(\"Malformed path:  \" + path_source)\n  return Path(result)\n</code></pre>"},{"location":"api_docs/python/s2t/s2t/#struct2tensor.struct2tensor.create_prensor_from_descendant_nodes","title":"create_prensor_from_descendant_nodes","text":"<pre><code>create_prensor_from_descendant_nodes(\n    nodes: Mapping[Path, NodeTensor],\n) -&gt; Prensor\n</code></pre> <p>Create a prensor from a map of paths to NodeTensor.</p> <p>If a path is a key in the map, all prefixes of that path must be present.</p> PARAMETER DESCRIPTION <code>nodes</code> <p>A map from paths to NodeTensors.</p> <p> TYPE: <code>Mapping[Path, NodeTensor]</code> </p> RETURNS DESCRIPTION <code>Prensor</code> <p>A Prensor.</p> RAISES DESCRIPTION <code>ValueError</code> <p>if there is a prefix of a path missing.</p> Source code in <code>struct2tensor/prensor.py</code> <pre><code>def create_prensor_from_descendant_nodes(\n    nodes: Mapping[path.Path, NodeTensor]) -&gt; \"Prensor\":\n  \"\"\"Create a prensor from a map of paths to NodeTensor.\n\n  If a path is a key in the map, all prefixes of that path must be present.\n\n  Args:\n    nodes: A map from paths to NodeTensors.\n\n  Returns:\n    A Prensor.\n\n  Raises:\n    ValueError: if there is a prefix of a path missing.\n  \"\"\"\n  subexpressions = collections.OrderedDict()\n  root_node = None\n  for k, v in sorted(nodes.items()):\n    if not k:\n      root_node = v\n    else:\n      first_step = k.field_list[0]\n      suffix = k.suffix(1)\n      if first_step not in subexpressions:\n        subexpressions[first_step] = {}\n      subexpressions[first_step][suffix] = v\n  if root_node is None:\n    raise ValueError(\"No root found: {}\".format(str(nodes)))\n  return create_prensor_from_root_and_children(\n      root_node,\n      collections.OrderedDict((k, create_prensor_from_descendant_nodes(v))\n                              for k, v in subexpressions.items()))\n</code></pre>"},{"location":"api_docs/python/s2t/s2t/#struct2tensor.struct2tensor.create_prensor_from_root_and_children","title":"create_prensor_from_root_and_children","text":"<pre><code>create_prensor_from_root_and_children(\n    root: NodeTensor, children: Mapping[Step, Prensor]\n) -&gt; Prensor\n</code></pre> Source code in <code>struct2tensor/prensor.py</code> <pre><code>def create_prensor_from_root_and_children(\n    root: NodeTensor, children: Mapping[path.Step, Prensor]) -&gt; Prensor:\n  if isinstance(children, collections.OrderedDict):\n    ordered_children = children\n  else:\n    ordered_children = collections.OrderedDict(sorted(children.items()))\n  return Prensor(root, ordered_children)\n</code></pre>"},{"location":"api_docs/python/s2t/s2t/#struct2tensor.struct2tensor.get_default_options","title":"get_default_options","text":"<pre><code>get_default_options() -&gt; Options\n</code></pre> <p>Get the default options.</p> Source code in <code>struct2tensor/calculate_options.py</code> <pre><code>def get_default_options() -&gt; Options:\n  \"\"\"Get the default options.\"\"\"\n  return Options(ragged_checks=True, sparse_checks=True)\n</code></pre>"},{"location":"api_docs/python/s2t/s2t/#struct2tensor.struct2tensor.get_options_with_minimal_checks","title":"get_options_with_minimal_checks","text":"<pre><code>get_options_with_minimal_checks() -&gt; Options\n</code></pre> <p>Options for calculation with minimal runtime checks.</p> Source code in <code>struct2tensor/calculate_options.py</code> <pre><code>def get_options_with_minimal_checks() -&gt; Options:\n  \"\"\"Options for calculation with minimal runtime checks.\"\"\"\n  return Options(ragged_checks=False, sparse_checks=False)\n</code></pre>"},{"location":"api_docs/python/s2t/s2t/#struct2tensor.struct2tensor.get_ragged_tensor","title":"get_ragged_tensor","text":"<pre><code>get_ragged_tensor(\n    t: Prensor,\n    p: Path,\n    options: Options = get_default_options(),\n) -&gt; RaggedTensor\n</code></pre> <p>Get a ragged tensor for a path.</p> <p>All steps are represented in the ragged tensor.</p> PARAMETER DESCRIPTION <code>t</code> <p>The Prensor to extract tensors from.</p> <p> TYPE: <code>Prensor</code> </p> <code>p</code> <p>the path to a leaf node in <code>t</code>.</p> <p> TYPE: <code>Path</code> </p> <code>options</code> <p>used to pass options for calculating ragged tensors.</p> <p> TYPE: <code>Options</code> DEFAULT: <code>get_default_options()</code> </p> RETURNS DESCRIPTION <code>RaggedTensor</code> <p>A ragged tensor containing values of the leaf node, preserving the structure along the path. Raises an error if the path is not found.</p> Source code in <code>struct2tensor/prensor_util.py</code> <pre><code>@deprecation.deprecated(None, \"Use the Prensor class method instead.\")\ndef get_ragged_tensor(\n    t: prensor.Prensor,\n    p: path.Path,\n    options: calculate_options.Options = calculate_options.get_default_options(\n    )\n) -&gt; tf.RaggedTensor:\n  \"\"\"Get a ragged tensor for a path.\n\n  All steps are represented in the ragged tensor.\n\n  Args:\n    t: The Prensor to extract tensors from.\n    p: the path to a leaf node in `t`.\n    options: used to pass options for calculating ragged tensors.\n\n  Returns:\n    A ragged tensor containing values of the leaf node, preserving the\n      structure along the path. Raises an error if the path is not found.\n  \"\"\"\n  return t.get_ragged_tensor(p, options)\n</code></pre>"},{"location":"api_docs/python/s2t/s2t/#struct2tensor.struct2tensor.get_ragged_tensors","title":"get_ragged_tensors","text":"<pre><code>get_ragged_tensors(\n    t: Prensor, options: Options = get_default_options()\n) -&gt; Mapping[Path, RaggedTensor]\n</code></pre> <p>Gets ragged tensors for all the leaves of the prensor expression.</p> PARAMETER DESCRIPTION <code>t</code> <p>The Prensor to extract tensors from.</p> <p> TYPE: <code>Prensor</code> </p> <code>options</code> <p>used to pass options for calculating ragged tensors.</p> <p> TYPE: <code>Options</code> DEFAULT: <code>get_default_options()</code> </p> RETURNS DESCRIPTION <code>Mapping[Path, RaggedTensor]</code> <p>A map from paths to ragged tensors.</p> Source code in <code>struct2tensor/prensor_util.py</code> <pre><code>@deprecation.deprecated(None, \"Use the Prensor class method instead.\")\ndef get_ragged_tensors(\n    t: prensor.Prensor,\n    options: calculate_options.Options = calculate_options.get_default_options(\n    )\n) -&gt; Mapping[path.Path, tf.RaggedTensor]:\n  \"\"\"Gets ragged tensors for all the leaves of the prensor expression.\n\n  Args:\n    t: The Prensor to extract tensors from.\n    options: used to pass options for calculating ragged tensors.\n\n  Returns:\n    A map from paths to ragged tensors.\n  \"\"\"\n  return t.get_ragged_tensors(options)\n</code></pre>"},{"location":"api_docs/python/s2t/s2t/#struct2tensor.struct2tensor.get_sparse_tensor","title":"get_sparse_tensor","text":"<pre><code>get_sparse_tensor(\n    t: Prensor,\n    p: Path,\n    options: Options = get_default_options(),\n) -&gt; SparseTensor\n</code></pre> <p>Gets a sparse tensor for path p.</p> <p>Note that any optional fields are not registered as dimensions, as they can't be represented in a sparse tensor.</p> PARAMETER DESCRIPTION <code>t</code> <p>The Prensor to extract tensors from.</p> <p> TYPE: <code>Prensor</code> </p> <code>p</code> <p>The path to a leaf node in <code>t</code>.</p> <p> TYPE: <code>Path</code> </p> <code>options</code> <p>Currently unused.</p> <p> TYPE: <code>Options</code> DEFAULT: <code>get_default_options()</code> </p> RETURNS DESCRIPTION <code>SparseTensor</code> <p>A sparse tensor containing values of the leaf node, preserving the structure along the path. Raises an error if the path is not found.</p> Source code in <code>struct2tensor/prensor_util.py</code> <pre><code>@deprecation.deprecated(None, \"Use the Prensor class method instead.\")\ndef get_sparse_tensor(\n    t: prensor.Prensor,\n    p: path.Path,\n    options: calculate_options.Options = calculate_options.get_default_options(\n    )\n) -&gt; tf.SparseTensor:\n  \"\"\"Gets a sparse tensor for path p.\n\n  Note that any optional fields are not registered as dimensions, as they can't\n  be represented in a sparse tensor.\n\n  Args:\n    t: The Prensor to extract tensors from.\n    p: The path to a leaf node in `t`.\n    options: Currently unused.\n\n  Returns:\n    A sparse tensor containing values of the leaf node, preserving the\n      structure along the path. Raises an error if the path is not found.\n  \"\"\"\n  return t.get_sparse_tensor(p, options)\n</code></pre>"},{"location":"api_docs/python/s2t/s2t/#struct2tensor.struct2tensor.get_sparse_tensors","title":"get_sparse_tensors","text":"<pre><code>get_sparse_tensors(\n    t: Prensor, options: Options = get_default_options()\n) -&gt; Mapping[Path, SparseTensor]\n</code></pre> <p>Gets sparse tensors for all the leaves of the prensor expression.</p> PARAMETER DESCRIPTION <code>t</code> <p>The Prensor to extract tensors from.</p> <p> TYPE: <code>Prensor</code> </p> <code>options</code> <p>Currently unused.</p> <p> TYPE: <code>Options</code> DEFAULT: <code>get_default_options()</code> </p> RETURNS DESCRIPTION <code>Mapping[Path, SparseTensor]</code> <p>A map from paths to sparse tensors.</p> Source code in <code>struct2tensor/prensor_util.py</code> <pre><code>@deprecation.deprecated(None, \"Use the Prensor class method instead.\")\ndef get_sparse_tensors(\n    t: prensor.Prensor,\n    options: calculate_options.Options = calculate_options.get_default_options(\n    )\n) -&gt; Mapping[path.Path, tf.SparseTensor]:\n  \"\"\"Gets sparse tensors for all the leaves of the prensor expression.\n\n  Args:\n    t: The Prensor to extract tensors from.\n    options: Currently unused.\n\n  Returns:\n    A map from paths to sparse tensors.\n  \"\"\"\n  return t.get_sparse_tensors(options)\n</code></pre>"},{"location":"api_docs/python/s2t/s2t/#struct2tensor.struct2tensor-modules","title":"Modules","text":""},{"location":"examples/prensor_playground/","title":"Your structured data into Tensorflow.","text":"In\u00a0[\u00a0]: Copied! <pre>#@test {\"skip\": true} \n# install struct2tensor\n!pip install struct2tensor\n# graphviz for pretty output\n!pip install graphviz\n</pre> #@test {\"skip\": true}  # install struct2tensor !pip install struct2tensor # graphviz for pretty output !pip install graphviz <pre>Requirement already satisfied: struct2tensor in /usr/local/lib/python3.6/dist-packages (0.0.1.dev6)\nRequirement already satisfied: tensorflow-metadata&gt;=0.13.0 in /usr/local/lib/python3.6/dist-packages (from struct2tensor) (0.15.1)\nRequirement already satisfied: protobuf&gt;=3.8.0 in /usr/local/lib/python3.6/dist-packages (from struct2tensor) (3.10.0)\nRequirement already satisfied: tensorflow==1.15.0 in /usr/local/lib/python3.6/dist-packages (from struct2tensor) (1.15.0)\nRequirement already satisfied: googleapis-common-protos in /usr/local/lib/python3.6/dist-packages (from tensorflow-metadata&gt;=0.13.0-&gt;struct2tensor) (1.6.0)\nRequirement already satisfied: six&gt;=1.9 in /usr/local/lib/python3.6/dist-packages (from protobuf&gt;=3.8.0-&gt;struct2tensor) (1.12.0)\nRequirement already satisfied: setuptools in /usr/local/lib/python3.6/dist-packages (from protobuf&gt;=3.8.0-&gt;struct2tensor) (42.0.1)\nRequirement already satisfied: numpy&lt;2.0,&gt;=1.16.0 in /usr/local/lib/python3.6/dist-packages (from tensorflow==1.15.0-&gt;struct2tensor) (1.17.4)\nRequirement already satisfied: opt-einsum&gt;=2.3.2 in /usr/local/lib/python3.6/dist-packages (from tensorflow==1.15.0-&gt;struct2tensor) (3.1.0)\nRequirement already satisfied: keras-preprocessing&gt;=1.0.5 in /usr/local/lib/python3.6/dist-packages (from tensorflow==1.15.0-&gt;struct2tensor) (1.1.0)\nRequirement already satisfied: termcolor&gt;=1.1.0 in /usr/local/lib/python3.6/dist-packages (from tensorflow==1.15.0-&gt;struct2tensor) (1.1.0)\nRequirement already satisfied: wheel&gt;=0.26 in /usr/local/lib/python3.6/dist-packages (from tensorflow==1.15.0-&gt;struct2tensor) (0.33.6)\nRequirement already satisfied: grpcio&gt;=1.8.6 in /usr/local/lib/python3.6/dist-packages (from tensorflow==1.15.0-&gt;struct2tensor) (1.15.0)\nRequirement already satisfied: tensorboard&lt;1.16.0,&gt;=1.15.0 in /usr/local/lib/python3.6/dist-packages (from tensorflow==1.15.0-&gt;struct2tensor) (1.15.0)\nRequirement already satisfied: keras-applications&gt;=1.0.8 in /usr/local/lib/python3.6/dist-packages (from tensorflow==1.15.0-&gt;struct2tensor) (1.0.8)\nRequirement already satisfied: tensorflow-estimator==1.15.1 in /usr/local/lib/python3.6/dist-packages (from tensorflow==1.15.0-&gt;struct2tensor) (1.15.1)\nRequirement already satisfied: google-pasta&gt;=0.1.6 in /usr/local/lib/python3.6/dist-packages (from tensorflow==1.15.0-&gt;struct2tensor) (0.1.8)\nRequirement already satisfied: gast==0.2.2 in /usr/local/lib/python3.6/dist-packages (from tensorflow==1.15.0-&gt;struct2tensor) (0.2.2)\nRequirement already satisfied: wrapt&gt;=1.11.1 in /usr/local/lib/python3.6/dist-packages (from tensorflow==1.15.0-&gt;struct2tensor) (1.11.2)\nRequirement already satisfied: absl-py&gt;=0.7.0 in /usr/local/lib/python3.6/dist-packages (from tensorflow==1.15.0-&gt;struct2tensor) (0.8.1)\nRequirement already satisfied: astor&gt;=0.6.0 in /usr/local/lib/python3.6/dist-packages (from tensorflow==1.15.0-&gt;struct2tensor) (0.8.0)\nRequirement already satisfied: werkzeug&gt;=0.11.15 in /usr/local/lib/python3.6/dist-packages (from tensorboard&lt;1.16.0,&gt;=1.15.0-&gt;tensorflow==1.15.0-&gt;struct2tensor) (0.16.0)\nRequirement already satisfied: markdown&gt;=2.6.8 in /usr/local/lib/python3.6/dist-packages (from tensorboard&lt;1.16.0,&gt;=1.15.0-&gt;tensorflow==1.15.0-&gt;struct2tensor) (3.1.1)\nRequirement already satisfied: h5py in /usr/local/lib/python3.6/dist-packages (from keras-applications&gt;=1.0.8-&gt;tensorflow==1.15.0-&gt;struct2tensor) (2.8.0)\nRequirement already satisfied: graphviz in /usr/local/lib/python3.6/dist-packages (0.10.1)\n</pre> In\u00a0[\u00a0]: Copied! <pre>import base64\nimport numpy as np\nimport pprint\nimport os\nimport tensorflow\nfrom graphviz import Source\n\nimport tensorflow as tf\n\nfrom IPython.display import Image\nfrom IPython.lib import pretty\n\nimport struct2tensor as s2t\nfrom struct2tensor.test import test_pb2\nfrom google.protobuf import text_format\n\n\ndef _display(graph):\n  \"\"\"Renders a graphviz digraph.\"\"\"\n  s = Source(graph)\n  s.format='svg'\n  return s\n    \n\ndef _create_query_from_text_sessions(text_sessions):\n  \"\"\"Creates a struct2tensor query from a list of pbtxt of struct2tensor.test.Session.\"\"\"\n  sessions = tf.constant([\n      text_format.Merge(\n          text_session, \n          test_pb2.Session()\n      ).SerializeToString()\n      for text_session in text_sessions\n  ])\n  return s2t.create_expression_from_proto(\n    sessions, test_pb2.Session.DESCRIPTOR)\n\ndef _prensor_pretty_printer(prensor, p, cycle):\n  \"\"\"Pretty printing function for struct2tensor.prensor.Prensor\"\"\"\n  pretty.pprint(prensor.get_sparse_tensors())\n\ndef _sp_pretty_printer(sp, p, cycle):\n  \"\"\"Pretty printing function for SparseTensor.\"\"\"\n\n  del cycle\n  p.begin_group(4, \"SparseTensor(\")\n  p.text(\"values={}, \".format(sp.values.numpy().tolist()))\n  p.text(\"dense_shape={}, \".format(sp.dense_shape.numpy().tolist()))\n  p.break_()\n  p.text(\"indices={}\".format(sp.indices.numpy().tolist()))\n  p.end_group(4, \")\")\n\n\npretty.for_type(tf.SparseTensor, _sp_pretty_printer)\npretty.for_type(s2t.Prensor, _prensor_pretty_printer)\n\n_pretty_print = pretty.pprint\n\nprint(\"type-specific pretty printing ready to go\")\n</pre> import base64 import numpy as np import pprint import os import tensorflow from graphviz import Source  import tensorflow as tf  from IPython.display import Image from IPython.lib import pretty  import struct2tensor as s2t from struct2tensor.test import test_pb2 from google.protobuf import text_format   def _display(graph):   \"\"\"Renders a graphviz digraph.\"\"\"   s = Source(graph)   s.format='svg'   return s       def _create_query_from_text_sessions(text_sessions):   \"\"\"Creates a struct2tensor query from a list of pbtxt of struct2tensor.test.Session.\"\"\"   sessions = tf.constant([       text_format.Merge(           text_session,            test_pb2.Session()       ).SerializeToString()       for text_session in text_sessions   ])   return s2t.create_expression_from_proto(     sessions, test_pb2.Session.DESCRIPTOR)  def _prensor_pretty_printer(prensor, p, cycle):   \"\"\"Pretty printing function for struct2tensor.prensor.Prensor\"\"\"   pretty.pprint(prensor.get_sparse_tensors())  def _sp_pretty_printer(sp, p, cycle):   \"\"\"Pretty printing function for SparseTensor.\"\"\"    del cycle   p.begin_group(4, \"SparseTensor(\")   p.text(\"values={}, \".format(sp.values.numpy().tolist()))   p.text(\"dense_shape={}, \".format(sp.dense_shape.numpy().tolist()))   p.break_()   p.text(\"indices={}\".format(sp.indices.numpy().tolist()))   p.end_group(4, \")\")   pretty.for_type(tf.SparseTensor, _sp_pretty_printer) pretty.for_type(s2t.Prensor, _prensor_pretty_printer)  _pretty_print = pretty.pprint  print(\"type-specific pretty printing ready to go\") <pre>type-specific pretty printing ready to go\n</pre> In\u00a0[\u00a0]: Copied! <pre>@tf.function(input_signature=[tf.TensorSpec(shape=(None), dtype=tf.string)], autograph=False)\ndef parse_session(serialized_sessions):\n  \"\"\"A TF function parsing a batch of serialized Session protos into tensors.\n\n  It is a TF graph that takes one 1-D tensor as input, and outputs a\n  Dict[str, tf.SparseTensor]\n  \"\"\"\n  query = s2t.create_expression_from_proto(\n      serialized_sessions, test_pb2.Session.DESCRIPTOR)\n  # Move all the fields of our interest to under \"event\".  \n  query = query.promote_and_broadcast({\n          \"session_feature\": \"session_info.session_feature\",\n          \"action_number_of_views\": \"event.action.number_of_views\" },\n          \"event\")\n  # Specify \"event\" to be examples.\n  query = query.reroot(\"event\")\n  # Extract all the fields of our interest.\n  projection = query.project([\"session_feature\", \"query\", \"action_number_of_views\"]) \n  prensors = s2t.calculate_prensors([projection])\n    \n  output_sparse_tensors = {}\n  for prensor in prensors:\n    path_to_tensor = prensor.get_sparse_tensors()\n    output_sparse_tensors.update({str(k): v for k, v in path_to_tensor.items()})\n  \n  return output_sparse_tensors\n\nprint(\"Defined the workhorse func: (structured data at rest) -&gt; (tensors)\")\n</pre> @tf.function(input_signature=[tf.TensorSpec(shape=(None), dtype=tf.string)], autograph=False) def parse_session(serialized_sessions):   \"\"\"A TF function parsing a batch of serialized Session protos into tensors.    It is a TF graph that takes one 1-D tensor as input, and outputs a   Dict[str, tf.SparseTensor]   \"\"\"   query = s2t.create_expression_from_proto(       serialized_sessions, test_pb2.Session.DESCRIPTOR)   # Move all the fields of our interest to under \"event\".     query = query.promote_and_broadcast({           \"session_feature\": \"session_info.session_feature\",           \"action_number_of_views\": \"event.action.number_of_views\" },           \"event\")   # Specify \"event\" to be examples.   query = query.reroot(\"event\")   # Extract all the fields of our interest.   projection = query.project([\"session_feature\", \"query\", \"action_number_of_views\"])    prensors = s2t.calculate_prensors([projection])        output_sparse_tensors = {}   for prensor in prensors:     path_to_tensor = prensor.get_sparse_tensors()     output_sparse_tensors.update({str(k): v for k, v in path_to_tensor.items()})      return output_sparse_tensors  print(\"Defined the workhorse func: (structured data at rest) -&gt; (tensors)\") <pre>Defined the workhorse func: (structured data at rest) -&gt; (tensors)\n</pre> In\u00a0[\u00a0]: Copied! <pre>serialized_sessions = tf.constant([\n    text_format.Merge(\n        \"\"\"\n        session_info {\n          session_duration_sec: 1.0\n          session_feature: \"foo\"\n        }\n        event {\n          query: \"Hello\"\n          action {\n            number_of_views: 1\n          }\n          action {\n          }\n        }\n        event {\n          query: \"world\"\n          action {\n            number_of_views: 2\n          }\n          action {\n            number_of_views: 3\n          }\n        }\n        \"\"\",\n        test_pb2.Session()\n    ).SerializeToString()\n])\n\n_pretty_print(parse_session(serialized_sessions))\n</pre> serialized_sessions = tf.constant([     text_format.Merge(         \"\"\"         session_info {           session_duration_sec: 1.0           session_feature: \"foo\"         }         event {           query: \"Hello\"           action {             number_of_views: 1           }           action {           }         }         event {           query: \"world\"           action {             number_of_views: 2           }           action {             number_of_views: 3           }         }         \"\"\",         test_pb2.Session()     ).SerializeToString() ])  _pretty_print(parse_session(serialized_sessions)) <pre>{'action_number_of_views': SparseTensor(values=[1, 2, 3], dense_shape=[2, 2], \n     indices=[[0, 0], [1, 0], [1, 1]]),\n 'query': SparseTensor(values=[b'Hello', b'world'], dense_shape=[2], \n     indices=[[0], [1]]),\n 'session_feature': SparseTensor(values=[b'foo', b'foo'], dense_shape=[2, 1], \n     indices=[[0, 0], [1, 0]])}\n</pre> <p>See how we went from our pre-pipeline data (the Protobuffer) all the way to the structured data, packed into <code>SparseTensor</code>s?</p> In\u00a0[\u00a0]: Copied! <pre>#@title { display-mode: \"form\" }\n#@test {\"skip\": true} \n\n_display(\"\"\"\ndigraph {\n  root -&gt; session [label=\"*\"];\n  session -&gt; event [label=\"*\"];\n  session -&gt; session_id [label=\"?\"];\n  event -&gt; action [label=\"*\"];\n  event -&gt; query_token [label=\"*\"]\n  action -&gt; number_of_views [label=\"?\"];\n}\n\"\"\")\n</pre> #@title { display-mode: \"form\" } #@test {\"skip\": true}   _display(\"\"\" digraph {   root -&gt; session [label=\"*\"];   session -&gt; event [label=\"*\"];   session -&gt; session_id [label=\"?\"];   event -&gt; action [label=\"*\"];   event -&gt; query_token [label=\"*\"]   action -&gt; number_of_views [label=\"?\"]; } \"\"\")  Out[\u00a0]: <p>We will be using visualizations like this to demostrate struct2tensor queries later.</p> <p>Note:</p> <ul> <li>The \"*\" on the edge means the pointed node has repeated values; while the \"?\" means it has an optional value.</li> <li>There is always a \"root\" node whose only child is the root of the structure. Note that it's \"repeated\" because one struct2tensorTree can represent multiple instances of a structure.</li> </ul> In\u00a0[\u00a0]: Copied! <pre>#@title { display-mode: \"form\" }\n#@test {\"skip\": true} \n\n_display(\"\"\"\ndigraph {\n  session_session_id [color=\"red\"];\n  root -&gt; session [label=\"*\"];\n  session -&gt; event [label=\"*\"];\n  session -&gt; session_id [label=\"?\"];\n  event -&gt; action [label=\"*\"];\n  event -&gt; session_session_id [label=\"?\"];\n  event -&gt; query_token [label=\"*\"];\n  action -&gt; number_of_views [label=\"?\"];\n}\n\"\"\")\n</pre> #@title { display-mode: \"form\" } #@test {\"skip\": true}   _display(\"\"\" digraph {   session_session_id [color=\"red\"];   root -&gt; session [label=\"*\"];   session -&gt; event [label=\"*\"];   session -&gt; session_id [label=\"?\"];   event -&gt; action [label=\"*\"];   event -&gt; session_session_id [label=\"?\"];   event -&gt; query_token [label=\"*\"];   action -&gt; number_of_views [label=\"?\"]; } \"\"\")  Out[\u00a0]: <p>We will talk about common struct2tensor queries in later sections.</p> In\u00a0[\u00a0]: Copied! <pre>query = _create_query_from_text_sessions(['''\n  event { action { number_of_views: 1} action { number_of_views: 2} action {} }\n  event {}\n  ''', '''\n  event { action { number_of_views: 3} }\n  ''']\n  ).project([\"event.action.number_of_views\"])\n\nprensor = s2t.calculate_prensors([query])\npretty.pprint(prensor)\n</pre> query = _create_query_from_text_sessions(['''   event { action { number_of_views: 1} action { number_of_views: 2} action {} }   event {}   ''', '''   event { action { number_of_views: 3} }   ''']   ).project([\"event.action.number_of_views\"])  prensor = s2t.calculate_prensors([query]) pretty.pprint(prensor) <pre>[{event.action.number_of_views: SparseTensor(values=[1, 2, 3], dense_shape=[2, 2, 3], \n     indices=[[0, 0, 0], [0, 0, 1], [1, 0, 0]])}\n]\n</pre> <p>struct2tensor's internal data model is closer to the above \"nested lists\" abstraction and sometimes it's easier to reason with \"nested lists\" than with <code>SparseTensor</code>s.</p> <p>Recently, <code>tf.RaggedTensor</code> was introduced to represent nested lists exactly. We are working on adding support for projecting into ragged tensors.</p> In\u00a0[\u00a0]: Copied! <pre>#@title { display-mode: \"form\" }\n#@test {\"skip\": true} \n\n_display('''\ndigraph {\n  root -&gt; session [label=\"*\"];\n  session -&gt; event [label=\"*\"];\n  event -&gt; query_token [label=\"*\"];\n}\n''')\n</pre> #@title { display-mode: \"form\" } #@test {\"skip\": true}   _display(''' digraph {   root -&gt; session [label=\"*\"];   session -&gt; event [label=\"*\"];   event -&gt; query_token [label=\"*\"]; } ''') Out[\u00a0]: <p><code>promote(source_path=\"event.query_token\", new_field_name=\"event_query_token\")</code></p> In\u00a0[\u00a0]: Copied! <pre>#@title { display-mode: \"form\" }\n#@test {\"skip\": true} \n\n_display('''\ndigraph {\n  event_query_token [color=\"red\"];\n  root -&gt; session [label=\"*\"];\n  session -&gt; event [label=\"*\"];\n  session -&gt; event_query_token [label=\"*\"];\n  event -&gt; query_token [label=\"*\"];\n}\n''')\n</pre> #@title { display-mode: \"form\" } #@test {\"skip\": true}   _display(''' digraph {   event_query_token [color=\"red\"];   root -&gt; session [label=\"*\"];   session -&gt; event [label=\"*\"];   session -&gt; event_query_token [label=\"*\"];   event -&gt; query_token [label=\"*\"]; } ''') Out[\u00a0]: In\u00a0[\u00a0]: Copied! <pre>query = (_create_query_from_text_sessions([\n\"\"\"\nevent {\n  query_token: \"abc\"\n  query_token: \"def\"\n}\nevent {\n  query_token: \"ghi\"\n}\n\"\"\"])\n        .promote(source_path=\"event.query_token\", new_field_name=\"event_query_token\")\n        .project([\"event_query_token\"]))\n\nprensor = s2t.calculate_prensors([query])\n\n_pretty_print(prensor)\n</pre> query = (_create_query_from_text_sessions([ \"\"\" event {   query_token: \"abc\"   query_token: \"def\" } event {   query_token: \"ghi\" } \"\"\"])         .promote(source_path=\"event.query_token\", new_field_name=\"event_query_token\")         .project([\"event_query_token\"]))  prensor = s2t.calculate_prensors([query])  _pretty_print(prensor) <pre>[{event_query_token: SparseTensor(values=[b'abc', b'def', b'ghi'], dense_shape=[1, 3], \n     indices=[[0, 0], [0, 1], [0, 2]])}\n]\n</pre> <p>The projected structure is like:</p> <pre><code>{\n  # this is under Session.\n  event_query_token: \"abc\"\n  event_query_token: \"def\"\n  event_query_token: \"ghi\"\n}\n</code></pre> In\u00a0[\u00a0]: Copied! <pre>#@title { display-mode: \"form\" }\n#@test {\"skip\": true} \n\n_display('''\ndigraph {\n  root -&gt; session [label=\"*\"];\n  session -&gt; session_id [label=\"?\"];\n  session -&gt; event [label=\"*\"];\n}\n''')\n</pre> #@title { display-mode: \"form\" } #@test {\"skip\": true}   _display(''' digraph {   root -&gt; session [label=\"*\"];   session -&gt; session_id [label=\"?\"];   session -&gt; event [label=\"*\"]; } ''') Out[\u00a0]: <p><code>broadcast(source_path=\"session_id\", sibling_field=\"event\", new_field_name=\"session_session_id\")</code></p> In\u00a0[\u00a0]: Copied! <pre>#@title { display-mode: \"form\" }\n#@test {\"skip\": true} \n\n_display('''\ndigraph {\n  session_session_id [color=\"red\"];\n  root -&gt; session [label=\"*\"];\n  session -&gt; session_id [label=\"?\"];\n  session -&gt; event [label=\"*\"];\n  event -&gt; session_session_id [label=\"?\"];\n}\n''')\n</pre> #@title { display-mode: \"form\" } #@test {\"skip\": true}   _display(''' digraph {   session_session_id [color=\"red\"];   root -&gt; session [label=\"*\"];   session -&gt; session_id [label=\"?\"];   session -&gt; event [label=\"*\"];   event -&gt; session_session_id [label=\"?\"]; } ''') Out[\u00a0]: In\u00a0[\u00a0]: Copied! <pre>query = (_create_query_from_text_sessions([\n\"\"\"\nsession_id: 8\nevent { }\nevent { }\n\"\"\"])\n        .broadcast(source_path=\"session_id\",\n                   sibling_field=\"event\",\n                   new_field_name=\"session_session_id\")\n        .project([\"event.session_session_id\"]))\n\nprensor = s2t.calculate_prensors([query])\n_pretty_print(prensor)\n</pre> query = (_create_query_from_text_sessions([ \"\"\" session_id: 8 event { } event { } \"\"\"])         .broadcast(source_path=\"session_id\",                    sibling_field=\"event\",                    new_field_name=\"session_session_id\")         .project([\"event.session_session_id\"]))  prensor = s2t.calculate_prensors([query]) _pretty_print(prensor) <pre>[{event.session_session_id: SparseTensor(values=[8, 8], dense_shape=[1, 2], \n     indices=[[0, 0], [0, 1]])}\n]\n</pre> <p>The projected structure is like:</p> <pre><code>{\n  event {\n    session_session_id: 8\n  }\n  event {\n    session_session_id: 8\n  }\n}\n</code></pre> <pre><code>promote_and_broadcast(\n    path_dictionary={\n        'session_info_duration_sec': 'session_info.session_duration_sec'},\n    dest_path_parent='event.action')\n</code></pre> <p>is equivalent to:</p> <pre><code>promote(source_path='session_info.session_duration_sec',\n    new_field_name='anonymous_field1')\n\nbroadcast(source_path='anonymous_field1',\n    sibling_field='event.action',\n    new_field_name='session_info_duration_sec')\n</code></pre> In\u00a0[\u00a0]: Copied! <pre>query = (_create_query_from_text_sessions([\n\"\"\"\nsession_id: 8\n\"\"\",\n\"\"\"\nsession_id: 9\n\"\"\"])\n        .map_field_values(\"session_id\", lambda x: tf.add(x, 1), dtype=tf.int64,\n                          new_field_name=\"session_id_plus_one\")\n        .project([\"session_id_plus_one\"]))\n    \nprensor = s2t.calculate_prensors([query])\n\n_pretty_print(prensor)\n</pre> query = (_create_query_from_text_sessions([ \"\"\" session_id: 8 \"\"\", \"\"\" session_id: 9 \"\"\"])         .map_field_values(\"session_id\", lambda x: tf.add(x, 1), dtype=tf.int64,                           new_field_name=\"session_id_plus_one\")         .project([\"session_id_plus_one\"]))      prensor = s2t.calculate_prensors([query])  _pretty_print(prensor) <pre>[{session_id_plus_one: SparseTensor(values=[9, 10], dense_shape=[2], \n     indices=[[0], [1]])}\n]\n</pre> In\u00a0[\u00a0]: Copied! <pre>#@title { display-mode: \"form\" }\n#@test {\"skip\": true} \n\n_display('''\ndigraph {\n  root -&gt; session [label=\"*\"];\n  session -&gt; session_id [label=\"?\"];\n  session -&gt; event [label=\"*\"];\n  event -&gt; event_id [label=\"?\"];\n}\n''')\n</pre> #@title { display-mode: \"form\" } #@test {\"skip\": true}   _display(''' digraph {   root -&gt; session [label=\"*\"];   session -&gt; session_id [label=\"?\"];   session -&gt; event [label=\"*\"];   event -&gt; event_id [label=\"?\"]; } ''') Out[\u00a0]: <p><code>reroot(\"event\")</code></p> In\u00a0[\u00a0]: Copied! <pre>#@title { display-mode: \"form\" }\n#@test {\"skip\": true} \n\n_display('''\ndigraph {\n  root -&gt; event [label=\"*\"];\n  event -&gt; event_id [label=\"?\"];\n}\n''')\n</pre> #@title { display-mode: \"form\" } #@test {\"skip\": true}   _display(''' digraph {   root -&gt; event [label=\"*\"];   event -&gt; event_id [label=\"?\"]; } ''') Out[\u00a0]: In\u00a0[\u00a0]: Copied! <pre>#@title { display-mode: \"form\" }\ntext_protos = [\"\"\"\nsession_id: 1\nevent {\n  event_id: \"a\"\n}\nevent {\n  event_id: \"b\"\n}\n\"\"\",\n\"\"\"\nsession_id: 2\n\"\"\",\n\"\"\"\nsession_id: 3\nevent {\n  event_id: \"c\"\n}\n\"\"\"\n]\nprint(\"\"\"Assume the following Sessions: \"\"\")\nprint([text_format.Merge(p, s2t.test.test_pb2.Session()) for p in text_protos])\nprint(\"\\n\")\nreroot_example_query = _create_query_from_text_sessions(text_protos)\n\nprint(\"\"\"project([\"event.event_id\"]) before reroot() (the batch dimension is the index to sessions):\"\"\")\n_pretty_print(s2t.calculate_prensors([reroot_example_query.project([\"event.event_id\"])]))\nprint(\"\\n\")\nprint(\"\"\"project([\"event_id\"]) after reroot() (the batch dimension becomes the index to events):\"\"\")\n_pretty_print(s2t.calculate_prensors([reroot_example_query.reroot(\"event\").project([\"event_id\"])]))\n</pre> #@title { display-mode: \"form\" } text_protos = [\"\"\" session_id: 1 event {   event_id: \"a\" } event {   event_id: \"b\" } \"\"\", \"\"\" session_id: 2 \"\"\", \"\"\" session_id: 3 event {   event_id: \"c\" } \"\"\" ] print(\"\"\"Assume the following Sessions: \"\"\") print([text_format.Merge(p, s2t.test.test_pb2.Session()) for p in text_protos]) print(\"\\n\") reroot_example_query = _create_query_from_text_sessions(text_protos)  print(\"\"\"project([\"event.event_id\"]) before reroot() (the batch dimension is the index to sessions):\"\"\") _pretty_print(s2t.calculate_prensors([reroot_example_query.project([\"event.event_id\"])])) print(\"\\n\") print(\"\"\"project([\"event_id\"]) after reroot() (the batch dimension becomes the index to events):\"\"\") _pretty_print(s2t.calculate_prensors([reroot_example_query.reroot(\"event\").project([\"event_id\"])])) <pre>Assume the following Sessions: \n[session_id: 1\nevent {\n  event_id: \"a\"\n}\nevent {\n  event_id: \"b\"\n}\n, session_id: 2\n, session_id: 3\nevent {\n  event_id: \"c\"\n}\n]\n\n\nproject([\"event.event_id\"]) before reroot() (the batch dimension is the index to sessions):\n[{event.event_id: SparseTensor(values=[b'a', b'b', b'c'], dense_shape=[3, 2], \n     indices=[[0, 0], [0, 1], [2, 0]])}\n]\n\n\nproject([\"event_id\"]) after reroot() (the batch dimension becomes the index to events):\n[{event_id: SparseTensor(values=[b'a', b'b', b'c'], dense_shape=[3], \n     indices=[[0], [1], [2]])}\n]\n</pre> In\u00a0[6]: Copied! <pre>tf_example = text_format.Parse(\"\"\"\nfeatures {\n  feature {\n    key: \"my_feature\"\n    value {\n      float_list {\n        value: 1.0\n      }\n    }\n  }\n  feature {\n    key: \"other_feature\"\n    value {\n      bytes_list {\n        value: \"my_val\"\n      }\n    }\n  }\n}\n\"\"\", tf.train.Example())\n\nquery = s2t.create_expression_from_proto(\n    tf_example.SerializeToString(), tf.train.Example.DESCRIPTOR)\nquery = query.promote_and_broadcast({'my_new_feature': \"features.feature[my_feature].float_list.value\", \"other_new_feature\": \"features.feature[other_feature].bytes_list.value\"}, \"features\")\nquery = query.project([\"features.my_new_feature\", \"features.other_new_feature\"])\n[prensor] = s2t.calculate_prensors([query])\nragged_tensors = prensor.get_ragged_tensors()\n\nprint(ragged_tensors)\n</pre> tf_example = text_format.Parse(\"\"\" features {   feature {     key: \"my_feature\"     value {       float_list {         value: 1.0       }     }   }   feature {     key: \"other_feature\"     value {       bytes_list {         value: \"my_val\"       }     }   } } \"\"\", tf.train.Example())  query = s2t.create_expression_from_proto(     tf_example.SerializeToString(), tf.train.Example.DESCRIPTOR) query = query.promote_and_broadcast({'my_new_feature': \"features.feature[my_feature].float_list.value\", \"other_new_feature\": \"features.feature[other_feature].bytes_list.value\"}, \"features\") query = query.project([\"features.my_new_feature\", \"features.other_new_feature\"]) [prensor] = s2t.calculate_prensors([query]) ragged_tensors = prensor.get_ragged_tensors()  print(ragged_tensors)  <pre>{features.my_new_feature: &lt;tf.RaggedTensor [[[1.0]]]&gt;, features.other_new_feature: &lt;tf.RaggedTensor [[[b'my_val']]]&gt;}\n</pre> In\u00a0[\u00a0]: Copied! <pre># Download our sample data file from the struct2tensor repository. The desciption of the data is below.\n#@test {\"skip\": true} \n\n!curl -o dremel_example.parquet 'https://raw.githubusercontent.com/google/struct2tensor/master/struct2tensor/testdata/parquet_testdata/dremel_example.parquet'\n</pre> # Download our sample data file from the struct2tensor repository. The desciption of the data is below. #@test {\"skip\": true}   !curl -o dremel_example.parquet 'https://raw.githubusercontent.com/google/struct2tensor/master/struct2tensor/testdata/parquet_testdata/dremel_example.parquet' <pre>  % Total    % Received % Xferd  Average Speed   Time    Time     Time  Current\n                                 Dload  Upload   Total   Spent    Left  Speed\n100  1657  100  1657    0     0   8122      0 --:--:-- --:--:-- --:--:--  8122\n</pre> In\u00a0[\u00a0]: Copied! <pre>#@test {\"skip\": true} \n\nfrom struct2tensor import expression_impl\n\nfilenames = [\"dremel_example.parquet\"]\nbatch_size = 1\n\nexp = s2t.expression_impl.parquet.create_expression_from_parquet_file(filenames)\nnew_exp = exp.promote_and_broadcast({\"new_field\": \"Links.Forward\"}, \"Name\")\nproj_exp = new_exp.project([\"Name.new_field\"])\nproj_exp_needed = exp.project([\"Name.Url\"]) \n# Please note that currently, proj_exp_needed needs to be passed into calculate.\n# This is due to the way data is stored in parquet (values and repetition &amp; \n# definition levels). To construct the node for \"Name\", we need to read the \n# values of a column containing \"Name\".\npqds = s2t.expression_impl.parquet.calculate_parquet_values([proj_exp, proj_exp_needed], exp, \n                                        filenames, batch_size)\n\nfor prensors in pqds:\n  new_field_prensor = prensors[0]\n  print(\"============================\")\n  print(\"Schema of new_field prensor: \")\n  print(new_field_prensor)\n  print(\"\\nSparse tensor representation: \")\n  pretty.pprint(new_field_prensor)\nprint(\"============================\")\n</pre> #@test {\"skip\": true}   from struct2tensor import expression_impl  filenames = [\"dremel_example.parquet\"] batch_size = 1  exp = s2t.expression_impl.parquet.create_expression_from_parquet_file(filenames) new_exp = exp.promote_and_broadcast({\"new_field\": \"Links.Forward\"}, \"Name\") proj_exp = new_exp.project([\"Name.new_field\"]) proj_exp_needed = exp.project([\"Name.Url\"])  # Please note that currently, proj_exp_needed needs to be passed into calculate. # This is due to the way data is stored in parquet (values and repetition &amp;  # definition levels). To construct the node for \"Name\", we need to read the  # values of a column containing \"Name\". pqds = s2t.expression_impl.parquet.calculate_parquet_values([proj_exp, proj_exp_needed], exp,                                          filenames, batch_size)  for prensors in pqds:   new_field_prensor = prensors[0]   print(\"============================\")   print(\"Schema of new_field prensor: \")   print(new_field_prensor)   print(\"\\nSparse tensor representation: \")   pretty.pprint(new_field_prensor) print(\"============================\") <pre>/usr/local/lib/python3.6/dist-packages/struct2tensor/expression_impl/parquet.py:65: FutureWarning: The 'field_by_name' method is deprecated, use 'field' instead\n  [arrow_schema.field_by_name(name) for name in arrow_schema.names]))\n/usr/local/lib/python3.6/dist-packages/struct2tensor/expression_impl/parquet.py:396: FutureWarning: The 'field_by_name' method is deprecated, use 'field' instead\n  for step in curr_steps_as_set\n</pre> <pre>============================\nSchema of new_field prensor: \nRootNodeTensor root\n  repeated ChildNodeTensor Name\n    repeated &lt;dtype: 'int64'&gt; new_field\n\nSparse tensor representation: \n{Name.new_field: SparseTensor(values=[20, 40, 60, 20, 40, 60, 20, 40, 60], dense_shape=[1, 3, 3], \n     indices=[[0, 0, 0], [0, 0, 1], [0, 0, 2], [0, 1, 0], [0, 1, 1], [0, 1, 2], [0, 2, 0], [0, 2, 1], [0, 2, 2]])}\n\n============================\nSchema of new_field prensor: \nRootNodeTensor root\n  repeated ChildNodeTensor Name\n    repeated &lt;dtype: 'int64'&gt; new_field\n\nSparse tensor representation: \n{Name.new_field: SparseTensor(values=[80], dense_shape=[1, 1, 1], \n     indices=[[0, 0, 0]])}\n\n============================\n</pre>"},{"location":"examples/prensor_playground/#your-structured-data-into-tensorflow","title":"Your structured data into Tensorflow.\u00b6","text":"<p>ML training often expects flat data, like a line in a CSV. tf.Example was designed to represent flat data. But the data you care about and want to predict things about usually starts out structured.</p> <p>Over and over again you have to write transform code that turns your structured data into Tensors. This repetitive transform code must be rewritten over and over for all your ML pipelines both for training and serving! And it lets bugs slip into your ML pipeline.</p> <p><code>struct2tensor</code> lets you take advantage of structured data within your ML pipelines. It is:</p> <ul> <li>for: ML Engineers</li> <li>who: train models on data that starts out structured</li> <li>it is: a python library</li> <li>that: transforms your structured data into model-friendly (Sparse, Raggged, Dense, ...) tensors hermetically within your model</li> <li>unlike: writing custom transforms over and over for training and serving.</li> </ul> <p></p>"},{"location":"examples/prensor_playground/#demo-example","title":"Demo example\u00b6","text":"<p>Suppose we have this structured data we want to train on. The source example data format is a protobuff. <code>struct2tensor</code> was built internally and works on protobuffers now. It can be extended to parquet, json, etc. in the future.</p> <pre><code># e.g. a web session\nmessage Session{\n  message SessionInfo {\n    string session_feature = 1;\n    double session_duration_sec = 2;\n  }\n  SessionInfo session_info = 1;\n  message Event {\n    string query = 1;\n    message Action {\n      int number_of_views = 1;\n    }\n    repeated Action action = 2;\n  }\n  repeated Event event = 2;\n}\n</code></pre> <p>In 3 steps we'll extract the fields we want with <code>struct2tensor</code>. We'll end up with batch-aligned <code>SparseTensors</code>:</p> <ol> <li>Tell our model what examples we care about, e.g.  <code>event</code> (submessage <code>Session::Event</code>).</li> <li>Pick the proto fields that we think are good features, say:</li> </ol> <ul> <li><code>session_info.session_feature</code></li> <li><code>event.query</code></li> </ul> <ol> <li>Identify the label to predict, say  <code>event.action.number_of_views</code>  (the actual label could be sum(action.number_of_views for action in event))</li> </ol> <p>Then we can build a struct2tensor query that:</p> <ul> <li>parses instances of this protocol buffer</li> <li>transforms the fields we care about</li> <li>creates the necessary <code>SparseTensor</code>s</li> </ul> <p>Don't worry about some of these terms yet. We'll show you an example. And then explain the terms later.</p>"},{"location":"examples/prensor_playground/#install-required-packages-internal-colab-users-skip","title":"Install required packages (internal colab users: skip)\u00b6","text":""},{"location":"examples/prensor_playground/#some-pretty-printing-and-imports","title":"Some Pretty Printing and Imports\u00b6","text":"<p>(not the \"real\" work yet)</p>"},{"location":"examples/prensor_playground/#the-real-work","title":"The real work:\u00b6","text":"<p>A function that parses our structured data (protobuffers) into tensors:</p>"},{"location":"examples/prensor_playground/#lets-see-it-in-action","title":"Lets see it in action:\u00b6","text":""},{"location":"examples/prensor_playground/#digging-far-deeper","title":"Digging Far Deeper\u00b6","text":"<p>Interested and want to learn more? Read on...</p> <p>Let's define several terms we mentioned before:</p>"},{"location":"examples/prensor_playground/#prensor","title":"Prensor\u00b6","text":"<p>A Prensor (protobuffer + tensor) is a data structure storing the data we work on. We use protobuffers a lot at Google. <code>struct2tensor</code> can support other structured formats, too.</p> <p>For example, throughout this colab we will be using proto <code>struct2tensor.test.Session</code>. A schematic visualization of a selected part of the prensor from that proto looks like:</p>"},{"location":"examples/prensor_playground/#struct2tensor-query","title":"struct2tensor Query\u00b6","text":"<p>A struct2tensor query transforms a Prensor into another Prensor.</p> <p>For example, <code>broadcast</code> is a query that replicates a node as a child of one of its siblings.</p> <p>Applying</p> <pre><code>broadcast(\n    source_path=\"session.session_id\",\n    sibling=\"event\",\n    new_field_name=\"session_session_id\")\n</code></pre> <p>on the previous tree gives:</p>"},{"location":"examples/prensor_playground/#projection","title":"Projection\u00b6","text":"<p>A projection of paths in a Prensor produces another Prensor with just the selected paths.</p>"},{"location":"examples/prensor_playground/#logical-representation-of-a-projection","title":"Logical representation of a projection\u00b6","text":"<p>The structure of the projected path can be represented losslessly as nested lists. For example, the projection of <code>event.action.number_of_views</code> from the struct2tensorTree formed by the following two instances of <code>struct2tensor.test.Session</code>:</p> <pre><code>{\n  event { action { number_of_views: 1} action { number_of_views: 2} action {} }\n  event {}\n}, {\n  event { action { number_of_views: 3} }\n}\n</code></pre> <p>is:</p> <pre><code>[  # the outer list has two elements b/c there are two Session protos.\n [  # the first proto has two events\n   [[1],[2],[]],  # 3 actions, the last one does not have a number_of_views.\n   [], # the second event does not have action\n ],\n [ # the second proto has one event\n   [[3]],\n ],\n]\n</code></pre>"},{"location":"examples/prensor_playground/#representing-nested-lists-with-tfsparsetensor","title":"Representing nested lists with <code>tf.SparseTensor</code>\u00b6","text":"<p>struct2tensor uses <code>tf.SparseTensor</code> to represent the above nested list in the projection results. Note that <code>tf.SparseTensor</code> essentially enforces that the lists nested at the same level to have the same length (because the there is a certain size for each dimension), therefore this representation is lossy. The above nested lists, when written as a SparseTensor will look like:</p> <pre><code>tf.SparseTensor(\n  dense_shape=[2, 2, 3, 1],  # each is the maximum length of lists at the same nesting level.\n  values = [1, 2, 3],\n  indices = [[0, 0, 0, 0], [0, 0, 1, 0], [1, 0, 0, 0]]\n)\n</code></pre> <p>Note that the last dimension is useless: the index of that dimension will always be 0 for any present value because number_of_views is an optional field. So struct2tensors library will actually \"squeeze\" all the optional dimensions.</p> <p>The actual result would be:</p>"},{"location":"examples/prensor_playground/#common-struct2tensor-queries","title":"Common struct2tensor Queries\u00b6","text":""},{"location":"examples/prensor_playground/#promote","title":"<code>promote</code>\u00b6","text":"<p>Promotes a node to become a sibling of its parent. If the node is repeated, then all its values are concatenated (the order is preserved).</p>"},{"location":"examples/prensor_playground/#broadcast","title":"<code>broadcast</code>\u00b6","text":"<p>Broadcasts the value of a node to one of its sibling. The value will be replicated if the sibling is repeated. This is similar to TensorFlow and Numpy's broadcasting semantics.</p>"},{"location":"examples/prensor_playground/#promote_and_broadcast","title":"<code>promote_and_broadcast</code>\u00b6","text":"<p>The query accepts multiple source fields and a destination field. For each source field, it first promotes it to the least common ancestor with the destination field (if necessary), then broadcasts it to the destination field (if necessary).</p> <p>Usually for the purpose of machine learning, this gives a reasonable flattened representation of nested structures.</p>"},{"location":"examples/prensor_playground/#map_field_values","title":"<code>map_field_values</code>\u00b6","text":"<p>Creates a new node that is a sibling of a leaf node. The values of the new node are results of applying the given function to the values of the source node.</p> <p>Note that the function provided takes 1-D tensor that contains all the values of the source node as input and should also output a 1-D tensor of the same size, and it should build TF ops.</p>"},{"location":"examples/prensor_playground/#reroot","title":"<code>reroot</code>\u00b6","text":"<p>Makes the given node the new root of the struct2tensorTree. This has two effects:</p> <ul> <li>restricts the scope of the struct2tensorTree<ul> <li>The field paths in all the following queries are relative to the new root</li> <li>There's no way to refer to nodes that are outside the subtree rooted at the new root.</li> </ul> </li> <li>changes the batch dimension.</li> </ul>"},{"location":"examples/prensor_playground/#proto-map","title":"Proto Map\u00b6","text":"<p>You can specify a key for the proto map field in a path via brackets.</p> <p>Given the following tf.Example:</p> <pre><code>features {\n  feature {\n    key: \"my_feature\"\n    value {\n      float_list {\n        value: 1.0\n      }\n    }\n  }\n  feature {\n    key: \"other_feature\"\n    value {\n      bytes_list {\n        value: \"my_val\"\n      }\n    }\n  }\n}\n</code></pre> <p>To get the values of <code>my_feature</code> and <code>other_feature</code>, we can <code>promote_and_broadcast</code> and <code>project</code> the following paths: <code>features.feature[my_feature].float_list.value</code> and <code>features.feature[other_feature].bytes_list.value</code></p> <p>This results in the following dict of ragged tensors:</p> <pre><code>{\n  features.my_new_feature: &lt;tf.RaggedTensor [[[1.0]]]&gt;,\n  features.other_new_feature: &lt;tf.RaggedTensor [[[b'my_val']]]&gt;\n}\n</code></pre> <p>Note: we renamed <code>my_feature</code> to <code>my_new_feature</code> in the <code>promote_and_broadcast</code> (and similarly for <code>other_feature</code>).</p>"},{"location":"examples/prensor_playground/#apache-parquet-support","title":"Apache Parquet Support\u00b6","text":"<p><code>struct2tensor</code> offers an Apache Parquet tf.DataSet that allows reading from a Parquet file and apply queries to manipulate the structure of the data.</p> <p>Because of the powerful struct2tensor library, the dataset will only read the Parquet columns that are required. This reduces I/O cost if we only need a select few columns.</p>"},{"location":"examples/prensor_playground/#preparation","title":"Preparation\u00b6","text":"<p>Please run the code cell at Some Pretty Printing and Imports to ensure that all required modules are imported, and that pretty print works properly.</p>"},{"location":"examples/prensor_playground/#prepare-the-input-data","title":"Prepare the input data\u00b6","text":""},{"location":"examples/prensor_playground/#example","title":"Example\u00b6","text":"<p>We will use a sample Parquet data file (dremel_example.parquet), which contains data based on the example used in this paper: https://storage.googleapis.com/pub-tools-public-publication-data/pdf/36632.pdf</p> <p>The file dremel_example.parquet has the following schema:</p> <pre><code>message Document {\n  required int64 DocId;\n  optional group Links {\n    repeated int64 Backward;\n    repeated int64 Forward; }\n  repeated group Name {\n    repeated group Language {\n      required string Code;\n      optional string Country; }\n    optional string Url; }}\n</code></pre> <p>and contains the following data:</p> <pre><code>Document\n  DocId: 10\n  Links\n    Forward: 20\n    Forward: 40\n    Forward: 60\n  Name\n    Language\n      Code: 'en-us'\n      Country: 'us'\n    Language\n      Code: 'en'\n    Url: 'http://A'\n  Name\n    Url: 'http://B'\n  Name\n    Language\n      Code: 'en-gb'\n      Country: 'gb'\nDocument\n  DocId: 20\n  Links\n    Backward: 10\n    Backward: 30\n    Forward: 80\n  Name\n    Url: 'http://C'\n</code></pre> <p>In this example, we will promote and broadcast the field <code>Links.Forward</code> and project it.</p> <p>batch_size will be the number of records (<code>Document</code>) per prensor. This works with optional and repeated fields, and will be able to batch the entire record.</p> <p>Feel free to try <code>batch_size = 2</code> in the below code. (Note this parquet file only has 2 records (<code>Document</code>) total).</p>"}]}